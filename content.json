{"meta":{"title":"ZJYelizaveta's Blog","subtitle":"有幸在那一天，遇到你，最了不起的你。","description":"有幸在那一天，遇到你，最了不起的你。","author":"ZJYelizaveta","url":"http://yoursite.com"},"pages":[{"title":"Links","date":"2017-10-21T15:19:30.000Z","updated":"2017-10-21T15:21:18.552Z","comments":true,"path":"Links/index.html","permalink":"http://yoursite.com/Links/index.html","excerpt":"","text":"chrt’s Bloghamsterwk’s BlogSengxian’s BlogBarrin’s Blog"},{"title":"categories","date":"2017-10-22T02:27:29.000Z","updated":"2017-10-22T02:27:29.692Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2017-10-21T15:28:32.000Z","updated":"2017-10-21T15:29:51.397Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"I’m an OIer.来自武汉二中，现役高二 QAQ颜控，沉迷于羽生结弦在初中同桌的安利下喜欢上了《空中浩劫》，尤其喜欢在坐飞机之前看嗯，然后没有了想和学长学姐一起去THU 我一直相信一句话：“无论你遇见谁，他都是你生命里该出现的人，绝非偶然，他一定会教会你一些什么。”所以我也相信：“无论我走到哪里，那都是我该去的地方，经历一些我该经历的事，遇见我该遇见的人。” 联系方式：ZJYelizaveta@outlook.comQQ：贰肆叁玖伍玖玖柒陆零(2439599760)很希望认识你们！"}],"posts":[{"title":"NOIP 2011 整理","slug":"NOIP-2011-整理","date":"2017-10-23T06:42:29.000Z","updated":"2017-10-23T14:46:02.462Z","comments":true,"path":"2017/10/23/NOIP-2011-整理/","link":"","permalink":"http://yoursite.com/2017/10/23/NOIP-2011-整理/","excerpt":"Day 1铺地毯描述为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。 注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。 $0 \\leq n \\leq 1000, 0 \\leq a, b, g, k \\leq 10^{5}$","text":"Day 1铺地毯描述为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。 注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。 $0 \\leq n \\leq 1000, 0 \\leq a, b, g, k \\leq 10^{5}$ 分析题目较为简单，是 NOIP Day1 T1 的水准。 $\\Theta(n)$ 的扫一遍，如果这个点包含在某一张地毯中则更新答案。 代码12345678910111213141516171819202122232425262728293031323334353637383940// Created by ZJYelizaveta on 2017年09月02日 星期六 09时13分58秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int INF = 0x3f3f3f3f;int n;struct Carpet &#123; int a, b, g, k;&#125;c[MAX_N];int fx, fy;int ans;int main()&#123; n = readIn(); for (int i = 0; i &lt; n; ++i) &#123; c[i].a = readIn(), c[i].b = readIn(), c[i].g = readIn(), c[i].k = readIn(); &#125; fx = readIn(), fy = readIn();//final x and final y ans = -1; for (int i = 0; i &lt; n; ++i) &#123; int x = c[i].a + c[i].g; int y = c[i].b + c[i].k; if (c[i].a &lt;= fx &amp;&amp; fx &lt;= x &amp;&amp; c[i].b &lt;= fy &amp;&amp; fy &lt;= y) ans = i + 1; &#125; printf(\"%d\\n\", ans); return 0;&#125; 选择客栈描述丽江河边有 $n$ 家很有特色的客栈，客栈按照其位置顺序从 $1$ 到 $n$ 编号。每家客栈都按照某一种色调进行装饰（总共 $k$ 种，用整数 $0 \\sim k-1$ 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $p$。他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $p$ 元的咖啡店小聚。 $2 \\leq n \\leq 200000, 0 &lt; k \\leq 50, 0 \\leq p \\leq 100, 0 \\leq$ 最低消费 $\\leq 100$ 分析$\\Theta(n^{2})$ 枚举可以拿到 60 分，我也不知道为什么是 60 呢！竟然没有越界qwq $\\Theta(n^{2})$ 这样的时间复杂度肯定是不行的，考虑优化时间复杂度到 $\\Theta(n)$ 或 $\\Theta(nlogn)$，同样也可以考虑关于关于颜色 $k$ 的时间复杂度哒。 像这种有关区间的计数，可以考虑固定其中一个端点，然后扫一下区间。 如果 $q[i].b \\leq p$，令 $pos = i$ 则计算： $sum[]$ 表示 $pos$ 以左颜色 $q[i].a$ 的颜色个数。 $cnt[]$ 表示当前颜色 $q[i].a$ 的个数。 $lastPos[]$ 表示颜色 $q[i].a$ 上一次出现的位置。 计算之后，更新 $cnt[], lastPos[]$ 即可。 代码$60 \\%$ 12345678910111213141516171819202122232425262728293031323334353637383940414243// Created by ZJYelizaveta on Thursday, October 19, 2017 AM08:49:42 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int INF = 0x3f3f3f3f;int n, k, p;struct Hotel &#123; int c, p;&#125;a[MAX_N];int ans;int main()&#123; n = readIn&lt;int&gt;(), k = readIn&lt;int&gt;(), p = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) a[i].c = readIn&lt;int&gt;(), a[i].p = readIn&lt;int&gt;(); ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int color = a[i].c; for (int j = i + 1; j &lt;= n; ++j) if (a[j].c == color) &#123;// printf(\"%d %d\\n\", i, j); for (int k = i; k &lt;= j; ++k) &#123; if (a[k].p &lt;= p) &#123; ++ans; break; &#125; &#125; &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125; $100 \\%$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Created by ZJYelizaveta on Thursday, October 19, 2017 PM03:37:49 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 200000 + 3;const int MAX_K = 50 + 3;const int MAX_P = 100 + 3;const int INF = 0x3f3f3f3f;int n, m, p;struct Hotel &#123; int a, b;&#125;q[MAX_N];int sum[MAX_K], cnt[MAX_K], lastPos[MAX_K];int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(), p = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) q[i].a = readIn&lt;int&gt;(), q[i].b = readIn&lt;int&gt;(); int pos = 0, ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (q[i].b &lt;= p) pos = i; // if (pos &gt;= lastPos[q[i].a]) sum[q[i].a] = cnt[q[i].a]; ans += sum[q[i].a]; ++cnt[q[i].a]; lastPos[q[i].a] = i; &#125; printf(\"%d\\n\", ans); return 0;&#125; mayan 游戏描述Mayan puzzle 是最近流行起来的一个游戏。游戏界面是一个 $7$ 行 $5$ 列的棋盘，上面堆放着一些方块，方块不能悬空堆放，即方块必须放在最下面一行，或者放在其他方块之上。游戏通关是指在规定的步数内消除所有的方块，消除方块的规则如下： 每步移动可以且仅可以沿横向（即向左或向右）拖动某一方块一格：当拖动这一方 块时，如果拖动后到达的位置（以下称目标位置）也有方块，那么这两个方块将交换位置（参见输入输出样例说明中的图 6 到图 7)；如果目标位置上没有方块，那么被拖动的方块将从原来的竖列中抽出，并从目标位置上掉落（直到不悬空,参见下面图 1 和图 2）； 任一时刻，如果在一横行或者竖列上有连续三个或者三个以上相同颜色的方块，则 它们将立即被消除（参见图 1 到图 3）。 注意： a) 如果同时有多组方块满足消除条件，几组方块会同时被消除（例如下面图 4，三个颜色为 $1$ 的方块和三个颜色为 $2$ 的方块会同时被消除，后剩下一个颜色为 $2$ 的方块）。 b) 当出现行和列都满足消除条件且行列共享某个方块时，行和列上满足消除条件的所有方块会被同时消除（例如下面图 5 所示的情形，$5$ 个方块会同时被消除）。 方块消除之后，消除位置之上的方块将掉落，掉落后可能会引起新的方块消除。注意：掉落的过程中将不会有方块的消除。 上面图 1 到图 3 给出了在棋盘上移动一块方块之后棋盘的变化。棋盘的左下角方块的坐标为 $(0, 0)$ 将位于 $(3, 3)$ 的方块向左移动之后，游戏界面从图 1 变成图 2 所示的状态，此时在一竖列上有连续三块颜色为 $4$ 的方块，满足消除条件，消除连续 $3$ 块颜色为 $4$ 的方块后，上方的颜色为 $3$ 的方块掉落，形成图 3 所示的局面。 分析模拟的时候就是连暴力都不想写了，然后改题目的时候由于代码能力较差 写 + 调试 用了一上午，Sign 思路很简洁，因为已经限制了步数，那么我们用 dfs 就可以求解了，至于下落和消除就是模拟。 但是单纯的 dfs 回溯是不够的，我们需要一些剪枝和优化： 因为我们要求方案的字典序最小，所以我们在平移的时候遵从一下几点 在中间的时候向右交换（左边那个向右边移动字典序更小） 当左边没有格的时候向左移动 当右边的格子和自己相同时跳过 最优化剪枝：不移动相同的色块 可行性剪枝：若某种颜色的方块数量小于 $3$ 则无解 然后就是模拟 + 爆搜了qwq 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165// Created by ZJYelizaveta on Monday, October 23, 2017 AM09:11:19 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#pragma GCC optimize(3)#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 7 + 3;const int INF = 0x3f3f3f3f;int n;int color[MAX_N][MAX_N];int cnt[MAX_N + 3];struct Node &#123; int x, y, flag;&#125;ans[MAX_N];inline bool empty() &#123; for (int i = 0; i &lt; 5; ++i) &#123; for (int j = 0; j &lt; 7; ++j) if (color[i][j]) return false; // &#125; return true;&#125;int num[10][10];inline void drop() &#123; memset(num, -1, sizeof num); for (int i = 0; i &lt; 5; ++i) &#123; int k = 0; for (int j = 0; j &lt; 7; ++j) &#123; if (color[i][j]) num[i][k++] = j; &#125; &#125; for (int i = 0; i &lt; 5; ++i) &#123; for (int j = 0; j &lt; 7; ++j) &#123; color[i][j] = num[i][j] == -1 ? 0 : color[i][num[i][j]]; // drop the square which in the middle of the row without another square beneath it &#125; &#125;/* for (int i = 0; i &lt; 5; ++i) &#123; for (int j = 0; j &lt; 7; ++j) printf(\"%d \", color[i][j]); printf(\"\\n\"); &#125;*/ return; //&#125;bool clear() &#123; bool flag = 0; for (int i = 0; i &lt; 3; ++i) &#123; for (int j = 0; j &lt; 7; ++j) if (color[i][j]) &#123; int k; for (k = i; k + 1 &lt; 5 &amp;&amp; color[k + 1][j] == color[i][j]; ++k); if (k - i &gt;= 2) &#123; for (int l = i; l &lt;= k; l++) &#123; int up = j, down = j; while (up + 1 &lt; 7 &amp;&amp; color[l][up + 1] == color[i][j]) up++; while (down - 1 &gt;= 0 &amp;&amp; color[l][down - 1] == color[i][j]) down--; if (up - down &gt;= 2) &#123; for (int h = down; h &lt;= up; ++h) color[l][h] = 0; &#125; &#125; for (int l = i; l &lt;= k; ++l) color[l][j] = 0; flag = true; &#125; &#125; &#125; for (int i = 0; i &lt; 5; ++i) &#123; for (int j = 0; j &lt; 5; ++j) if (color[i][j]) &#123; int k; for (k = j; k + 1 &lt; 7 &amp;&amp; color[i][k + 1] == color[i][j]; k++); if (k - j &gt;= 2) &#123; for (int h = j; h &lt;= k; ++h) &#123; int lft = i,rht = i; while (lft - 1 &gt;= 0 &amp;&amp; color[lft - 1][h] == color[i][j]) lft--; while (rht + 1 &lt; 7 &amp;&amp; color[rht + 1][h] == color[i][j]) rht++; if (rht - lft &gt;= 2) &#123; for (int l = lft; l &lt;= rht; ++l) color[l][h] = 0; &#125; &#125; for (int h = j; h &lt;= k; h++) color[i][h] = 0; flag = 1; &#125; &#125; &#125; if (flag) return true; else return false;&#125;void dfs(int step) &#123; if (step &gt; n) &#123; if (empty()) &#123; for (int i = 1; i &lt;= n; ++i) &#123; if (ans[i].flag) &#123; printf(\"%d %d %d\\n\", ans[i].x + 1, ans[i].y, -1); // move the square which on [i, j]'s right to the left &#125; else &#123; printf(\"%d %d %d\\n\", ans[i].x, ans[i].y, 1); &#125; &#125; exit(0); &#125; return; &#125; int cnt[12]; memset(cnt, 0, sizeof cnt); // caculate for (int i = 0; i &lt; 5; ++i) &#123; for (int j = 0; j &lt; 7; ++j) ++cnt[color[i][j]]; &#125; for (int i = 1; i &lt;= 10; ++i) // if there is a color which its quantity is less than 3, it means that in this situation we have no solution if (cnt[i] != 0 &amp;&amp; cnt[i] &lt; 3) return; for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 7; ++j) if (color[i][j] != color[i + 1][j]) &#123; // if the color between [i, j] and [i + 1, j] are the same, we don't need to swap them ans[step].x = i; ans[step].y = j; ans[step].flag = (!color[i][j]); int temp[10][10]; memcpy(temp, color, sizeof temp); swap(color[i][j], color[i + 1][j]); drop(); while (clear()) drop(); dfs(step + 1); ans[step].x = 0; ans[step].y = 0, ans[step].flag = 0; memcpy(color, temp, sizeof color); &#125; &#125;&#125;int main()&#123; n = readIn&lt;int&gt;(); for (int i = 0; i &lt; 5; ++i) &#123; for (int j = 0; ; ++j) &#123; color[i][j] = readIn&lt;int&gt;(); if (color[i][j] == 0) break;// printf(\"%d \", color[i][j]); &#125;// printf(\"\\n\"); &#125; dfs(1); printf(\"-1\\n\"); return 0;&#125; Day 2计算系数描述给定一个多项式 $( ax + by )^{k}$ ，请求出多项式展开后 $x^{n} y^{m}$ 项的系数。 $0 \\leq k \\leq 1000, 0 \\leq n, m \\leq k$，且 $n + m = k, 0 \\leq a, b \\leq 10^{6}$ 分析就是二项式定理呀 qwq 对于不带系数的形式，我们有如下的形式： (x + y)^{n} = \\sum_{k = 0}^{n} \\binom{n}{k}x^{n - k}y^{k}那么对于有系数的形式呢？ (ax + by)^{k} = \\sum_{i = 0}^{k}\\binom{k}{i}a^{k - i}b^{i}x^{k - i}y^{i}这样一来，对于 $x^{n}y^{m}$ 这一项的系数我们可以将其表示为： ans = a^{n}b^{m}\\binom{k}{n}处理组合数的时候我们可以将其分为阶层 $fac[]$ 和逆元 $inv[]$ 来处理，其中我们可以 $\\Theta(n)$ 预处理处阶层，并在 $\\Theta(n + logn)$ 的时间复杂度内预处理处逆元。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// Created by ZJYelizaveta on Monday, September 04, 2017 AM09:19:33 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0; int f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int INF = 0x3f3f3f3f;const int MOD = 10007;int k, n, m;int fac[MAX_N], inv[MAX_N];ll ans;inline void exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if(b == 0) &#123;x = 1, y = 0;&#125; else&#123; exgcd(b, a % b, y, x); y -= (a / b) * x; &#125;&#125;inline int calculate(int a, int b)&#123; int x = 0, y = 0; exgcd(a, b, x, y); return (x % b + b) % b;&#125;inline void prepare()&#123; fac[0] = 1; for(int i = 1; i &lt;= k; ++i) fac[i] = fac[i - 1] * i % MOD;// for(int i = 1; i &lt;= n; ++i) printf(\"f[%d] = %lld\\n\", i, fac[i]); inv[k] = calculate(fac[k], MOD); for(int i = k - 1; i &gt;= 0; --i) inv[i] = inv[i + 1] * (i + 1) % MOD;// for(int i = 1; i &lt;= n; ++i) printf(\"inv[%d] = %lld\\n\", i, inv[i]);&#125;inline ll quickPow(int a, int b) &#123; ll res = 1; while (b) &#123; if (b &amp; 1) res = 1ll * res * a % MOD; a = 1ll * a * a % MOD; b &gt;&gt;= 1; &#125; return res;&#125;inline void solve(int a, int b) &#123; ans = (ll)quickPow(a, n) * quickPow(b, m) % MOD;// printf(\"%lld\\n\", ans); ans = (ll)ans * fac[k] % MOD * inv[n] % MOD * inv[m] % MOD; printf(\"%lld\\n\", ans);&#125;int main()&#123; int a = readIn(), b = readIn(); k = readIn(), n = readIn(), m = readIn(); prepare(); ans = 0; if (n == 0) &#123; ans = quickPow(b, k); printf(\"%lld\\n\", (ans % MOD + MOD) % MOD); &#125; else if (m == 0) &#123; ans = quickPow(a, k); printf(\"%lld\\n\", (ans % MOD + MOD) % MOD); &#125; else solve(a, b); return 0;&#125; 聪明的质监员描述小 T 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 $n$ 个矿石，从 $1$ 到 $n$ 逐一编号，每个矿石都有自己的重量 $w_{i}$ 以及价值 $v_{i}$ 。检验矿产的流程是： 给定 $m$ 个区间 $[L_{i} ,R_{i}]$。 选出一个参数 $W$。 对于一个区间 $[L_{i} ,R_{i} ]$，计算矿石在这个区间上的检验值 $Y_{i}$： Y_{i} = \\sum_{j}1 \\times \\sum_{j}v_{j}, j \\in [L_{i}, R_{i}] 且 w_{j} \\geq W, j是矿石编号 这批矿产的检验结果 $Y$ 为各个区间的检验值之和。即：$Y = \\sum_{i = 1}^{m}Y_{i}$若这批矿产的检验结果与所给标准值 $S$ 相差太多，就需要再去检验另一批矿产。小 T不想费时间去检验另一批矿产，所以他想通过调整参数 $W$ 的值，让检验结果尽可能的靠近标准值 $S$，即使得 $S-Y$ 的绝对值最小。请你帮忙求出这个最小值。 $1 \\leq n, m \\leq 2 \\times 10^{5}, 0 &lt; w_{i}, v_{i} \\leq 10^{6}, 0 &lt; S \\leq 10^{12}, 1 \\leq L_{i} \\leq R_{i} \\leq n$ 分析我们需要最小化 $S - Y$ 的绝对值，因为 $S$ 是定值，那么我们要最小化 $Y$ 的值。 最极端的我们可以枚举 $W$ 的所有可能值 $0 \\sim max(w[i])$ ，然后 $\\Theta(n^{3})$ 计算。 这应该是我们暴力的思路，但是作为正解而言时间复杂度太高了，考虑如何优化时间复杂度。 因为 $W$ 的取值是线性的，所以考虑 $\\Theta(logn)$ 二分 $W$，然后 $\\Theta(n^{2})$ 来计算和判断。 我们把枚举 $W$ 的时间复杂度由 $\\Theta(n)$ 降到了 $\\Theta(logn)$ 但是由于计算和判断的时间复杂度很大，所以我们仍然只能拿到 50 分，考虑优化计算和判断的时间复杂度。 用 $cnt[i]$ 表示前 $i$ 个矿石中满足条件的个数， $sum[i]$ 表示前 $i$ 个满足条件的矿石的价值之和。这样一来我们将计算和判断的时间复杂度优化至 $\\Theta(n)$。 总时间复杂度为 $\\Theta(nlogn)$。 P.S. 在进行二维求和计算的时候，可以考虑用前缀和来优化，使得计算的时候时间复杂度下降一个 $n$（由 $\\Theta(n^{2})$ 到 $\\Theta(n)$）。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// Created by ZJYelizaveta on Monday, September 04, 2017 AM10:17:46 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 200000 + 3;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3fll;int n, m; ll S;int w[MAX_N], v[MAX_N];int l[MAX_N], r[MAX_N];ll cnt[MAX_N], sum[MAX_N];ll ans;inline bool check(int W) &#123; memset(cnt, 0, sizeof cnt); memset(sum, 0, sizeof sum); ll res = 0; // 前缀和优化 for (int i = 1; i &lt;= n; ++i) &#123; cnt[i] = cnt[i - 1], sum[i] = sum[i - 1]; if (w[i] &gt;= W) &#123; ++cnt[i]; sum[i] += v[i]; &#125; &#125;// printf(\"%d\\n\", W);// for (int i = 1; i &lt;= n; ++i) printf(\"%lld \", sum[i]); printf(\"\\n\");// for (int i = 1; i &lt;= n; ++i) printf(\"%lld \", cnt[i]); printf(\"\\n\"); for (int i = 1; i &lt;= m; ++i) &#123; res += (ll)(cnt[r[i]] - cnt[l[i] - 1]) * (sum[r[i]] - sum[l[i] - 1]); &#125; ans = min(ans, abs(S - res)); if (res &lt; S) return false; return true;&#125;int main()&#123; n = readIn(), m = readIn(); scanf(\"%lld\", &amp;S);// printf(\"%lld\\n\", S); int MAX = -INF; for (int i = 1; i &lt;= n; ++i) &#123; w[i] = readIn(), v[i] = readIn(); MAX = max(MAX, w[i]); &#125; for (int i = 1; i &lt;= m; ++i) l[i] = readIn(), r[i] = readIn(); ans = INFLL; int l = 0, r = MAX + 1; while (r - l &gt; 1) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) l = mid; else r = mid; &#125; printf(\"%lld\\n\", ans);// fprintf(stderr, \"Time used : %.3f\\n\", (double)clock() / CLOCKS_PER_SEC); return 0;&#125; 观光公交描述风景迷人的小城 Y 市，拥有 $n$ 个美丽的景点。由于慕名而来的游客越来越多，Y 市特意安排了一辆观光公交车，为游客提供更便捷的交通服务。观光公交车在第 $0$ 分钟出现在 $1$ 号景点,随后依次前往 $2,3,4, \\cdots , n$ 号景点。从第 $i$ 号景点开到第 $i+1$ 号景点需要 $D_{i}$ 分钟。任意时刻，公交车只能往前开，或在景点处等待。设共有 $m$ 个游客，每位游客需要乘车 $1$ 次从一个景点到达另一个景点，第 $i$ 位游客在$T_{i}$ 分钟来到景点 $A_{i}$ ，希望乘车前往景点 $B_{i} (A_{i} &lt;B_{i} )$。为了使所有乘客都能顺利到达目的地，公交车在每站都必须等待需要从该景点出发的所有乘客都上车后才能出发开往下一景点。假设乘客上下车不需要时间。一个乘客的旅行时间，等于他到达目的地的时刻减去他来到出发地的时刻。因为只有一辆观光车，有时候还要停下来等其他乘客，乘客们纷纷抱怨旅行时间太长了。于是聪明的司机 ZZ 给公交车安装了 $k$ 个氮气加速器，每使用一个加速器，可以使其中一个 $D_{i}$ 减 $1$。对于同一个 $D_{i}$ 可以重复使用加速器，但是必须保证使用后 $D_{i}$ 大于等于 $0$。那么 ZZ 该如何安排使用加速器，才能使所有乘客的旅行时间总和最小？ $1 \\leq n \\leq 1000, 1 \\leq m \\leq 10000, 0 \\leq k \\leq 100000, 0 \\leq D_{i} \\leq 100, 0 \\leq T_{i} \\leq 100000$ 分析模拟的时候没有什么思路，好像有点费用流的感觉（一定是我的错觉），但是还是只写了特判的 30 分，Sign 原来是 贪心 + 模拟 qwq 首先，我们可以先预处理出结点 $i$ 最晚出发的人的出发时间 $last[i]$ ，以及结点 $i$ 在不使用氮气加速的时候公交到达的时间 $arv[i]$ ，还有在第 $i$ 站下车的人数（对答案有贡献）。 这样我们可以计算出，在不使用氮气加速的时候，所有旅客的旅行时间之和： ans = \\sum_{i = 1}^{m}arv[b[i]] - t[i]因为 $t[i]$ 是不会改变的，如果我们想令 $ans$ 最小，那么我们需要最小化 $arv[b[i]]$ 。 如何可以最大化的最小化 $arv[b[i]]$ 呢？我们要使被影响的结点尽可能多，那么我们每一次 $\\Theta(n)$ 线性扫一次。 考虑对于结点 $i$ ，如果有 $arv[i + 1] &gt; last[i + 1]$ ，那么在这个时候我们在 $i$ 处使用氮气不仅对 $i + 1$ 这个结点有贡献还有可能对之后的结点也有贡献。 若 $arv[i + 1] \\leq last[i + 1]$ ，那么如果在 $i$ 处使用氮气，那么只会对 $i + 1$ 处产生贡献，因为在景点停靠等待使得后面的景点的到达时间依然没有改变。 因此，我们在 $i$ 处使用加速器对别的景点的贡献是可以递推出来的。 求出了在 $i$ 处使用加速器可以影响的最远的点，那么影响的总时间就等于在每个被影响的点下车的人数之和乘以使用加速器的数量，然后记得更新。 最后的答案为 ans = (\\sum_{i = 1}^{m}arv[b[i]] - t[i]) - maxDecrease代码特判 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Created by ZJYelizaveta on Monday, September 04, 2017 AM11:10:09 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int MAX_M = 10000 + 3;const int MAX_K = 100000 + 3;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3fll;int n, m, k;int d[MAX_N];int t[MAX_M], a[MAX_M], b[MAX_M];int arv[MAX_N], st[MAX_N];int ans;inline void solve1() &#123; ans = 0; memset(arv, 0, sizeof arv); memset(st, 0, sizeof st); for (int i = 1; i &lt;= m; ++i) st[a[i]] = max(st[a[i]], t[i]); arv[1] = st[1]; for (int i = 2; i &lt;= n; ++i) &#123; arv[i] = max(arv[i - 1], st[i - 1]) + d[i - 1]; &#125;// for (int i = 1; i &lt;= n; ++i) printf(\"%d \", st[i]); printf(\"\\n\");// for (int i = 1; i &lt;= n; ++i) printf(\"%d \", arv[i]); printf(\"\\n\"); for (int i = 1; i &lt;= m; ++i) ans += arv[b[i]] - t[i]; printf(\"%d\\n\", ans);&#125;inline void calculate(int x) &#123; int res = 0; for (int i = 2; i &lt;= x; ++i) &#123; arv[i] = max(arv[i - 1], st[i - 1]) + d[i - 1]; &#125; arv[x + 1] = max(arv[x], st[x]) + d[x] - 1; for(int i = x + 2; i &lt;= n; ++i) &#123; arv[i] = max(arv[i - 1], st[i - 1]) + d[i - 1]; &#125; for (int i = 1; i &lt;= m; ++i) res += arv[b[i]] - t[i];// printf(\"%d\\n\", res); ans = min(ans, res);&#125;inline void solve2() &#123; memset(arv, 0, sizeof arv); memset(st, 0, sizeof st); arv[1] = 0; for (int i = 1; i &lt;= m; ++i) st[a[i]] = max(st[a[i]], t[i]); arv[1] = st[1]; ans = INF; for (int i = 1; i &lt;= n - 1; ++i) calculate(i); printf(\"%d\\n\", ans);&#125;int main()&#123; n = readIn(), m = readIn(), k = readIn(); for (int i = 1; i &lt;= n - 1; ++i) d[i] = readIn(); for (int i = 1; i &lt;= m; ++i) t[i] = readIn(), a[i] = readIn(), b[i] = readIn(); if (k == 0) solve1(); else if (k == 1) solve2(); return 0;&#125; $100 \\%$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int MAX_M = 10000 + 3;const int MAX_K = 100000 + 3;const ll INF = 0x3f3f3f3f3f3f3f3fll;ll n, m, k;ll d[MAX_N];ll t[MAX_M], a[MAX_M], b[MAX_M];ll last[MAX_N], arv[MAX_N], sum[MAX_N];ll cntPerson, numK, from, to;ll ans;inline void prepare() &#123; for (int i = 2; i &lt;= n; i++) arv[i] = max(arv[i - 1], last[i - 1]) + d[i - 1]; for (int i = 2; i &lt;= n; i++) sum[i] += sum[i - 1]; for (int i = 1; i &lt;= m; i++) ans += arv[b[i]] - t[i];// for (int i = 1; i &lt;= n; ++i) printf(\"%d %lld\\n\", i, last[i]);// for (int i = 1; i &lt;= n; ++i) printf(\"%d %lld\\n\", i, sum[i]);// for (int i = 1; i &lt;= n; ++i) printf(\"%d %lld\\n\", i, arv[i]);// printf(\"%d\\n\", ans);&#125;inline bool find() &#123; ll curK = INF, pos = n; cntPerson = 0, numK = INF; for (int i = n - 1; i &gt;= 1; --i) &#123; if (arv[i + 1] &gt; last[i + 1]) curK = min(curK, arv[i + 1] - last[i + 1]); else &#123; curK = arv[i + 1]; // the max number we can decrease pos = i + 1; &#125; if (d[i] &amp;&amp; sum[pos] - sum[i] &gt; cntPerson) &#123; cntPerson = sum[pos] - sum[i]; from = i; to = pos; numK = min(k, min(curK, d[i])); &#125; &#125; return numK;&#125;inline void calculate() &#123; for (int i = from + 1; i &lt;= to; ++i) arv[i] -= numK; k -= numK; d[from] -= numK; ans -= cntPerson * numK;&#125;inline void solve() &#123; while (find()) calculate(); printf(\"%lld\\n\", ans);&#125;int main()&#123;// freopen(\"testdata.in\", \"r\", stdin); n = readIn&lt;ll&gt;(), m = readIn&lt;ll&gt;(), k = readIn&lt;ll&gt;(); for (int i = 1; i &lt;= n - 1; ++i) d[i] = readIn&lt;ll&gt;(); for (int i = 1; i &lt;= m; ++i) &#123; t[i] = readIn&lt;ll&gt;(), a[i] = readIn&lt;ll&gt;(), b[i] = readIn&lt;ll&gt;(); ++sum[b[i]]; last[a[i]] = max(last[a[i]], t[i]); &#125; prepare(); solve(); return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"NOIP","slug":"NOIP","permalink":"http://yoursite.com/tags/NOIP/"},{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"},{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/二分/"}]},{"title":"Hello World!","slug":"hello-world","date":"2017-10-22T03:03:05.806Z","updated":"2017-09-08T15:29:58.716Z","comments":true,"path":"2017/10/22/hello-world/","link":"","permalink":"http://yoursite.com/2017/10/22/hello-world/","excerpt":"I’m an OIer.来自武汉二中，现役高二 QAQ","text":"I’m an OIer.来自武汉二中，现役高二 QAQ 习惯Blog上的第一篇文章写 Hello World12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; cout &lt;&lt; \"Hello World!\" &lt;&lt; endl; return 0;&#125; 我一直相信一句话：“无论你遇见谁，他都是你生命里该出现的人，绝非偶然，他一定会教会你一些什么。”所以我也相信：“无论我走到哪里，那都是我该去的地方，经历一些我该经历的事，遇见我该遇见的人。”","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"「BZOJ 2301」「HAOI2011」Problem b","slug":"「BZOJ-2301」「HAOI2011」Problem-b","date":"2017-09-28T07:44:48.000Z","updated":"2017-10-21T08:43:09.845Z","comments":true,"path":"2017/09/28/「BZOJ-2301」「HAOI2011」Problem-b/","link":"","permalink":"http://yoursite.com/2017/09/28/「BZOJ-2301」「HAOI2011」Problem-b/","excerpt":"题目地址 描述对于给出的 $n$ 个询问，每次求有多少个数对 $(x,y)$，满足 $a \\leq x \\leq b$，$c \\leq y \\leq d$，且 $gcd(x,y) = k$。$gcd(x,y)$ 函数为 $x$ 和 $y$ 的最大公约数。 $1 \\leq n\\leq50000，1\\leq a\\leq b\\leq 50000，1\\leq c \\leq d\\leq 50000，1\\leq k \\leq 50000$","text":"题目地址 描述对于给出的 $n$ 个询问，每次求有多少个数对 $(x,y)$，满足 $a \\leq x \\leq b$，$c \\leq y \\leq d$，且 $gcd(x,y) = k$。$gcd(x,y)$ 函数为 $x$ 和 $y$ 的最大公约数。 $1 \\leq n\\leq50000，1\\leq a\\leq b\\leq 50000，1\\leq c \\leq d\\leq 50000，1\\leq k \\leq 50000$ 分析这是一个计算满足 gcd(i, j) = k 的 i, j 个数的题目，这样的模型经常出现。 这里我们默认 $n \\leq m$，如果不满足就交换。令 $f(k)$ 为 $gcd(i, j) = k$ 的个数，$g(k)$ 为 $k \\mid gcd(i, j)$ 的个数。 那么有以下关系：g(k) = \\sum_{d = 1}^{\\left \\lfloor \\frac{n}{k} \\right \\rfloor}f(d \\times k)我们需要求 $f(k)$，通过反演我们得到： f(k) = \\sum_{d = 1}^{\\left \\lfloor \\frac{n}{k} \\right \\rfloor}g(d \\times k)\\mu(d)那么这里的瓶颈就是如何快速求出 $g(d \\times k)$，首先考虑如何快速求出 $g(k)$，因为 $i = k \\times x_{1}, j = k \\times y_{1}$，我们只需要求出来有多少对满足条件的 $x_{1}, y_{1}$，即可求出 $g(k)$，因此有： g(k) = \\left \\lfloor \\frac{n}{k} \\right \\rfloor\\left \\lfloor \\frac{m}{k} \\right \\rfloor那么原式可改写为：f(k) = \\sum_{d = 1}^{\\left \\lfloor \\frac{n}{k} \\right \\rfloor}\\mu(d)\\left \\lfloor \\frac{n}{kd} \\right \\rfloor\\left \\lfloor \\frac{m}{kd} \\right \\rfloor我们可以暴力计算在 $\\Theta(n + T\\frac{n}{k})$ 的时间内算出来，但是时间复杂度仍然太高，考虑如何降低时间复杂度。 如之前所说，算法的瓶颈在于如何快速计算 $g(d \\times k)$，这里可以用 分块 来解决。 如图所示，是 $n = 32, m = 40, k = 2$ 的 $\\left \\lfloor \\frac{n}{dk} \\right \\rfloor,\\left \\lfloor \\frac{m}{dk} \\right \\rfloor, \\mu(d)$ 的取值。 $1 \\leq d \\leq \\sqrt n$，$d$ 最多有 $\\sqrt n$ 个取值，$\\left \\lfloor \\frac{n}{d} \\right \\rfloor$ 最多有 $\\left \\lfloor \\sqrt n \\right \\rfloor$ 个不同的取值。 $\\sqrt n + 1 \\leq d \\leq n$，$\\left \\lfloor \\frac{n}{d} \\right \\rfloor \\leq \\left \\lfloor \\sqrt n \\right \\rfloor$，所以 $\\left \\lfloor \\frac{n}{d} \\right \\rfloor$ 最多有 $\\left \\lfloor \\sqrt n \\right \\rfloor$ 个取值。 综上所述，$\\left \\lfloor \\frac{n}{d} \\right \\rfloor$ 最多有 $2 \\left \\lfloor \\sqrt n \\right \\rfloor$ 个取值。那么我们可以最多分为 $2 \\left \\lfloor \\frac{n}{dk} \\right \\rfloor + 2 \\left \\lfloor \\frac{m}{dk} \\right \\rfloor$ 段来计算。 总时间复杂度 $\\Theta(T(\\sqrt n + \\sqrt m))$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// Created by ZJYelizaveta on Thursday, September 28, 2017 PM02:17:53 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 50000 + 3;const int INF = 0x3f3f3f3f;int testCase;int prime[MAX_N], mu[MAX_N], sum[MAX_N], cnt = 0;bool isNotPrime[MAX_N];inline void sieve() &#123; memset(prime, 0, sizeof prime); memset(mu, 0, sizeof mu); memset(isNotPrime, false, sizeof isNotPrime); mu[1] = 1, isNotPrime[0] = isNotPrime[1] = true; for (register int i = 2; i &lt; MAX_N; ++i) &#123; if (!isNotPrime[i]) &#123; prime[++cnt] = i; mu[i] = -1; &#125; for (register int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt; MAX_N; ++j) &#123; isNotPrime[i * prime[j]] = true; if (i % prime[j] == 0) &#123; mu[i * prime[j]] = 0; break; &#125; else mu[i * prime[j]] = -mu[i]; &#125; &#125;// for (int i = 1; i &lt;= 12; ++i) printf(\"%d \", mu[i]); printf(\"\\n\"); sum[0] = 0; for (register int i = 1; i &lt; MAX_N; ++i) sum[i] = sum[i - 1] + mu[i];// for (int i = 1; i &lt;= 12; ++i) printf(\"%d \", sum[i]); printf(\"\\n\");&#125;inline int solve(int n, int m, int k) &#123; if (n &gt; m) swap(n, m); n /= k, m /= k; int last = 0, ans = 0; for (register int i = 1; i &lt;= n; i = last + 1) &#123; last = min((n / (n / i)), (m / (m / i))); ans += (sum[last] - sum[i - 1]) * (n / i) * (m / i); // &#125; return ans;&#125;int main()&#123; sieve(); testCase = readIn&lt;int&gt;(); while (testCase--) &#123; int a = readIn&lt;int&gt;(), b = readIn&lt;int&gt;(), c = readIn&lt;int&gt;(), d = readIn&lt;int&gt;(), k = readIn&lt;int&gt;(); int ans = solve(b, d, k) - solve(a - 1, d, k) - solve(b, c - 1, k) + solve(a - 1, c - 1, k); printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"http://yoursite.com/tags/莫比乌斯反演/"}]},{"title":"线性规划与网络流24题 Part 3","slug":"线性规划与网络流24题-Part-3","date":"2017-09-21T05:31:51.000Z","updated":"2017-10-22T03:17:31.588Z","comments":true,"path":"2017/09/21/线性规划与网络流24题-Part-3/","link":"","permalink":"http://yoursite.com/2017/09/21/线性规划与网络流24题-Part-3/","excerpt":"最后一部分！","text":"最后一部分！ 「网络流 24 题」负载平衡 - 19转化为最小代价供求问题，用最小费用最大流解决。 计算出每个仓库的盈余后，可以把问题转化为供求问题。建立供求网络，把$A$集合中所有结点看做供应节点，$B$集合所有节点看做需求结点，在能一次搬运满足供需的$A_{i}$和$B_{j}$之间连接一条费用为$1$的有向边，表示搬运一个单位货物费用为$1$。另外还要在$A_{i}$与相邻的$A_{j}$之间连接边，表示货物可以暂时搬运过去，不立即满足需求，费用也为$1$。（转自 hzwer） 因此可以建出如下的图： 首先求出$equal = \\frac{\\sum_{i = 1}^{n}w[i]}{n}$的值，每一个仓库有一个$a[i]$，令$a[i] = w[i] - equal$ 将一个仓库拆分为两个点，分别代表这个仓库可以输出的货流量$A$集合，仓库需要的货流量$B$集合 建立超级源点$s$，若$a[i] &gt; 0$，从$s$向$A_{i}$连一条容量为$a[i]$，费用为$0$的边 建立超级源点$t$，若$a[i] &lt; 0$，从$A_{i}$向$t$连一条容量为$-a[i]$，费用为$0$的边 $A$集合中的点$A_{i}$向其相邻的点$B_{i + 1},B_{i - 1},A_{i - 1}, A_{i + 1}$（$0 \\leq i &lt; n$）连一条容量为$\\infty$，费用为$1$的边 最小费用最大流，最小费用流值就是最少搬运量 「网络流 24 题」深海机器人问题 - 20多出发点和目的地的网络运输问题 由于“多个深海机器人可以在同一时间占据同一位置”，所以不需限制点的流量，不用拆点。而且，每条边的价值只能计算一次，容量限制要设为$1，$同时还将要连接上容量不限，费用为0的重边。 把网格中每个位置抽象成网络中一个结点 建立超级源点$s$，从点$s$到每个出发点$i$连接一条容量为该点出发的机器人数量，费用为$0$的边 建立超级源点$t$，从每个目标点$i$到$t$连一条容量为可以到达该点的机器人数量，费用为$0$的边 对于每个顶点$i$，若$j$为$i$东边或南边相邻的一个结点，从结点$i$向结点$j$连一条容量为 $1$，费用为该边价值的边 对于每个顶点 $i$，若 $j$ 为 $i$ 东边或南边相邻的一个结点，从结点$i$向结点$j$一条容量为$\\infty$，费用为$0$的边 最大费用最大流，答案为采集到的生物标本的最高总价值 「网络流 24 题」最长 k 可重区间集问题 - 21这个问题可以看做是求$k$条权之和最大的不相交路径，每条路径为一些不相交的区间序列。由于是最大费用流，两条路径之间一定有一些区间相交，可以看做是相交部分重复了$2$次，而$k$条路经就是最多重复了$k$次。最简单的想法就是把区间排序后，不相交的区间之间连接一条边，由于每个区间只能用一次，所以要拆点，点内限制流量。如果我们改变一下思路，把端点作为网络中的顶点，区间恰恰是特定一些端点之间的边，这样建模的复杂度更小。转自 hzwer 建模方法如下： 离散化所有区间的端点，把每个端点看做一个顶点，建立超级源点$s$和超级汇点$t$ 从$s$到顶点$1$（最左边顶点）连接一条容量为$k$，费用为$0$的边 从顶点$2n$（最右边顶点）到$t$连接一条容量为$k$，费用为$0$的边 从顶点$i$到顶点$i+1(i+1 \\leq 2n)$，连接一条容量为$\\infty$，费用为$0$的边 对于每个区间$[a,b]$，从$a$对应的顶点$i$到$b$对应的顶点$j$连接一条容量为$1$，费用为区间长度的有向边。 求最大费用最大流，最大费用流值就是最长k可重区间集的长度。 「网络流 24 题」最长 k 可重线段集问题 - 22依然是最大权不相交路径转化成为最小费用最大流问题。建图方法同 “ 最长 k 可重区间集问题 - 21 “，这里不再赘述了由于$COGS$上的数据有问题，所以这道题目无法评测QAQ 「网络流 24 题」火星探险问题 - 23在$\\text{COGS}$好像没有找到，有哪位大佬可以告诉我在哪里可以交这道题目吗QAQ 「网络流 24 题」骑士共存问题 - 24最大独立集问题同 “ 「网络流 24 题」方格取数 - 9 “ ，首先进行黑白交替染色，显然棋盘变成了一个二分图。然后对于没有障碍物的地方向骑士可以到达的地方连边(连双向边)，然后跑一遍网络流，最后答案等于点数减去最大匹配数。 代码「网络流 24 题」负载平衡 - 19123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// Created by ZJYelizaveta on Monday, August 21, 2017 AM10:41:54 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int MAXNODE = 200 + 3;const int INF = 0x3f3f3f3f;int n;int a[MAX_N], b[MAX_N];namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int dist[MAXNODE]; int prevV[MAXNODE], prevE[MAXNODE]; bool inq[MAXNODE]; inline void clear() &#123; for (int i = 0; i &lt;= MAXNODE; ++i) G[i].clear(); &#125; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow(int s, int t) &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, false, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s); inq[s] = true, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = false; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123;// dist[e.to] = dist[u] + e.cost; prevE[e.to] = i; prevV[e.to] = u; if (!inq[e.to]) &#123; inq[e.to] = true;// if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to); else q.push_front(e.to); &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second += flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;int main()&#123; n = readIn(); int sum = 0, equal = 0; for (int i = 1; i &lt;= n; ++i) a[i] = readIn(), sum += a[i]; equal = sum / n; for (int i = 1; i &lt;= n; ++i) b[i] = a[i] - equal; int s = 0, t = 2 * n + 1; for (int i = 1; i &lt;= n; ++i) if (b[i] &gt; 0) addEdge(s, i, b[i], 0); for (int i = 1; i &lt;= n; ++i) if (b[i] &lt; 0) addEdge(i + n, t, -b[i], 0); for (int i = 1; i &lt;= n; ++i) &#123; if (i != 1) &#123; addEdge(i, i - 1, INF, 1), addEdge(i, i - 1 + n, INF, 1); &#125; if (i != n) &#123; addEdge(i, i + 1, INF, 1), addEdge(i, i + 1 + n, INF, 1); &#125; &#125; addEdge(n, 1, INF, 1), addEdge(n, n + 1, INF, 1); addEdge(1, n, INF, 1), addEdge(1, n + n, INF, 1); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", ans.second); return 0;&#125; 「网络流 24 题」深海机器人问题 - 20123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// Created by ZJYelizaveta on 2017年08月24日 星期四 22时35分18秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAXNODE = 1000 + 3;const int INF = 0x3f3f3f3f;int a, b;int p, q;namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int dist[MAXNODE]; int prevV[MAXNODE], prevE[MAXNODE]; bool inq[MAXNODE]; inline void clear() &#123; for (int i = 0; i &lt;= MAXNODE; ++i) G[i].clear(); &#125; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow(int s, int t) &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, false, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s); inq[s] = true, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = false; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123;// dist[e.to] = dist[u] + e.cost; prevE[e.to] = i; prevV[e.to] = u; if (!inq[e.to]) &#123; inq[e.to] = true;// if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to); else q.push_front(e.to); &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second += flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;int main()&#123; freopen(\"shinkai.in\", \"r\", stdin); freopen(\"shinkai.out\", \"w\", stdout); a = readIn(), b = readIn(); p = readIn() + 1, q = readIn() + 1; int s = 0, t = p * q + 1; for (int i = 0; i &lt; p; ++i) &#123; for (int j = 1; j &lt; q; ++j) &#123; int c = readIn(); int u = i * q + j, v = u + 1; addEdge(u, v, 1, -c); addEdge(u, v, INF, 0); &#125; &#125; for (int j = 1; j &lt;= q; ++j) &#123; for (int i = 0; i &lt;= p - 2; ++i) &#123; int c = readIn(); int u = i * q + j, v = u + q; addEdge(u, v, 1, -c); addEdge(u, v, INF, 0); &#125; &#125; for (int i = 1; i &lt;= a; ++i) &#123; int c = readIn(), x = readIn(), y = readIn(); addEdge(s, x * q + y + 1, c, 0); &#125; for (int i = 1; i &lt;= b; ++i) &#123; int c = readIn(), x = readIn(), y = readIn(); addEdge(x * q + y + 1, t, c, 0); &#125; pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", -ans.second); return 0;&#125; 「网络流 24 题」最长 k 可重区间集问题 - 21123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// Created by ZJYelizaveta on Monday, August 21, 2017 PM01:53:40 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 500 + 3;const int MAXNODE = 1000 + 3;const int INF = 0x3f3f3f3f;int n, k;int l[MAX_N], r[MAX_N];namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int dist[MAXNODE]; int prevE[MAXNODE], prevV[MAXNODE]; bool inq[MAXNODE]; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow(int s, int t) &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, false, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s); inq[s] = true, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = false; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123; dist[e.to] = dist[u] + e.cost; prevV[e.to] = u; prevE[e.to] = i; if (!inq[e.to]) &#123; inq[e.to] = true; if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to); else q.push_front(e.to); &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second += flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;vector&lt;int&gt; vec;map&lt;int, int&gt; mp;int main()&#123; n = readIn(), k = readIn(); for (int i = 1; i &lt;= n; ++i) &#123; l[i] = readIn(), r[i] = readIn(); if (l[i] &gt; r[i]) swap(l[i], r[i]); vec.push_back(l[i]), vec.push_back(r[i]); &#125; sort(vec.begin(), vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end());// int m = vec.size(); int s = m, t = m + 1; addEdge(s, 0, k, 0), addEdge(m - 1, t, k, 0); for (int i = 0; i &lt; m; ++i) &#123; mp[vec[i]] = i; if (i + 1 &lt; m) addEdge(i, i + 1, INF, 0); &#125; for (int i = 1; i &lt;= n; ++i) addEdge(mp[l[i]], mp[r[i]], 1, l[i] - r[i]); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", -ans.second); return 0;&#125; 「网络流 24 题」最长 k 可重线段集问题 - 22「网络流 24 题」火星探险问题 - 23「网络流 24 题」骑士共存问题 - 24123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// Created by ZJYelizaveta on 2017骞?8鏈?5鏃 鏄熸湡浜 08鏃?0鍒?8绉// Copyright (c) 2017骞 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 200 + 3;const int MAXNODE = 400000 + 3;const int INF = 0x3f3f3f3f;const int dx[] = &#123;2, 1, -1, -2, -2, -1, 1, 2&#125;;const int dy[] = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;;int n, m;int a[MAX_N][MAX_N];int s, t, ans;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int iter[MAXNODE], level[MAXNODE]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; queue&lt;int&gt; q; memset(level, -1, sizeof level); q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if(u == t) return flow;// for (int &amp;i = iter[u]; i &lt; G[u].size(); i++) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(flow, e.cap)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int flow = 0, d = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while(d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;inline int ID(int x, int y) &#123; return (y - 1) * n + x;&#125;int main()&#123; freopen(\"knight.in\", \"r\", stdin); freopen(\"knight.out\", \"w\", stdout); n = readIn(), m = readIn(); s = 0, t = n * n + 1, ans = n * n; memset(a, 0, sizeof a); for (int i = 1; i &lt;= m; ++i) &#123; a[readIn()][readIn()] = 1; --ans; &#125; for (int j = 1; j &lt;= n; ++j) for (int i = 1; i &lt;= n; ++i) if (!a[i][j]) &#123; if ((i + j) &amp; 1) &#123; addEdge(s, ID(i,j), 1); for (int k = 0; k &lt;= 7; ++k) &#123; int x = i + dx[k], y = j + dy[k]; if (1 &lt;= x &amp;&amp; x &lt;= n &amp;&amp; 1 &lt;= y &amp;&amp; y &lt;= n &amp;&amp; !a[x][y]) addEdge(ID(i, j), ID(x, y), INF); &#125; &#125; else addEdge(ID(i,j), t, 1); &#125; ans -= maxFlow(s, t); printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/费用流/"},{"name":"最大权闭合图","slug":"最大权闭合图","permalink":"http://yoursite.com/tags/最大权闭合图/"},{"name":"最小割","slug":"最小割","permalink":"http://yoursite.com/tags/最小割/"},{"name":"最大独立集","slug":"最大独立集","permalink":"http://yoursite.com/tags/最大独立集/"},{"name":"分层图","slug":"分层图","permalink":"http://yoursite.com/tags/分层图/"}]},{"title":"线性规划与网络流24题 Part 2","slug":"线性规划与网络流24题-Part-2","date":"2017-09-21T05:31:40.000Z","updated":"2017-09-21T06:37:31.366Z","comments":true,"path":"2017/09/21/线性规划与网络流24题-Part-2/","link":"","permalink":"http://yoursite.com/2017/09/21/线性规划与网络流24题-Part-2/","excerpt":"失踪人口回归！","text":"失踪人口回归！ 「网络流 24 题」方格取数 - 9建图太神啦QAQ二分图点权最大独立集，转化为最小割模型，从而用最大流解决。贴几个结论和定义，如果不知道可以看一下 最小点权覆盖集：满足每一条边的两个端点至少选一个的最小权点集。最大点权独立集：满足每一条边的两个端点最多选一个的最大权点集。最小点权覆盖 = 原图最小割最大点权独立集 = 总点权 - 最小点权覆盖 = 总点权 - 最小割 = 总点权 - 最大流 我们将棋盘黑白染色，发现只有不同颜色的格子，是不能同时选择的。将每个格子看作一个点，如果我们将有冲突的格子之间连边的话，会发现这是一个二分图。 我们将染成黑色的格子归为$A$集合，染成白色的格子归为$B$集合 建立超级源点$s$连向$A$集合中的每一个点，边的容量为格子中的数值; 建立超级汇点$t$，$B$集合中的每一个点向$t$连一条容量为格子中数值中的边 对于一个染成黑色的格子，向与它相邻的白色格子连一条容量为$INF$的边 $ans = sum - maxFlow(s, t)$ 我们可以发现，我们需要求出最小的流量使得$A$集合与$B$集合不联通，相当于求此图的最小割，而此图的最小割就是原图的最小点权覆盖集，二分图最小点权覆盖集的补集就是二分图的最大点权独立集。 「网络流 24 题」餐巾计划 - 10开始做费用流的题目啦QAQ这个问题的主要约束条件是每天的餐巾够用，经过分析可以把每天要用的和用完的分离开处理，建模后就是二分图。二分图$A$集合中顶点$A_{i}$表示第$i$天用完的餐巾，其数量为$r_{i}$，所以从$s$向$A_{i}$连接容量为$r_{i}$的边作为限制。$B$集合中每个点$B_{i}$则是第$i$天需要的餐巾，数量为$r_{i}$，与$t$连接的边容量作为限制。 具体建模型方法如下: 将每一天拆分为$A$集合中的顶点$A_{i}$和$B$集合中的顶点$B_{i}$ 建立超级源点$s$向$A$集合中的每一个点连一条容量为$r_{i}$，费用为$0$的边 ; 建立超级源点$t$，$B$集合中的每一个点向$t$连一条容量为$r_{i}$，费用为$0$的边 新购买餐巾，从$s$向$B$集合中的每一个点连一条容量$\\infty$，费用为$p$的边。 每天用完的餐巾可以选择留到下一天，从每个$A_{i}$向$A_{i+1}(i+1 \\leq N)$连一条容量为$\\infty$，费用为$0$的边。 送到快洗部，从每个$A_{i}$向$B_{i+m}(i+m \\leq N)$连一条容量为$\\infty$，费用为$f$的边。 送到慢洗部，从每个$A_{i}$向$B{i+n}(i+n \\leq N)$连一条容量为$\\infty$，费用为$s$的有向边。 「网络流 24 题」航空路线问题 - 11LOJ上最后一道网络流，脑抽了，调了很久的输出方案QAQ建模如下: 将每个点拆分为两个集合，$A$集合和$B$集合 从$A$集合的$A_{i}$向$B$集合中的$B_{i}$连一条容量为$1$费用为$-1$的边$(1 &lt; i &lt; n)$ 从$A_{1}$向$B_{1}$连一条容量为$2$,费用为$-1$的边 从$A_{n}$向$B_{n}$连一条容量为$2$,费用为$-1$的边 如果存在边$(i,j), i&lt;j$，那么从$B_{i}$向$A_{j}$连一条容量$1$,费用为$0$的边 跑一遍最小费用最大流，若$A_{1} \\sim B_{1}$满流，则存在解，否则无解 「网络流 24 题」软件补丁 - 12通过状压转换成为最短路问题 好像跟[CTSC 1999]补丁VS错误这道题目是一样的但是当时没意识到这是一个费用流的题QAQ，然后按照原来的写了一遍交上去，结果跑得贼慢，然后虚心的学习了一下别人的代码，发现，诶怎么不用加边呀QAQ 我们可以肯定最多只有$2^{n}$种错误情况 ( 若这是第$i$个错误则用二进制表示时这一位为$0$ )，初始状态为$2^{n}−1$， 最后要求达到的状态是$0$。进一步我们发现$n$实际上很小，可以状压，那么可以想到用二进制来表示出所有的错误情况。但是实际上根本不用建图呀，每一次判断当前的补丁是否可用 (和是否加边的判断是一样的) ，然后状压跑一遍$SPFA$就行了QAQ 「网络流 24 题」星际转移问题 - 13真的贼难调QAQ，需要按照时间来拆点，见识了 我们把网络优化问题转化为枚举答案 $+$可行性判定问题。枚举天数，按天数把图分层，因为乘船每坐一站天数都要增加$1$，把太空船航线抽象成图中的一条边，跨图的两层。由于太空船容量有限，边上也要加上容量限制。除了坐船以外，人还可以在某个空间站等待下一班太空船的到来，所以每个点要与下一层同一点连接一条容量为$\\infty$的边。这样在层限制的图上求出的网络最大流就是在当前天数以内能够从地面到月球的最多的人数，该人数随天数递增不递减，存在单调性。所以可以枚举答案或二分答案，用网络流判定。网络流判定问题更适合枚举答案，而不是二分，因为新增一些点和边只需要在原有的基础上增广，不必重新求网络流。（转自 Byvoid） 首先判断地球到月球之间是否存在一条可行道路，若不存在，那么无解；否则把每一个太空站按照天数拆分成为$d$个点，$[i, d]$表示第$i$个站第$d$天。建立超级源点$s$和超级汇点$t$，并顺序枚举天数（网络流相比二分更适合顺序枚举） 对于第$d$天，从$s$向$[0, d]$连一条容量为$\\infty$的边。 对于第$d$天，从$[-1, d]$向$t$连一条容量为$\\infty$的边 对于第$i$艘飞船，令其第$d - 1$天在$a$处，第$d$天在$b$处，则从$[a, d - 1]$向$[b, d]$连一条容量为该太空飞船容量的边 对于第$i$个太空站，从$[i, d - 1]$向$[i, d]$连一条容量为$\\infty$的边 求最大流，若$ans = k$则停止枚举，那么当前的$d$就为答案 「网络流 24 题」孤岛营救问题 - 14转化为分层图最短路问题。 用一个$p$位二进制串表示当前获得的钥匙状态(若获得则二进制串中的这一位为$1$)，那么我们需要建立$2^{p}$层图。每层图表示在当前钥匙状态下的地图，每获得一把钥匙进入新的一层，然后i跑一次最短路即可。分层图最短路可以看这一个BZOJ 2763: [JLOI2011]飞行路线 「网络流 24 题」汽车加油行驶问题 - 15依然是分层图最短路QAQ 「网络流 24 题」数字梯形 - 16最大权不相交路径问题转化为最大费用最大流模型 梯形的顶至底的$m$条路径互不相交，说明了每个点只能经过一次，所以这里限制条件就是点，建图方法如下 : 将一个点拆分为两个点一个在$A$集合，一个在$B$集合(限制点流量) 建立超级源点$s$向梯形顶层每一个在合中的点连一条容量为$1$，费用为$0$的边 建立超级汇点$t$，从梯形底层每一个在$B$集合中的点向$t$连一条容量为$1$，费用为$0$的边 $A_{i, j}$向$B_{i, j}$连一条容量为$1$，费用为当前该点在数字梯形中对应的权值(这里权值取负)的边 从$B_{i, j}$向$A_{i + 1, j}$，$A_{i + 1, j + 1}$连一条容量为$1$，费用为$0$的边 跑一遍最小费用最大流，答案取反 梯形的顶至底的 $m$条路径仅在数字结点处相交，这时点上没有任何限制，而限制在边 建立超级源点$s$向梯形顶层每一个在$A$集合中的点连一条容量为$1$，费用为$0$的边 建立超级汇点$t$，从梯形底层每一个在$A$集合中的点向$t$连一条容量为$\\infty$，费用为$0$的边 $A_{i, j}$向$B_{i, j}$连一条容量为$\\infty$，费用为当前该点在数字梯形中对应的权值(这里权值取负)的边 从$B_{i, j}$向$A_{i + 1, j}$，$A_{i + 1, j + 1}$连一条容量为$1$，费用为$0$的边(限制边流量) 跑一遍最小费用最大流，答案取反 梯形的顶至底的$m$条路径允许在数字结点相交或边相交，这时点边都没有限制 建立超级源点$s$向梯形顶层每一个在合中的点连一条容量为$1$，费用为$0$的边 建立超级汇点$t$，从梯形底层每一个在$A$集合中的点向$t$连一条容量为$\\infty$，费用为$0$的边 $A_{i, j}$向$B_{i, j}$连一条容量为$\\infty$，费用为当前该点在数字梯形中对应的权值(这里权值取负)的边 从$B_{i, j}$向$A_{i + 1, j}$，$A_{i + 1, j + 1}$连一条容量为$\\infty$，费用为$0$的边 跑一遍最小费用最大流，答案取反 「网络流 24 题」运输问题 - 17费用流问题裸题QAQ建模方法一如既往的很套路： $m$ 个仓库做为$A$集合， $n$个零售商店做为$B$集合。 建立超级源点$s$向$A$集合中的每一个点连一条容量为$a[i]$，费用为$0$的边；建立超级汇点$t$，$B$集合中的每一个点向$t$连一条容量为$b[i]$，费用为$0$的边。 从$A$集合中的点$A_{i}$向$B$集合中的点$B_{j}$连一条容量为$\\infty$，费用为$c[i][j]$的边 最小总效益跑一遍最小费用最大流，最大总效益跑一遍最大费用最大流（与$16$题一样，把费用取负就可以了）。 「网络流 24 题」分配问题 - 18和$17$题一样还是费用流问题裸题QAQ建模方法一如既往的很套路： $n$ 个人做为$A$集合， $n$个任务做为$B$集合。 建立超级源点$s$向$A$集合中的每一个点连一条容量为$1$，费用为$0$的边；建立超级汇点$t$，$B$集合中的每一个点向$t$连一条容量为$1$，费用为$0$的边。 从$A$集合中的点$A_{i}$向$B$集合中的点$B_{j}$连一条容量为$\\infty$，费用为$c[i][j]$的边 最小总效益跑一遍最小费用最大流，最大总效益跑一遍最大费用最大流（与$16$题一样，把费用取负就可以了）。 代码「网络流 24 题」方格取数 - 9123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// Created by ZJYelizaveta on 2017年08月18日 星期五 19时52分22秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 900 + 3;const int MAX_M = 30 + 3;const int INF = 0x3f3f3f3f;int m, n; // hang, lieint s, t;int a[MAX_M][MAX_M];int ans, sum;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1]; int iter[MAX_N &lt;&lt; 1], level[MAX_N &lt;&lt; 1]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(e.cap, flow)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int d = 0, flow = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;inline int getId(int x, int y) &#123; return (x - 1) * m + y;&#125;int main()&#123; n = readIn(), m = readIn(); s = 0, t = n * m + 1; int cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; int num = readIn(); sum += num; int curId = getId(i, j);// printf(\"%d\\n\", curId); bool flag = (i + j) &amp; 1; if (flag) addEdge(s, curId, num); else addEdge(curId, t, num); if (flag) &#123; if (i - 1 &gt;= 1) addEdge(curId, getId(i - 1, j), INF); if (i + 1 &lt;= n) addEdge(curId, getId(i + 1, j), INF); if (j - 1 &gt;= 1) addEdge(curId, getId(i, j - 1), INF); if (j + 1 &lt;= m) addEdge(curId, getId(i, j + 1), INF); &#125; &#125; &#125; ans = maxFlow(s, t); printf(\"%d\\n\", sum - ans);&#125; 「网络流 24 题」餐巾计划 - 1012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// Created by ZJYelizaveta on 2017年08月19日 星期六 23时01分39秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int INF = 0x3f3f3f3f;namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1]; int dist[MAX_N &lt;&lt; 1]; int prevV[MAX_N &lt;&lt; 1], prevE[MAX_N &lt;&lt; 1]; bool inq[MAX_N &lt;&lt; 1]; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow(int s, int t) &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, 0, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s), inq[s] = 1, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = 0;// for (int i = 0; i &lt; (int)G[u].size(); i++)&#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123; dist[e.to] = dist[u] + e.cost; prevE[e.to] = i; prevV[e.to] = u; if (!inq[e.to]) &#123;// inq[e.to] = 1; if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to);// else q.push_front(e.to);// &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second += flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;int main()&#123; int n = readIn(), P = readIn(), M = readIn(), F = readIn(), N = readIn(), S = readIn(); int s = 0, t = 2 * n + 1; for (int i = 1; i &lt;= n; ++i) &#123; int r = readIn(); addEdge(s, i + n, r, 0); addEdge(i, t, r, 0); addEdge(s, i, INF, P); if (i + 1 &lt;= n) addEdge(i + n, i + n + 1, INF, 0); if (i + M &lt;= n) addEdge(i + n, i + M, INF, F); if (i + N &lt;= n) addEdge(i + n, i + N, INF, S); &#125; pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", ans.second); return 0;&#125; 「网络流 24 题」航空路线问题 - 11123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// Created by ZJYelizaveta on 2017年08月23日 星期三 22时19分32秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int MAXNODE = 200 + 3;const int INF = 0x3f3f3f3f;int n, m;int s, t;char str[MAX_N][15 + 3], s1[15 + 3], s2[15 + 3];map&lt;string, int&gt; M;namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int dist[MAXNODE]; int prevV[MAXNODE], prevE[MAXNODE]; bool inq[MAXNODE]; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow() &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, false, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s); inq[s] = true, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = false; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123;// dist[e.to] = dist[u] + e.cost; prevE[e.to] = i; prevV[e.to] = u; if (!inq[e.to]) &#123; inq[e.to] = true;// if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to); else q.push_front(e.to); &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second -= flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;int vis[MAXNODE];vector&lt;string&gt; vec;void dfs(int u, int n) &#123; vis[u] = 1; for (int i = 0, v; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (!vis[v = e.to] &amp;&amp; ((!e.cap &amp;&amp; e.cost &lt;= 0) || (e.cap &amp;&amp; e.cost &gt;= 0))) &#123; dfs(v, n); if (v &lt;= n) vec.push_back(str[v]); &#125; &#125;&#125;inline void printPath() &#123; memset(vis, 0, sizeof vis); vec.clear(); vec.push_back(str[1]); dfs(1, n); vec.push_back(str[1]); for (int i = (int)vec.size() - 1; i &gt;= 0; --i) cout &lt;&lt; vec[i] &lt;&lt; endl;&#125;int main()&#123; n = readIn(), m = readIn(); M.clear(); s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%s\", str[i]); M[str[i]] = i; if (i == 1 || i == n) addEdge(i, i + n, 2, 0); else addEdge(i, i + n, 1, 0); &#125; addEdge(s, 1, 2, 0); addEdge(n * 2, t, 2, 0); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%s\", s1); scanf(\"%s\", s2); int a = M[s1], b = M[s2]; if (a &gt; b) swap(a, b); if (a == 1 &amp;&amp; b == n) addEdge(a + n, b, 2, -1); addEdge(a + n, b, 1, -1); &#125; pair&lt;int, int&gt; ans = minCostMaxFlow(); if (ans.first != 2) printf(\"No Solution!\\n\"); else &#123; printf(\"%d\\n\", ans.second); printPath(); &#125; return 0;&#125; 「网络流 24 题」软件补丁 - 12123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// Created by ZJYelizaveta on 2017年08月20日 星期日 09时47分57秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = (1 &lt;&lt; (17 + 3));const int INF = 0x3f3f3f3f;int n, m, s, t;int w[MAX_N];char str1[MAX_N], str2[MAX_N];struct Limited &#123; int s1, s2, t1, t2; //b+, b-, f+, f-&#125;lim[100 + 3];int dist[MAX_N];bool inq[MAX_N];inline bool check(int u, int id) &#123; if ((u | lim[id].s1) != u) return false; if (u &amp; lim[id].s2) return false; return true;&#125;inline void SPFA() &#123; memset(inq, false, sizeof inq); memset(dist, INF, sizeof dist); queue&lt;int&gt; q; q.push(s); inq[s] = true; dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (register int i = 0; i &lt; m; ++i) &#123; if (check(u, i)) &#123; int to = (u &amp; (~lim[i].t2)) | lim[i].t1; if (dist[to] &gt; dist[u] + w[i]) &#123; dist[to] = dist[u] + w[i]; if (!inq[to]) &#123; inq[to] = true; q.push(to); &#125; &#125; &#125; &#125; &#125; if (dist[t] == INF) printf(\"%d\\n\", 0); else printf(\"%d\\n\", dist[t]);&#125;int main()&#123; n = readIn(), m = readIn(); s = (1 &lt;&lt; n) - 1, t = 0; for (register int i = 0; i &lt; m; ++i) &#123; w[i] = readIn(); scanf(\"%s\", str1); for (register int j = 0; j &lt; n; ++j) &#123; if (str1[j] == '+') lim[i].s1 |= (1 &lt;&lt; j); else if (str1[j] == '-') lim[i].s2 |= (1 &lt;&lt; j); &#125; scanf(\"%s\", str2); for (register int j = 0; j &lt; n; ++j) &#123; if (str2[j] == '+') lim[i].t1 |= (1 &lt;&lt; j); else if (str2[j] == '-') lim[i].t2 |= (1 &lt;&lt; j); &#125; &#125; SPFA(); return 0;&#125; 「网络流 24 题」星际转移问题 - 13123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145// Created by ZJYelizaveta on 2017年08月22日 星期二 19时53分41秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 13 + 3;const int MAX_M = 20 + 3;const int MAX_K = 50 + 3;const int MAXNODE = 500000 + 3;const int INF = 0x3f3f3f3f;int n, m, k;int h[MAX_M], r[MAX_M], a[MAX_M][MAX_N];int s, t;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int level[MAXNODE], iter[MAXNODE]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(e.cap, flow)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int d = 0, flow = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;namespace unionFindSet &#123; int fa[MAX_N]; inline void prepare() &#123; for (int i = 1; i &lt; MAX_N; ++i) fa[i] = i; &#125; inline int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125;&#125;using namespace unionFindSet;inline int ID(int station, int day) &#123; return day * (n + 2) + station;&#125;inline void solve() &#123; int moon = 1, earth = 2; int cur = 0, ans = 0; addEdge(s, ID(earth, 0), k), addEdge(ID(moon, 0), t, 0); while (1) &#123; ++cur; for (int i = 1; i &lt;= n + 2; ++i) &#123; addEdge(ID(i, cur - 1), ID(i, cur), INF); &#125; for (int i = 1; i &lt;= m; ++i) &#123; addEdge(ID(a[i][(cur - 1) % r[i]], cur - 1), ID(a[i][cur % r[i]], cur), h[i]); &#125; addEdge(ID(moon, cur), t, INF); ans += maxFlow(s, t); if (ans == k) &#123; printf(\"%d\\n\", cur); break; &#125; &#125;&#125;int main()&#123; n = readIn(), m = readIn(), k = readIn(); prepare(); s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1; for (int i = 1; i &lt;= m; ++i) &#123; h[i] = readIn(), r[i] = readIn(); for (int j = 0; j &lt; r[i]; ++j) &#123; a[i][j] = readIn() + 2;// printf(\"%d \", b[i][j]); if (j) &#123; int x = find(a[i][j - 1]); int y = find(a[i][j]);// printf(\"%d %d\\n\", x, y); if (x != y) fa[x] = y; &#125; &#125;// printf(\"\\n\"); &#125; int moon = 1, earth = 2; if (find(earth) != find(moon)) printf(\"%d\\n\", 0); else solve(); return 0;&#125; 「网络流 24 题」孤岛营救问题 - 141234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// Created by ZJYelizaveta on 2017年08月23日 星期三 17时56分49秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10 + 3;const int MAX_K = 150 + 3;const int INF = 0x3f3f3f3f;const int dx[] = &#123;1, 0, -1, 0&#125;;const int dy[] = &#123;0, 1, 0, -1&#125;;int n, m, p, k, s;int x2[MAX_K], x3[MAX_K], y2[MAX_K], y3[MAX_K], g[MAX_K];int x[MAX_K], y[MAX_K], q[MAX_K];int key[MAX_N][MAX_N], d[MAX_N][MAX_N][MAX_N][MAX_N];bool vis[1024 + 3][MAX_N][MAX_N];struct Node &#123; int x, y, st, dist; Node (int x, int y, int st, int dist) : x(x), y(y), st(st), dist(dist)&#123;&#125;&#125;;queue&lt;Node&gt; Q;inline void solve() &#123; Q.push(Node(1, 1, 0, 0)); vis[0][1][1] = true; while (!Q.empty()) &#123; Node cur = Q.front(); Q.pop(); for (int i = 0; i &lt;= 3; ++i) &#123; int x = cur.x + dx[i] , y = cur.y + dy[i] , t = d[cur.x][cur.y][x][y]; if (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m &amp;&amp; t != -1 &amp;&amp; !( ( cur.st ^ t ) &amp; t )) &#123; Node next = Node(x, y, (cur.st | key[x][y]), cur.dist + 1); if( x == n &amp;&amp; y == m ) &#123; printf(\"%d\\n\", next.dist); return; &#125; if (vis[next.st][x][y]) continue; vis[next.st][x][y] = true; Q.push(next); &#125; &#125; &#125; printf(\"%d\\n\", -1);&#125;int main()&#123; n = readIn(), m = readIn(), p = readIn(), k = readIn(); for (int i = 1; i &lt;= k; ++i) x2[i] = readIn(), y2[i] = readIn(), x3[i] = readIn(), y3[i] = readIn(), g[i] = readIn(); s = readIn(); for (int i = 1; i &lt;= s; ++i) x[i] = readIn(), y[i] = readIn(), q[i] = readIn(); for (int i = 1; i &lt;= k; ++i) &#123; int &amp;a = d[x2[i]][y2[i]][x3[i]][y3[i]]; int &amp;b = d[x3[i]][y3[i]][x2[i]][y2[i]]; if (a == -1) continue; if (g[i] == 0) a = b = -1; else a = b = (a | (1 &lt;&lt; (g[i] - 1))); &#125; for (int i = 1; i &lt;= s; ++i) key[x[i]][y[i]] |= (1 &lt;&lt; (q[i] - 1)); solve(); return 0;&#125; 「网络流 24 题」汽车加油行驶问题 - 15「网络流 24 题」数字梯形 - 16123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155// Created by ZJYelizaveta on 2017年08月20日 星期日 19时21分21秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 20 + 3;const int MAXNODE = 800 + 3;const int INF = 0x3f3f3f3f;int n, m;int a[MAX_N][MAX_N], num[MAX_N][MAX_N];int cnt;namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int dist[MAXNODE]; int prevV[MAXNODE], prevE[MAXNODE]; bool inq[MAXNODE]; inline void init() &#123; for (int i = 0; i &lt;= MAXNODE; ++i) G[i].clear(); &#125; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow(int s, int t) &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, 0, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s), inq[s] = 1, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = 0;// for (int i = 0; i &lt; (int)G[u].size(); i++)&#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123; dist[e.to] = dist[u] + e.cost; prevE[e.to] = i; prevV[e.to] = u; if (!inq[e.to]) &#123;// inq[e.to] = 1; if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to);// else q.push_front(e.to);// &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second += flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;inline void solve1() &#123; init(); int s = 0, t = 2 * cnt + 1;// printf(\"%d %d %d\\n\", s, t, cnt); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i + m; ++j) &#123; addEdge(num[i][j], num[i][j] + cnt, 1, -a[i][j]); if (i + 1 &lt;= n) &#123; addEdge(num[i][j] + cnt, num[i + 1][j], 1, 0); addEdge(num[i][j] + cnt, num[i + 1][j + 1], 1, 0); &#125; &#125; &#125; for (int i = 1; i &lt;= m; ++i) addEdge(s, num[1][i], 1, 0); for (int i = 1; i &lt; n + m; ++i) addEdge(num[n][i] + cnt, t, 1, 0); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", -ans.second);&#125;inline void solve2() &#123; init(); int s = 0, t = 2 * cnt + 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i + m; ++j) &#123; addEdge(num[i][j], num[i][j] + cnt, INF, -a[i][j]); if (i + 1 &lt;= n) &#123; addEdge(num[i][j] + cnt, num[i + 1][j], 1, 0); addEdge(num[i][j] + cnt, num[i + 1][j + 1], 1, 0); &#125; &#125; &#125; for (int i = 1; i &lt;= m; ++i) addEdge(s, num[1][i], 1, 0); for (int i = 1; i &lt; n + m; ++i) addEdge(num[n][i] + cnt, t, INF, 0); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", -ans.second);&#125;inline void solve3() &#123; init(); int s = 0, t = 2 * cnt + 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i + m; ++j) &#123; addEdge(num[i][j], num[i][j] + cnt, INF, -a[i][j]); if (i + 1 &lt;= n) &#123; addEdge(num[i][j] + cnt, num[i + 1][j], INF, 0); addEdge(num[i][j] + cnt, num[i + 1][j + 1], INF, 0); &#125; &#125; &#125; for (int i = 1; i &lt;= m; ++i) addEdge(s, num[1][i], 1, 0); for (int i = 1; i &lt; n + m; ++i) addEdge(num[n][i] + cnt, t, INF, 0); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", -ans.second);&#125;int main()&#123; m = readIn(), n = readIn(); cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i + m; ++j) &#123; a[i][j] = readIn(); num[i][j] = ++cnt;// printf(\"%d %d \", num[i][j], a[i][j]); &#125;// printf(\"\\n\"); &#125; solve1(); solve2(); solve3(); return 0;&#125; 「网络流 24 题」运输问题 - 17123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// Created by ZJYelizaveta on Monday, August 21, 2017 AM09:07:18 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int MAXNODE = 200 + 3;const int INF = 0x3f3f3f3f;int n, m;int a[MAX_N], b[MAX_N], c[MAX_N][MAX_N];namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int dist[MAXNODE]; int prevV[MAXNODE], prevE[MAXNODE]; bool inq[MAXNODE]; inline void clear() &#123; for (int i = 0; i &lt;= MAXNODE; ++i) G[i].clear(); &#125; inline void init() &#123; for (int i = 0; i &lt;= MAXNODE; ++i) G[i].clear(); &#125; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow(int s, int t) &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, 0, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s), inq[s] = 1, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = 0;// for (int i = 0; i &lt; (int)G[u].size(); i++)&#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123; dist[e.to] = dist[u] + e.cost; prevE[e.to] = i; prevV[e.to] = u; if (!inq[e.to]) &#123;// inq[e.to] = 1; if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to);// else q.push_front(e.to);// &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second += flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;inline void solve1() &#123; clear(); int s = 0, t = n + m + 1; for (int i = 1; i &lt;= n; ++i) addEdge(s, i, a[i], 0); for (int i = 1; i &lt;= m; ++i) addEdge(i + n, t, b[i], 0); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) addEdge(i, j + n, INF, c[i][j]); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", ans.second);&#125;inline void solve2() &#123; clear(); int s = 0, t = n + m + 1; for (int i = 1; i &lt;= n; ++i) addEdge(s, i, a[i], 0); for (int i = 1; i &lt;= m; ++i) addEdge(i + n, t, b[i], 0); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) addEdge(i, j + n, INF, -c[i][j]); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", -ans.second);&#125;int main()&#123; n = readIn(), m = readIn(); for (int i = 1; i &lt;= n; ++i) a[i] = readIn(); for (int i = 1; i &lt;= m; ++i) b[i] = readIn(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) c[i][j] = readIn(); solve1(); solve2(); return 0;&#125; 「网络流 24 题」分配问题 - 18123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// Created by ZJYelizaveta on Monday, August 21, 2017 AM09:56:23 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int MAXNODE = 200 + 3;const int INF = 0x3f3f3f3f;int n;int c[MAX_N][MAX_N];namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int dist[MAXNODE]; int prevV[MAXNODE], prevE[MAXNODE]; bool inq[MAXNODE]; inline void clear() &#123; for (int i = 0; i &lt;= MAXNODE; ++i) G[i].clear(); &#125; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow(int s, int t) &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, false, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s); inq[s] = true, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = false; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123;// dist[e.to] = dist[u] + e.cost; prevE[e.to] = i; prevV[e.to] = u; if (!inq[e.to]) &#123; inq[e.to] = true;// if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to); else q.push_front(e.to); &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second += flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;inline void solve1() &#123; clear(); int s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; ++i) addEdge(s, i, 1, 0); for (int i = 1; i &lt;= n; ++i) addEdge(i + n, t, 1, 0); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) addEdge(i, j + n, INF, c[i][j]); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", ans.second);&#125;inline void solve2() &#123; clear(); int s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; ++i) addEdge(s, i, 1, 0); for (int i = 1; i &lt;= n; ++i) addEdge(i + n, t, 1, 0); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) addEdge(i, j + n, INF, -c[i][j]); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", -ans.second);&#125;int main()&#123; n = readIn(); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; c[i][j] = readIn();// printf(\"%d \", c[i][j]); &#125; &#125; solve1(); solve2(); return 0;&#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/费用流/"},{"name":"最大权闭合图","slug":"最大权闭合图","permalink":"http://yoursite.com/tags/最大权闭合图/"},{"name":"最小割","slug":"最小割","permalink":"http://yoursite.com/tags/最小割/"},{"name":"最大独立集","slug":"最大独立集","permalink":"http://yoursite.com/tags/最大独立集/"},{"name":"分层图","slug":"分层图","permalink":"http://yoursite.com/tags/分层图/"}]},{"title":"线性规划与网络流24题 Part 1","slug":"线性规划与网络流24题-Part-1","date":"2017-09-21T05:31:28.000Z","updated":"2017-09-21T06:37:39.643Z","comments":true,"path":"2017/09/21/线性规划与网络流24题-Part-1/","link":"","permalink":"http://yoursite.com/2017/09/21/线性规划与网络流24题-Part-1/","excerpt":"太菜了，现在才做网络流$24$题QAQ","text":"太菜了，现在才做网络流$24$题QAQ 「网络流 24 题」搭配飞行员 - 1很明显的求二分图最大匹配的模板题呀QAQ 建立源点 $s$ 连向每一个正驾驶员，容量为 $1$。 建立汇点 $t$ 所有的副驾驶员连向 $t$，容量为 $1$。 正驾驶员 $a$ 和副驾驶员 $b$ 可以同机飞行，那么连一条容量为$1$的边$a \\rightarrow b$。 然后跑最大流就是答案了 「网络流 24 题」太空飞行计划 - 2不会做啊QAQ，太菜了最大权闭合图问题，可以转化成最小割问题，进而用最大流解决。 闭合子图就是给定一个有向图，从中选择一些点组成一个点集$V$。对于$V$中任意一个点，其后续节点都仍然在$V$中。通俗的来说是 : 闭合图的性质反映的是事件的必要条件，$A$发生，那么$A$的所有前提要发生。 这道题目里 “ 要想做实验，先做某个实验必须购买好实验所需的设备 “ 构成了事件的必要条件。 先说结论吧，最大权闭合子图的权值等于所有正权点之和减去最小割 / 最大流。 本题要求最大化总收益，设配置仪器花 $C$ 元，这些仪器能进行的实验的总收益为 $P$，不能进行的实验的总收益为 $P’$ ，所有实验的总收益为 $Sum$，则 \\text{Profit} = P - C = (Sum - P') - C = Sum - (P' + C)由于 $S$ 是定值，我们将问题转化到了在合法的情况下，让 $W’ + C$尽量小，于是构图如下: 将每个实验划分为 $A$ 集合，每个仪器划分为 $B$ 集合。 建立超级源点 $s$ 向 $A$ 集合中的每一个点连一条容量为该实验收益的边并累加 $sum$，建立超级汇点 $t$，$B$ 集合中的每一个点向汇点 $t$ 连一条容量为该仪器花费的边。 如果 $A$ 集合中的实验 $A_{i}$ 需要$B$集合中的仪器 $B_{j}$，那么连边 $A_{i} \\rightarrow B_{j}$ 容量为 $\\infty$。 跑一遍最大流，$ans = sum - maxFlow(s, t)$。 我们发现我们需要最小化的$P’ + C$相当于当前图中的最小割 / 最大流。 现在再想一下上面的结论为什么成立，我们需要最小化割，相当于用最小的流量使得 $s$ 与 $t$ 不连通。对于一个实验，我们定义选择还是不选择实验 $A_{i}$ 通过是否割 $s \\rightarrow A_{i}$ 这条边来判定，如果不选择实验 $A_{i}$ 则割掉 $s \\rightarrow A_{i}$ 这条边; 如果选择实验 $A_{i}$ 则不割这条边，那么现在为了使得 $s \\rightarrow t$ 不连通，那么就割掉实验 $A_{i}$ 所需的仪器集合 $B_{i}$ 连向 $t$ 的边 (我们肯定不会选择割容量为$\\infty$的边)。那么这样每一个合法的割的值就为 $P’ + C$，也就是说我们要最小化 $P’ + C$ 的值。 输出方案有一些恶心，这里不想写了，可以看线性规划与网络流24题 - 2 太空飞行计划 「网络流 24 题」最小路径覆盖 - 3我们需要求有向无环图 $G$ 的最小路径覆盖。 最小路径覆盖 = 原图顶点数 - 二分图最大匹配数 我们可以观察一条路径，起点的入度为 $0$，终点的出度为 $0$，中间节点的出入度都为 $1$。也就是说，每一个点最多只能有 $1$ 个后继，同时每一个点最多只能有 $1$ 个前驱。假如我们选择了一条边 $(u,v)$，也就等价于把前驱 $u$ 和后继 $v$ 匹配上了。这样前驱 $u$ 和后继 $v$ 就不能和其他节点匹配。 将每一个点拆分成 $2$ 个，分别表示它作为前驱节点和后继节点，将所有的前驱结点作为 $A$ 集合，所有后继结点作为 $B$ 集合。 若原图中存在一条边$(u,v)$，则连接$A$集合的$u$和$B$集合的$v$。 新建源汇 $s, t$，$s$ 向每个 $A_{i}$连边，$B_{i}$向 $t$ 连边。 如果一个点是路径起点的话，它在$B$集合的结点一定是没有匹配上的，做完二分图最大匹配之后，保证了$B$集合中未匹配的点最少，也就对应了最小路径覆盖数。 输出路径有一些麻烦，画一下图应该就会了吧QAQ 「网络流 24 题」魔术球 - 4依然是一道很神奇的题目QAQ，听说贪心可以过，这里还是写网络流的做法吧 不好求有 $n$ 个柱子时可放的球数量，转换一下思路，我们求可放 $n$ 个球时的最小柱子数量，注意到同一个柱子上球的标号递增，所以可以转化为最小路径覆盖问题。 枚举答案 $A$，在图中建立节点 $1,2, \\cdots ,A$。如果对于 $i&lt;j$有 $i+j$为一个完全平方数，连接一条有向边 $(i,j)$。那么此时我们可以发现五门实际上是在求有向无环图的最小路径覆盖。 如果刚好满足最小路径覆盖数等于 $n$，那么 $A$ 是一个可行解，在所有可行解中找到最大的 $A$，即为最优解。可以顺序枚举 $A$ 的值，当最小路径覆盖数刚好大于 $n$ 时终止，$A-1$就是最优解。 这道题目更适合枚举答案而不是二分答案，因为如果顺序枚举答案，每次只需要在残量网络上增加新的结点点和边，再增广一次即可。如果二分答案，就需要每次重新建图，大大增加了时间复杂度。 「网络流 24 题」圆桌聚餐 - 5二分图多重匹配，为什么总是要输出方案呀QAQ 把每一个代表单位当成$A$集合中的一个元素，每张餐桌当做$B$集合中的一个元素。 建立超级源点$s$向$A$集合连一条容量为代表单位的人数; 建立超级汇点$t$，$B$集合中的每一个点向$t$连一条容量为餐桌最多容纳人数的边。保证每个单位参加人数不超过上限，每个餐桌容量不超过上限。 $A$集合中的每一个点向$B$集合中的每一个点连一条容量为$1$的点，保证了 “ 希望从同一个单位来的代表不在同一个餐桌就餐 “ 这个条件成立。若可以匹配多次则可以通过改变容量实现。 跑一边最大流$ans = maxFlow(s, t)$，若$ans$小于每个单位人数之和则没有解，否则存在并输出答案。 二分图最大匹配中，每个点最多只能和一条匹配边相关联，然而，我们像以上这类问题，即二分图匹配中一个点可以和多条匹配边相关联，可以参考以上的建模方法。 「网络流 24 题」最长递增子序列 - 6首先第一问可以用动态规划在 $\\Theta(n^{2})$ 做的，令 $f[i]$ 表示以第 $i$ 为结尾的最长上升序列的长度，最后取 $max$ $f[i]$即可。 第二问，问最多可取同时出多少个长度为 $s$ 的递增子序列。每个数只能用一次，因此考虑拆点来限制每个点只能用一次这个条件 把序列第$i$位拆成两个点$i_{a}$和$i_{b}$，从$i_{a}$到$i_{b}$连接一条容量为1的有向边 建立超级源点$s$和超级汇点$t$，如果序列第 $i$ 位有 $f[i] = 1$，从 $s$ 到 $i_{a}$ 连接一条容量为 $1$ 的边 如果有 $f[i]=1$，从 $i_{b}$ 到 $t$ 连接一条容量为1的有向边。 如果$i &lt; j$且$A[i] &lt; A[j]$且$f[j] + 1 = f[i]$，从$i_{b}$到$j_{a}$连接一条容量为$1$边 简要分析一下，因为最上升子序列有明显的阶段性，$f[i]$的值为阶段，那么$f[i] = 1$相当与阶段的开始，而$f[i] = k$相当于阶段的结束，一束流量为$1$的流，只有经过 $k - 1$次转移，才能到从源点到达汇点，而每一束到达汇点的流，均对应一个 最长上升子序列，因此第二问的答案就是本图最大流。 会求第二问了，那么第三问也是一样的，只需要将边$(1_{a}, 1_{b})$，$(n_{a}, n_{b})$，$(s, 1_{a})$，$(n_{b}, t) (f[n] == k)$的容量修改为$\\infty$，再求一次网络最大流，就是第三问结果。 调的有点久，因为位运算没有写括号进入了死循环 ??? 「网络流 24 题」试题库 - 7还是二分图多重匹配，题意描述的很玄妙呀QAQ大概就是一张试卷需要含有$k$种属性的试题，每种属性的试题需要$k_{i}$道，现在题库中一共有$n$道试题，每道试题有$p$种属性，输出满足第$k$道试题的试卷选取情况。建图方法同 “ 「网络流 24 题」圆桌聚餐 “ 。 每一道试题当成$A$集合中的一个元素，试卷中所需的每种试题当做$B$集合中的一个元素。 建立超级源点$s$向$A$集合连一条容量$1$; 建立超级汇点$t$，$B$集合中的每一个点向$t$连一条容量为每种试题需要数量。 $A$集合中的每一个点根据这道试题的类型向$B$集合中的代表此种类型的点连一条容量为$1$的点。 跑一边最大流$ans = maxFlow(s, t)$，若$ans$小于每各种类的题所需数量之和则没有解，否则存在并输出答案。 「网络流 24 题」机器人路径规划问题 - 8真 $\\cdot$ 不会做，有没有大佬可以教我呀QAQ 代码「网络流 24 题」搭配飞行员 - 112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Created by ZJYelizaveta on 2017年08月17日 星期四 09时27分02秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int INF = 0x3f3f3f3f;int n, m;int s, t;int a[MAX_N], b[MAX_N];int ans;namespace dinic &#123; struct Edge &#123; int to, cap, rev; Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N]; int iter[MAX_N], level[MAX_N]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; queue&lt;int&gt; q; memset(level, -1, sizeof level); q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if(u == t) return flow;// for (int &amp;i = iter[u]; i &lt; G[u].size(); i++) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(flow, e.cap)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int flow = 0, d = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while(d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace dinic;int main()&#123; n = readIn(), m = readIn();// printf(\"%d %d\\n\", n, m); s = 0, t = n + 1; for (int i = 1; i &lt;= m; ++i) addEdge(s, i, 1);// for (int i = m + 1; i &lt;= n; ++i) addEdge(i, t, 1);// int a, b; while (scanf(\"%d%d\", &amp;a, &amp;b) != EOF) &#123; if (a &gt; b) swap(a, b); addEdge(a, b, 1); &#125; ans = maxFlow(s, t); printf(\"%d\\n\", ans); return 0;&#125; 「网络流 24 题」太空飞行计划 - 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// Created by ZJYelizaveta on Wednesday, September 20, 2017 PM02:14:25 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int INF = 0x3f3f3f3f;int m, n;int s, t;int c[MAX_N];int ans, sum;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge (int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N]; int iter[MAX_N], level[MAX_N]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(e.cap, flow)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int d = 0, flow = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;int vis[MAX_N &lt;&lt; 1];void dfs(int u) &#123; vis[u] = true; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; !vis[e.to]) dfs(e.to); &#125;&#125;inline void printPath() &#123; memset(vis, 0, sizeof vis); dfs(0); for (int i = 1; i &lt;= n; ++i) if (vis[i]) printf(\"%d \", i); printf(\"\\n\"); for (int i = 1; i &lt;= m; ++i) if (vis[n + i]) printf(\"%d \", i); printf(\"\\n\");&#125;int main()&#123; n = readIn(), m = readIn();// printf(\"%d %d\\n\", n, m); s = 0, t = m + n + 1; sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; int num = readIn(); sum += num; addEdge(s, i, num); string s; int a; getline(cin, s); stringstream ss(s); while (ss &gt;&gt; a) addEdge(i, a + n, INF); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int x = readIn(); addEdge(i + n, t, x); &#125;// printf(\"%d\\n\", sum);// printf(\"%d\\n\", maxFlow(s, t)); ans = sum - maxFlow(s, t); printPath(); printf(\"%d\\n\", ans); return 0;&#125; 「网络流 24 题」最小路径覆盖 - 3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// Created by ZJYelizaveta on 2017年08月17日 星期四 10时02分56秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 300 + 3;const int INF = 0x3f3f3f3f;int n, m;int s, t;int ans;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1]; int iter[MAX_N &lt;&lt; 1], level[MAX_N &lt;&lt; 1]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(e.cap, flow));// if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int flow = 0, d = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;int vis[MAX_N &lt;&lt; 1], fa[MAX_N &lt;&lt; 1], next[MAX_N &lt;&lt; 1];void dfs(int u) &#123; vis[u] = true; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.to &gt; n &amp;&amp; e.to &lt;= 2 * n &amp;&amp; e.cap &lt;= 0 &amp;&amp; !vis[e.to]) &#123; next[u] = (e.to - n); fa[e.to - n] = fa[u]; dfs(e.to - n); &#125; &#125;&#125;inline void printPath() &#123; memset(vis, 0, sizeof vis); memset(next, 0, sizeof next); for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i);// for (int i = 1; i &lt;= n; ++i) printf(\"%d %d\\n\", fa[i], i); for (int i = 1; i &lt;= n; ++i) if (fa[i] == i) &#123; for (int j = i; j; j = next[j]) printf(\"%d \", j); printf(\"\\n\"); &#125;&#125;int main()&#123; n = readIn(), m = readIn();// printf(\"%d %d\\n\", n, m); s = 0, t = 2 * n + 1; for (int i = 1; i &lt;= n; ++i) addEdge(s, i, 1); for (int i = 1; i &lt;= n; ++i) addEdge(i + n, t, 1); for (int i = 1; i &lt;= m; ++i) &#123; int u = readIn(), v = readIn(); addEdge(u, v + n, 1); &#125; ans = n - maxFlow(s, t); printPath(); printf(\"%d\\n\", ans); return 0;&#125; 「网络流 24 题」魔术球 - 4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// Created by ZJYelizaveta on 2017年08月19日 星期六 18时59分06秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100000 + 3;const int MAX_M = 1000000 + 3;const int INF = 0x3f3f3f3f;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge (int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1]; int iter[MAX_N &lt;&lt; 1], level[MAX_N]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs(int s, int t) &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int t, int flow) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, t, min(e.cap, flow)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; int s = _s, t = _t; int d = 0, flow = 0; while (bfs(s, t)) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, t, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;int vis[MAX_N], next[MAX_N];inline void printPath(int n) &#123; memset(vis, 0, sizeof vis); memset(next, 0, sizeof next); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; (int)G[i].size(); ++j) &#123; Edge &amp;e = G[i][j]; if (e.to &amp;&amp; e.cap &lt;= 0) next[i] = e.to - 5000;// &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (vis[i]) continue; int x = i; while (x) &#123; printf(\"%d \", x); x = next[x]; vis[x] = 1; &#125; printf(\"\\n\"); &#125;&#125;set&lt;int&gt; S;int main()&#123; for (int i = 1; i &lt;= 100; ++i) S.insert(i * i); int n = readIn(); int st = 0, ed = 100000, m = 5000, ans = 0, cnt = 0; for (int i = 1; ; ++i) &#123; addEdge(st, i, 1); addEdge(i + m, ed, 1); for (int j = 1; j &lt; i; ++j) if (S.count(i + j)) addEdge(j, i + m, 1); ans += maxFlow(st, ed); if (i - ans &gt; n) &#123; printf(\"%d\\n\", i - 1); cnt = i - 1; break; &#125; &#125;// printf(\"%d\\n\", cnt); printPath(cnt); return 0;&#125; 「网络流 24 题」圆桌聚餐 - 5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// Created by ZJYelizaveta on 2017年08月17日 星期四 21时08分55秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 270 + 3;const int MAX_M = 150 + 3;const int INF = 0x3f3f3f3f;int n, m;int s, t;int ans, sum;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1]; int iter[MAX_N &lt;&lt; 1], level[MAX_N &lt;&lt; 1]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(e.cap, flow)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int flow = 0, d = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;inline void printPath() &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; (int)G[i].size(); ++j) &#123; Edge &amp;e = G[i][j]; if (e.to &gt; n &amp;&amp; e.to &lt;= n + m &amp;&amp; !e.cap) printf(\"%d \", e.to - n); &#125; printf(\"\\n\"); &#125;&#125;int main()&#123; n = readIn(), m = readIn(); s = 0, t = n + m + 1; sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; int num = readIn(); sum += num; addEdge(s, i, num); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int num = readIn(); addEdge(i + n, t, num); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; addEdge(i, j + n, 1); &#125; &#125; ans = maxFlow(s, t); if (ans &lt; sum) printf(\"%d\\n\", 0); else &#123; printf(\"%d\\n\", 1); printPath(); &#125; return 0;&#125; 「网络流 24 题」最长递增子序列 - 6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149// Created by ZJYelizaveta on 2017年08月24日 星期四 20时02分04秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 500 + 3;const int MAXNODE = 1000 + 3;const int INF = 0x3f3f3f3f;int n;int a[MAX_N];int f[MAX_N];int maxLength;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge (int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int level[MAXNODE], iter[MAXNODE]; inline void clear() &#123; for (int i = 0; i &lt; MAXNODE; ++i) G[i].clear(); &#125; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs(int s, int t) &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow, int t) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(flow, e.cap), t); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; int s = _s, t = _t; int d = 0, flow = 0; while (bfs(s, t)) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, INF, t), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;inline int solve1() &#123; int ans = -INF; memset(f, 0, sizeof f); for (register int i = 1; i &lt;= n; ++i) &#123; f[i] = 1; for (register int j = 1; j &lt; i; ++j) &#123; if (a[i] &gt;= a[j]) f[i] = max(f[i], f[j] + 1); &#125; ans = max(ans, f[i]); &#125; return ans;&#125;inline void solve2() &#123; int s = 0, t = (n &lt;&lt; 1) + 1; for (register int i = 1; i &lt;= n; ++i) &#123; addEdge(i, i + n, 1); if (f[i] == 1) addEdge(s, i, 1); if (f[i] == maxLength) addEdge(i + n, t, 1); for (register int j = 1; j &lt; i; ++j) &#123; if (a[j] &lt;= a[i] &amp;&amp; f[j] + 1 == f[i]) addEdge(j + n, i, 1); &#125; &#125; int ans = maxFlow(s, t); printf(\"%d\\n\", ans);&#125;inline void solve3() &#123; clear(); int s = 0, t = (n &lt;&lt; 1) + 1; for (register int i = 1; i &lt;= n; ++i) &#123; int cap = 1; if (i == 1 || i == n) cap = INF;// addEdge(i, i + n, cap); if (f[i] == 1) addEdge(s, i, cap); if (f[i] == maxLength) addEdge(i + n, t, cap); for (register int j = 1; j &lt; i; ++j) &#123; if (a[j] &lt;= a[i] &amp;&amp; f[j] + 1 == f[i]) addEdge(j + n, i, 1); &#125; &#125; int ans = maxFlow(s, t); printf(\"%d\\n\", ans);&#125;int main()&#123; freopen(\"alis.in\", \"r\", stdin); freopen(\"alis.out\", \"w\", stdout); n = readIn(); for (register int i = 1; i &lt;= n; ++i) a[i] = readIn(); maxLength = solve1(); printf(\"%d\\n\", maxLength); if (maxLength == 1) printf(\"%d\\n%d\\n\", n, n); else &#123; solve2(); solve3(); &#125;// fprintf(stderr, \"Time used : %.3f\\n\", (double)clock() / CLOCKS_PER_SEC); return 0;&#125; 「网络流 24 题」试题库 - 7123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// Created by ZJYelizaveta on 2017年08月17日 星期四 22时27分08秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int INF = 0x3f3f3f3f;int k, n;int s, t;int ans, sum;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1]; int iter[MAX_N &lt;&lt; 1], level[MAX_N &lt;&lt; 1]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(e.cap, flow)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int flow = 0, d = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;inline void printSolution() &#123; for (int i = n + 1; i &lt;= n + k; ++i) &#123; printf(\"%d:\", i - n); for (int j = 0; j &lt; (int)G[i].size(); ++j) &#123; Edge &amp;e = G[i][j]; if (e.to &lt;= n &amp;&amp; e.to &gt;= 1 &amp;&amp; e.cap) printf(\" %d\", e.to); &#125; printf(\"\\n\"); &#125;&#125;int main()&#123; k = readIn(), n = readIn(); s = 0, t = k + n + 1; sum = 0; for (int i = 1; i &lt;= k; ++i) &#123; int num = readIn(); sum += num; addEdge(i + n, t, num); &#125; for (int i = 1; i &lt;= n; ++i) &#123; int cnt = readIn(); addEdge(s, i, 1); for (int j = 1; j &lt;= cnt; ++j) &#123; int type = readIn(); addEdge(i, type + n, 1); &#125; &#125; ans = maxFlow(s, t);// printf(\"%d %d\\n\", ans, sum); if (ans &lt; sum) printf(\"No Solution!\\n\"); else printSolution(); return 0;&#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/费用流/"},{"name":"最大权闭合图","slug":"最大权闭合图","permalink":"http://yoursite.com/tags/最大权闭合图/"},{"name":"最小割","slug":"最小割","permalink":"http://yoursite.com/tags/最小割/"},{"name":"二分图匹配","slug":"二分图匹配","permalink":"http://yoursite.com/tags/二分图匹配/"},{"name":"二分图多重匹配","slug":"二分图多重匹配","permalink":"http://yoursite.com/tags/二分图多重匹配/"}]},{"title":"「BZOJ 2038」小Z的袜子","slug":"「BZOJ-2038」小Z的袜子","date":"2017-09-08T15:36:12.000Z","updated":"2017-09-21T06:50:17.048Z","comments":true,"path":"2017/09/08/「BZOJ-2038」小Z的袜子/","link":"","permalink":"http://yoursite.com/2017/09/08/「BZOJ-2038」小Z的袜子/","excerpt":"题目地址 描述作为一个生活散漫的人，小Z 每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……具体来说，小Z 把这 $N( 1\\leq N \\leq 500000)$ 只袜子从 $1$ 到 $N$ 编号，然后从编号 $L$ 到 $R$ 。尽管 小Z 并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。你的任务便是告诉 小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个 $(L,R)$ 以方便自己选择。","text":"题目地址 描述作为一个生活散漫的人，小Z 每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……具体来说，小Z 把这 $N( 1\\leq N \\leq 500000)$ 只袜子从 $1$ 到 $N$ 编号，然后从编号 $L$ 到 $R$ 。尽管 小Z 并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。你的任务便是告诉 小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个 $(L,R)$ 以方便自己选择。 分析我们可以把答案表示为 ans = \\frac{\\sum_{i = l}^{r}C_{cnt[c[a[i]]]}^{2}}{C_{r - l + 1}^{2}}其中 $cnt[i]$ 为颜色 $i$ 的个数，$c[i]$ 为 $i$ 的颜色，$a[i]$ 为原颜色序列 $a$ 第 $i$ 位的颜色，我们可以将原式化简一下，变为 : ans = \\frac{\\sum_{i = l}^{r}cnt[c[a[i]] \\cdot (cnt[c[a[i]] - 1)}{(r - l + 1) \\cdot (r - l)} \\\\ = \\frac{\\sum_{i = l}^{r}{cnt[c[a[i]]}^{2} - (r - l + 1)}{(r - l + 1) \\cdot (r - l)}这样一来，单个数字对答案的贡献可以简化为 ${cnt[c[a[i]]]}^{2}(l \\leq i\\leq r)$ ，每加进来或删去一个数字时，可以 $\\Theta(1)$ 重新计算单个数字对答案的贡献来得到新区间的答案。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Created by ZJYelizaveta on 2017年09月03日 星期日 09时44分10秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 50000 + 3;const int INF = 0x3f3f3f3f;int n, m;int a[MAX_N];struct Interval &#123; int l, r, id, pos; bool operator &lt; (const Interval &amp;rhs) const &#123; if (pos == rhs.pos) return r &lt; rhs.r; return pos &lt; rhs.pos; &#125;&#125;q[MAX_N];ll cnt[MAX_N], ans[MAX_N][2], res;int blockSize, f[MAX_N];inline ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;inline void modify(int id, int w) &#123; res += (ll)2 * cnt[a[id]] * w + 1; cnt[a[id]] += w;&#125;inline void solve() &#123; memset(cnt, 0, sizeof cnt); int l = 1, r = 0; res = 0; for (int i = 1; i &lt;= m; ++i) &#123; const Interval &amp;b = q[i]; while (b.l &lt; l) &#123;--l; modify(l, 1);&#125; while (r &lt; b.r) &#123;++r; modify(r, 1);&#125; while (l &lt; b.l) &#123;modify(l, -1); ++l;&#125; while (b.r &lt; r) &#123;modify(r, -1); --r;&#125; if (b.l == b.r) &#123;ans[i][0] = 0; ans[i][1] = 1; continue;&#125; ans[i][0] = (ll)res - (b.r - b.l + 1); ans[i][1] = (ll)(b.r - b.l + 1) * (b.r - b.l); ll cur = gcd(ans[i][0], ans[i][1]); ans[i][0] = ans[i][0] / cur, ans[i][1] = ans[i][1] / cur; f[b.id] = i; &#125;&#125;int main()&#123; n = readIn(), m = readIn(); blockSize = (int)(sqrt(n)); for (int i = 1; i &lt;= n; ++i) a[i] = readIn(); for (int i = 1; i &lt;= m; ++i) &#123; q[i].l = readIn(), q[i].r = readIn(), q[i].id = i; q[i].pos = (q[i].l - 1) / blockSize + 1; &#125; sort(q + 1, q + m + 1); solve(); for (int i = 1; i &lt;= m; ++i) printf(\"%lld/%lld\\n\", ans[f[i]][0], ans[f[i]][1]); return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/莫队/"}]},{"title":"「BZOJ 1878」HH 的项链","slug":"「BZOJ-1878」HH-的项链","date":"2017-09-08T15:34:53.000Z","updated":"2017-10-21T08:19:08.032Z","comments":true,"path":"2017/09/08/「BZOJ-1878」HH-的项链/","link":"","permalink":"http://yoursite.com/2017/09/08/「BZOJ-1878」HH-的项链/","excerpt":"题目地址 描述HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。$1 \\leq n \\leq 50000, 1 \\leq m \\leq 200000$","text":"题目地址 描述HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。$1 \\leq n \\leq 50000, 1 \\leq m \\leq 200000$ 分析莫队的模板题呀QAQ考虑从 $[l, r]$ 扩展到 $[l - 1, r], [l, r + 1]$，此时边界的贝壳种类是否未出现过，是未出现的种类则答案加一，并将此种贝壳种类的个数加一。考虑从 $[l, r]$ 扩展到 $[l + 1, r], [l, r - 1]$，此时边界的贝壳中类是否只出现过一次，是只出现过一次则答案减一，并将此种贝壳种类的个数减一。剩下的直接套模板，时间复杂度 $\\Theta(n \\sqrt n)$。 这道题目还可以用树状数组来解决，时间复杂度为 $\\Theta(n log n)$，参考博客。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Created by ZJYelizaveta on Monday, September 04, 2017 PM02:12:50 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000000 + 3;const int MAX_M = 200000 + 3;const int INF = 0x3f3f3f3f;int n, m;int a[MAX_N];struct Interval &#123; int l, r, id, pos; bool operator &lt; (const Interval &amp;rhs) const &#123; if (pos == rhs.pos) return r &lt; rhs.r; return pos &lt; rhs.pos; &#125;&#125;q[MAX_M];int ans[MAX_M], blockSize, res;int cnt[MAX_N];inline int insert(int id) &#123; return ++cnt[a[id]] == 1 ? 1 : 0;&#125;inline int remove(int id) &#123; return --cnt[a[id]] == 0 ? -1 : 0;&#125;inline void solve() &#123; memset(cnt, 0, sizeof cnt); int l = 1, r = 0; res = 0; for (int i = 1; i &lt;= m; ++i) &#123; const Interval &amp;b = q[i]; while (r &lt; b.r) &#123;++r; res += insert(r);&#125; while (b.r &lt; r) &#123;res += remove(r); --r;&#125; while (b.l &lt; l) &#123;--l; res += insert(l);&#125; while (l &lt; b.l) &#123;res += remove(l); ++l;&#125; ans[b.id] = res; &#125;&#125;int main()&#123; n = readIn(); blockSize = ceil(sqrt(n)); for (int i = 1; i &lt;= n; ++i) a[i] = readIn(); m = readIn(); for (int i = 1; i &lt;= m; ++i) &#123; q[i].l = readIn(), q[i].r = readIn(), q[i].id = i; q[i].pos = (q[i].l - 1) / blockSize + 1; &#125; sort(q + 1, q + m + 1); solve(); for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/莫队/"}]},{"title":"UVa 11825 - Hackers' Crackdown","slug":"UVa-11825-Hackers-Crackdown","date":"2017-08-28T02:26:32.000Z","updated":"2017-08-28T02:26:59.836Z","comments":true,"path":"2017/08/28/UVa-11825-Hackers-Crackdown/","link":"","permalink":"http://yoursite.com/2017/08/28/UVa-11825-Hackers-Crackdown/","excerpt":"题目地址 描述一个黑客入侵一个有 $n$ 台计算机 $(1, 2, \\cdots n - 1)$ 的网络，一共有 $n(1 \\leq n \\leq 16)$ 种任务，每台计算机都运行这所有的任务。对于每台计算机可以选择一项服务，终止这台计算机与其相邻计算机之间的这种服务，你需要让尽量多的服务瘫痪。","text":"题目地址 描述一个黑客入侵一个有 $n$ 台计算机 $(1, 2, \\cdots n - 1)$ 的网络，一共有 $n(1 \\leq n \\leq 16)$ 种任务，每台计算机都运行这所有的任务。对于每台计算机可以选择一项服务，终止这台计算机与其相邻计算机之间的这种服务，你需要让尽量多的服务瘫痪。 分析我们尝试把题意抽象一下，一共有 $n$ 个集合 $sub_{1}, sub_{2}, \\cdots, sub_{n}$，将这些集合分成尽量分成多组，使得每组的集合的并集等于全集。因为 $n$ 很小，所以考虑状态压缩，我们用二进制来表示这些集合。 如果第 $i$ 台电脑与第 $j$ 台电脑相连，那么集合 $sub[i]$ 的第 $j$ 位为 $1$。12345678for (register int i = 0; i &lt; n; ++i) &#123; int num = readIn(); sub[i] = 1 &lt;&lt; i; for (register int j = 1; j &lt;= num; ++j) &#123; int cur = readIn(); sub[i] |= (1 &lt;&lt; cur); &#125;&#125; 接下来预处理 $2^{n}$ 种集合组合的并集123456for (register int S = 0; S &lt; (1 &lt;&lt; n); ++S) &#123; cover[S] = 0; for (register int i = 0; i &lt; n; ++i) if (S &amp; (1 &lt;&lt; i)) &#123; cover[S] |= sub[i]; &#125;&#125; 令 $f[S]$ 为子集 $S$ 最多可以分为多少可以覆盖全集的组合，有转移f[S] = max(f[S], (f[S - S0 \\mid S0为S的子集, cover[S0]等于全集) + 1)枚举集合的子集的小技巧 :12345678f[0] = 0;int sum = (1 &lt;&lt; n) - 1;for (register int S = 1; S &lt; (1 &lt;&lt; n); ++S) &#123;// f[S] = 0; for (register int S0 = S; S0; S0 = (S0 - 1) &amp; S) &#123; if (cover[S0] == sum) f[S] = max(f[S], f[S ^ S0] + 1); &#125;&#125; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// Created by ZJYelizaveta on 2017年08月27日 星期日 20时34分04秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 16 + 3;const int MAXNODE = 1 &lt;&lt; MAX_N;const int INF = 0x3f3f3f3f;int testCase;int n;int sub[MAXNODE], f[MAXNODE], cover[MAXNODE];inline void solve() &#123; for (register int S = 0; S &lt; (1 &lt;&lt; n); ++S) &#123; cover[S] = 0; for (register int i = 0; i &lt; n; ++i) if (S &amp; (1 &lt;&lt; i)) &#123; cover[S] |= sub[i]; &#125; &#125; f[0] = 0; int sum = (1 &lt;&lt; n) - 1; for (register int S = 1; S &lt; (1 &lt;&lt; n); ++S) &#123;// f[S] = 0; for (register int S0 = S; S0; S0 = (S0 - 1) &amp; S) &#123; if (cover[S0] == sum) f[S] = max(f[S], f[S ^ S0] + 1); &#125; &#125;&#125;int main()&#123; testCase = 0; while (scanf(\"%d\", &amp;n) &amp;&amp; n != 0) &#123; for (register int i = 0; i &lt; n; ++i) &#123; int num = readIn(); sub[i] = 1 &lt;&lt; i; for (register int j = 1; j &lt;= num; ++j) &#123; int cur = readIn(); sub[i] |= (1 &lt;&lt; cur); &#125; &#125;// for (int i = 0; i &lt; n; ++i) printf(\"%d\\n\", sub[i]); solve(); printf(\"Case %d: %d\\n\", ++testCase, f[(1 &lt;&lt; n) - 1]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"状压DP","slug":"状压DP","permalink":"http://yoursite.com/tags/状压DP/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"}]},{"title":"UVa 10891 - Game of Sum","slug":"UVa-10891-Game-of-Sum","date":"2017-08-28T02:23:33.000Z","updated":"2017-08-29T13:10:24.563Z","comments":true,"path":"2017/08/28/UVa-10891-Game-of-Sum/","link":"","permalink":"http://yoursite.com/2017/08/28/UVa-10891-Game-of-Sum/","excerpt":"题目地址 描述长度为 $n(1 \\leq n \\leq 100)$ 的整数序列，两个玩家 $\\text{A}$ 和 $\\text{B}$ 轮流取数。 $\\text{A}$ 先取，每次每一个玩家只能从序列的一端开始取若干个数，但不能在序列的两端同时取。所有数都被取走后，统计 $\\text{A}, \\text{B}$ 玩家手上的数字的和作为各自的得分。我们假定 $\\text{A}, \\text{B}$ 两个人都很聪明且采用对自己最优的策略，求 $\\text{A}$ 的得分减去 $\\text{B}$ 的得分的结果。","text":"题目地址 描述长度为 $n(1 \\leq n \\leq 100)$ 的整数序列，两个玩家 $\\text{A}$ 和 $\\text{B}$ 轮流取数。 $\\text{A}$ 先取，每次每一个玩家只能从序列的一端开始取若干个数，但不能在序列的两端同时取。所有数都被取走后，统计 $\\text{A}, \\text{B}$ 玩家手上的数字的和作为各自的得分。我们假定 $\\text{A}, \\text{B}$ 两个人都很聪明且采用对自己最优的策略，求 $\\text{A}$ 的得分减去 $\\text{B}$ 的得分的结果。 分析首先我们分析得到不管 $\\text{A}, \\text{B}$ 玩家怎样取，当前的序列一定会是原来的序列的一个连续的子序列。自然而然的我们想到用 $dp[i][j]$ 来表示对于序列 $a[i \\cdots j]$ 在双方都采用最优策略的时候先手能获得的最多的分数。 那么我们转移状态就要枚举是在序列的左边取还是在序列的右边取，分别是这样的 : 从左边开始取，那么剩下的序列为 $a[k \\cdots j] (i &lt; k \\leq j)$ 从右边开始取，那么生鲜的序列为 $a[i \\cdots k] (i \\leq k &lt; j)$ 我们要最小化剩下的序列以保证先手尽量获得更多的分数，那么有转移 : dp[i][j] = \\sum_{l = i}^{l = j}a[l] - min(dp[i + 1][j], dp[i + 1][j], \\cdots, dp[j][j], dp[i][j - 1], dp[i][j - 2], \\cdots, dp[i][i], 0)括号里的 $0$ 表示把序列全部取完，这里不用每次 $\\Theta(n)$ 扫一遍数组，只需要在读入序列 $a[]$ 的时候顺便计算一下前缀和，那么 \\sum_{l = i}^{l = j}a[l] = sum[j] - sum[i - 1] 一共有 $\\Theta(n^{2})$ 的状态，每一个状态有 $\\Theta(n)$ 的转移，所以这样直接枚举转移时间复杂度为 $\\Theta(n^{3})$，时间复杂度尚在接受范围内但是怎样能够更加优化呢？ 考虑状态转移方程dp[i][j] = \\sum_{l = i}^{l = j}a[l] - min(dp[i + 1][j], dp[i + 1][j], \\cdots, dp[j][j], dp[i][j - 1], dp[i][j - 2], \\cdots, dp[i][i], 0) 我们完全可以把最小化的部分分为三部分来计算 : 令 $f[i][j] = min(dp[i][j], dp[i + 1][j], dp[i + 1][j], \\cdots, dp[j][j])$ 令 $g[i][j] = min(dp[i][j], dp[i][j - 1], dp[i][j - 2], \\cdots, dp[i][i])$ 以及 $0$ 那么状态转移方程可以改写为dp[i][j] = \\sum_{l = i}^{l = j}a[l] - min(f[i + 1][j], g[i][j - 1], 0)其中f[i][j] = min(dp[i][j], f[i + 1][j])\\\\ g[i][j] = min(dp[i][j], g[i][j - 1])至此，我们可以在 $\\Theta(1)$ 的时间复杂度内枚举转移，总时间复杂度降为 $\\Theta(n^{2})$ 动态规划的优化，不仅仅可以用单调队列，斜率优化这类数据结构或算法来优化，有时候不妨从动态规划的本质出发。 代码时间复杂度$\\Theta(n^{3})$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Created by ZJYelizaveta on 2017年08月27日 星期日 18时26分39秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int INF = 0x3f3f3f3f;int testCase;int n;int a[MAX_N], sum[MAX_N];int dp[MAX_N][MAX_N], vis[MAX_N][MAX_N];inline int solve(int i, int j) &#123; if (vis[i][j]) return dp[i][j]; vis[i][j] = 1;// int minPart = 0; for (int k = i + 1; k &lt;= j; ++k) minPart = min(minPart, solve(k, j)); for (int k = i; k &lt; j; ++k) minPart = min(minPart, solve(i, k)); dp[i][j] = sum[j] - sum[i - 1] - minPart; return dp[i][j];&#125;int main()&#123;// freopen(\"test.in\", \"r\", stdin); while (scanf(\"%d\", &amp;n) &amp;&amp; n) &#123; memset(sum, 0, sizeof sum); sum[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = readIn(); sum[i] = sum[i - 1] + a[i]; &#125;// for (int i = 1; i &lt;= n; ++i) printf(\"%d \", sum[i]); printf(\"\\n\"); memset(vis, 0, sizeof vis); memset(dp, 0, sizeof dp); printf(\"%d\\n\", 2 * solve(1, n) - sum[n]); &#125; return 0;&#125; 时间复杂度$\\Theta(n^{2})$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Created by ZJYelizaveta on 2017年08月27日 星期日 19时06分10秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int INF = 0x3f3f3f3f;int n;int a[MAX_N], sum[MAX_N];int dp[MAX_N][MAX_N], g[MAX_N][MAX_N], f[MAX_N][MAX_N];int main()&#123; while (scanf(\"%d\", &amp;n) &amp;&amp; n) &#123; memset(sum, 0, sizeof sum); sum[0] = 0; for (register int i = 1; i &lt;= n; ++i) &#123; a[i] = readIn(); sum[i] = sum[i - 1] + a[i]; &#125; memset(dp, 0, sizeof dp); memset(g, 0, sizeof g); memset(f, 0, sizeof f); for (register int i = 1; i &lt;= n; ++i) dp[i][i] = g[i][i] = f[i][i] = a[i]; for (register int l = 1; l &lt; n; ++l) &#123; for (register int i = 1; i + l &lt;= n; ++i) &#123; int j = i + l, minPart = 0; minPart = min(minPart, f[i + 1][j]); minPart = min(minPart, g[i][j - 1]); dp[i][j] = sum[j] - sum[i - 1] - minPart; f[i][j] = min(dp[i][j], f[i + 1][j]); g[i][j] = min(dp[i][j], g[i][j - 1]);// &#125; &#125; printf(\"%d\\n\", 2 * dp[1][n] - sum[n]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"},{"name":"博弈论","slug":"博弈论","permalink":"http://yoursite.com/tags/博弈论/"},{"name":"区间DP","slug":"区间DP","permalink":"http://yoursite.com/tags/区间DP/"}]},{"title":"UVa 10635 - Prince and Princess","slug":"UVa-10635-Prince-and-Princess","date":"2017-08-28T02:21:44.000Z","updated":"2017-08-29T13:10:04.452Z","comments":true,"path":"2017/08/28/UVa-10635-Prince-and-Princess/","link":"","permalink":"http://yoursite.com/2017/08/28/UVa-10635-Prince-and-Princess/","excerpt":"题目地址 描述两个长度为$p + 1$的序列$\\text{A}$和$q + 1$的序列$\\text{B}$，每个序列中的元素各不相同，且都是$1 \\sim n^{2}$之间的整数 $(2 \\leq n \\leq 250)$。两个序列开始的第一个元素都是$1$，求$A$和$B$的最长公共子序列。","text":"题目地址 描述两个长度为$p + 1$的序列$\\text{A}$和$q + 1$的序列$\\text{B}$，每个序列中的元素各不相同，且都是$1 \\sim n^{2}$之间的整数 $(2 \\leq n \\leq 250)$。两个序列开始的第一个元素都是$1$，求$A$和$B$的最长公共子序列。 分析这道题的思想很棒棒呀QAQ就是LCS问题，但是$\\Theta(pq)$的时间复杂度承受不了，要考虑如何来优化。仔细看一遍体面我们发现有描述 :” 每个序列中的元素各不相同 “ 。我们考虑用$1 \\sim p + 1$的数字来对$\\text{A}$重新标号，举一个例子: - 1 2 3 4 5 6 7 A 1 7 5 4 8 3 9 A’ 1 2 3 4 5 6 7 那么原来的序列$\\text{A}$相当于映射到序列$\\text{A’}$，然后我们用序列$\\text{B’}$表示原序列$\\text{B}$通过已知的映射关系解出的新序列，如下: - 1 2 3 4 5 6 7 8 B 1 4 3 5 6 2 8 9 B’ 1 4 6 3 0 0 5 7 那么我们相当于将原来的求最长公共子序列的问题转化成为了求序列$\\text{B’}$的最长上升子序列的长度，而最长上升子序列问题是可以在$\\Theta(nlogn)$的时间复杂度求出来的。 令$dp[i]$为前$i$个数中最大的数的位置，那么把$dp$数组先初始化为$\\infty$。每次在$dp$数组中查询第一个大于等于$a[i]$的位置$(pos)$，然后令$dp[pos] = a[i]$，并更新答案$ans = max(ans, pos)$。 因为这里的$dp$数组保证递增，那么我们可以用二分查找来找位置，复杂度为$\\Theta(logn)$，扫一遍数组$a$的时间复杂度为$\\Theta(n)$，所以时间复杂度为$\\Theta(nlogn)$。 注意: 子序列与子串的区别在于子序列不要求在原字符串中是连续的，而子串要求在原字符串中的连续的。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Created by ZJYelizaveta on 2017年08月26日 星期六 10时47分50秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 250 + 3;const int MAXNODE = MAX_N * MAX_N;const int INF = 0x3f3f3f3f;int testCase;int n, p, q;int a[MAXNODE];map&lt;int, int&gt; M;int dp[MAXNODE];int main()&#123; testCase = readIn(); for (int num = 1; num &lt;= testCase; ++num) &#123; M.clear(); n = readIn(), p = readIn(), q = readIn(); for (int i = 1; i &lt;= p + 1; ++i) &#123; M[readIn()] = i; &#125; memset(a, 0, sizeof a); for (int i = 1; i &lt;= q + 1; ++i) &#123; int num = readIn(); a[i] = M[num]; &#125;// for (int i = 1; i &lt;= q + 1; ++i) printf(\"%d \", a[i]); printf(\"\\n\"); int cnt = q + 1, ans = 0; memset(dp, INF, sizeof dp); for (int i = 1; i &lt;= cnt; ++i) &#123; int pos = lower_bound(dp + 1, dp + cnt + 1, a[i]) - dp; dp[pos] = a[i]; ans = max(ans, pos); &#125; printf(\"Case %d: %d\\n\", num, ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"最长公共子序列","slug":"最长公共子序列","permalink":"http://yoursite.com/tags/最长公共子序列/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"最长上升子序列","slug":"最长上升子序列","permalink":"http://yoursite.com/tags/最长上升子序列/"}]},{"title":"BZOJ 1579: [Usaco2009 Feb]Revamping Trails 道路升级","slug":"BZOJ-1579-Usaco2009-Feb-Revamping-Trails-道路升级","date":"2017-08-09T12:48:52.000Z","updated":"2017-08-09T12:58:29.742Z","comments":true,"path":"2017/08/09/BZOJ-1579-Usaco2009-Feb-Revamping-Trails-道路升级/","link":"","permalink":"http://yoursite.com/2017/08/09/BZOJ-1579-Usaco2009-Feb-Revamping-Trails-道路升级/","excerpt":"题目地址 描述每天，农夫 John 需要经过一些道路去检查牛棚 $N$ 里面的牛。农场上有$M(1 \\leq M \\leq 50,000)$条双向泥土道路，编号为$1 \\cdots M$， 道路 $i$ 连接牛棚$P1_{i}$和$P2_{i}$ $(1 \\leq P1_{i} \\leq N; 1 \\leq P2_{i} \\leq N)$。John 需要$T_{i} (1 \\leq T_{i} \\leq 1,000,000)$ 时间单位用道路 $i$ 从$P1_{i}$走到$P2_{i}$或者从$P2_{i}$ 走到$P1_{i}$ 他想更新一些路经来减少每天花在路上的时间。具体地说，他想更新 $K (1 \\leq K \\leq 20)$ 条路经，将它们所须时间减为$0$。帮助 FJ 选择哪些路经需要更新使得从 $1$ 到 $N$ 的时间尽量少。","text":"题目地址 描述每天，农夫 John 需要经过一些道路去检查牛棚 $N$ 里面的牛。农场上有$M(1 \\leq M \\leq 50,000)$条双向泥土道路，编号为$1 \\cdots M$， 道路 $i$ 连接牛棚$P1_{i}$和$P2_{i}$ $(1 \\leq P1_{i} \\leq N; 1 \\leq P2_{i} \\leq N)$。John 需要$T_{i} (1 \\leq T_{i} \\leq 1,000,000)$ 时间单位用道路 $i$ 从$P1_{i}$走到$P2_{i}$或者从$P2_{i}$ 走到$P1_{i}$ 他想更新一些路经来减少每天花在路上的时间。具体地说，他想更新 $K (1 \\leq K \\leq 20)$ 条路经，将它们所须时间减为$0$。帮助 FJ 选择哪些路经需要更新使得从 $1$ 到 $N$ 的时间尽量少。 分析跟“BZOJ 2763: [JLOI2011]飞行路线”这道题目套路一样，都是分层图最短路，不过数据加强了一下。还有听说会卡 SPFA ，最好还是写堆优化的 Dijkstra 吧QAQ如果不是很理解分层图最短路的话可以看一下我上一篇博客BZOJ 2763解题报告 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 1579: [Usaco2009 Feb]Revamping Trails 道路升级// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int MAX_M = 50000 + 3;const int MAX_K = 20 + 3;const int INF = 0x3f3f3f3f;int n, m, k;struct Edge &#123; int to, next, dist, rest; Edge (int to = 0, int dist = 0, int rest = 0) : to(to), next(next), dist(dist), rest(rest)&#123;&#125; bool operator &lt; (const Edge &amp;rhs) const &#123; return dist &gt; rhs.dist; &#125;&#125;edge[MAX_M &lt;&lt; 1];int head[MAX_M], cnt = 0;int dp[MAX_N][MAX_K], ans;inline void addEdge(int from, int to, int cost) &#123; edge[++cnt].to = from; edge[cnt].dist = cost; edge[cnt].next = head[to]; head[to] = cnt; edge[++cnt].to = to; edge[cnt].dist = cost; edge[cnt].next = head[from]; head[from] = cnt;&#125;inline void dijkstra(int s) &#123; priority_queue&lt;Edge&gt; q; memset(dp, INF, sizeof dp); dp[0][k] = 0; q.push(Edge(0, 0, k)); while (!q.empty()) &#123; Edge cur = q.top(); q.pop(); int u = cur.to, dist = cur.dist, rest = cur.rest; if (dp[u][rest] &lt; dist) continue; dp[u][rest] = dist; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (dp[u][rest] + edge[i].dist &lt; dp[v][rest]) q.push(Edge(v, dp[u][rest] + edge[i].dist, rest)); if (rest &amp;&amp; dp[u][rest] &lt; dp[v][rest - 1]) q.push(Edge(v, dp[u][rest], rest - 1)); &#125; &#125;&#125;int main()&#123; n = readIn(), m = readIn(), k = readIn(); memset(head, -1, sizeof head); for (int i = 0; i &lt; m; ++i) &#123; int u = readIn(), v = readIn(), w = readIn(); --u; --v; addEdge(u, v, w); &#125; dijkstra(0); ans = INF; for (int i = 0; i &lt;= k; ++i) ans = min(ans, dp[n - 1][i]); printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://yoursite.com/tags/Dijkstra/"},{"name":"分层图最短路","slug":"分层图最短路","permalink":"http://yoursite.com/tags/分层图最短路/"}]},{"title":"BZOJ 2763: [JLOI2011]飞行路线","slug":"BZOJ-2763-JLOI2011-飞行路线","date":"2017-08-08T14:31:19.000Z","updated":"2017-08-09T13:00:31.918Z","comments":true,"path":"2017/08/08/BZOJ-2763-JLOI2011-飞行路线/","link":"","permalink":"http://yoursite.com/2017/08/08/BZOJ-2763-JLOI2011-飞行路线/","excerpt":"题目地址 描述Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 $n$ 个城市设有业务，设这些城市分别标记为 $0$ 到 $n-1$ ，一共有 $m$ 种航线，每种航线连接两个城市，并且航线有一定的价格。Alice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 $k$ 种航线上搭乘飞机。那么 Alice 和 Bob 这次出行最少花费多少？","text":"题目地址 描述Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 $n$ 个城市设有业务，设这些城市分别标记为 $0$ 到 $n-1$ ，一共有 $m$ 种航线，每种航线连接两个城市，并且航线有一定的价格。Alice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 $k$ 种航线上搭乘飞机。那么 Alice 和 Bob 这次出行最少花费多少？ 对于$30 \\%$的数据，$2 \\leq n \\leq 50$，$1 \\leq m \\leq 300$，$k = 0$对于$50 \\%$的数据，$2 \\leq n \\leq 600$，$1 \\leq m \\leq 6000$，$0 \\leq k \\leq 1$对于$100 \\%$的数据，$2 \\leq n \\leq 10000$，$1 \\leq m \\leq 50000$，$0 \\leq k \\leq 10$ 分析刚开始做这道题目的时候一点思路都没有，好像只会$50 \\%$的数据的算法，无奈，去查了一下题解，可能这道题目太简单了，题解都很简洁但是我实在太蒻了看不懂呀，于是我仔细研究了一下，好像是这样的QAQ一篇比较好的题解是这样的 $dp[i][j]$ 表示到达 $i$ 点时还有 $j$ 次边权置 $0$ 机会的最小花费，初始时 $dp[s][k]=0$，其余置为正无穷，然后随$Dijkstra$或$SPFA$转移即可，最终答案为$max (dp[t][i] \\mid 0 \\leq i \\leq k )$。 首先，其实这道题目问的就是“有$n$个点$m$条边，可以把$k$条边的边权置为$0$，求$s$到$t$的最短路”。 我们观察数据范围发现$k$比较小，我们可以通过$k$来划分阶段，那么最多有$11$个阶段，每个阶段分别为已经将$m$条边中的$k$条边的边权置为$0$的最短路。有明显的阶段性，我们考虑$DP$来转移每一层到下一层的状态。那么我们只要$DP$一下把每一层的最短路都求出来，再扫一遍$DP$数组，取一下$minAns$就可以了。 这里虽然说求的是分层图的最短路，但是实际上我们是不用把每一层的都建出来的。 对于每一条边考虑是否要将这一条边权置为$0$，（$u$为$v$的父亲结点）： 如果考虑将这一条边权置为$0$，考虑是否还有剩余机会若有则转移到下一层（向下一层的连边边权为$0$）；再考虑$dp[u][rest]是否小于dp[v][rest - 1]$，若成立则$q.push(Node(v, dp[u][rest], rest - 1))$。 若不考虑将边权置为$0$，那么更新当前答案：若$if (dp[u][rest] + edge[i].dist &lt; dp[v][rest])$成立，则$q.push(Node(v, dp[u][rest] + edge[i].dist, rest))$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// BZOJ 2763 [JLOI2011]飞行路线// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int MAX_M = 50000 + 3;const int MAX_K = 10 + 3;const int INF = 0x3f3f3f3f;int n, m, k;int s, t;struct Edge &#123; int to, next, dist, rest; Edge (int to = 0, int dist = 0, int rest = 0) : to(to), dist(dist), rest(rest)&#123;&#125;; bool operator &lt; (const Edge &amp;rhs) const &#123; return dist &gt; rhs.dist;//注意定义QAQ &#125;&#125;edge[MAX_M &lt;&lt; 1];typedef Edge Node;int head[MAX_N], cnt = 0;int dp[MAX_N][MAX_K];inline void addEdge(int from, int to, int cost) &#123; edge[++cnt].to = to; edge[cnt].dist = cost; edge[cnt].next = head[from]; head[from] = cnt; edge[++cnt].to = from; edge[cnt].dist = cost; edge[cnt].next = head[to]; head[to] = cnt;&#125;inline void dijkstra(int s) &#123; priority_queue&lt;Edge&gt; q; memset(dp, INF, sizeof dp); dp[s][k] = 0; q.push(Node(s, 0, k)); while (!q.empty()) &#123; Node cur = q.top(); q.pop(); int u = cur.to, dist = cur.dist, rest = cur.rest; if (dp[u][rest] &lt; dist) continue; dp[u][rest] = dist; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (dp[u][rest] + edge[i].dist &lt; dp[v][rest]) q.push(Node(v, dp[u][rest] + edge[i].dist, rest)); if (rest &amp;&amp; dp[u][rest] &lt; dp[v][rest - 1]) q.push(Node(v, dp[u][rest], rest - 1)); &#125; &#125;&#125;int main()&#123; n = readIn(), m = readIn(), k = readIn(); s = readIn(), t = readIn(); memset(head, -1, sizeof head); for (int i = 0; i &lt; m; ++i) &#123; int u = readIn(), v = readIn(), w = readIn(); addEdge(u, v, w); &#125; dijkstra(s); int ans = INF; for (int i = 0; i &lt;= k; ++i) ans = min(ans, dp[t][i]); printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://yoursite.com/tags/Dijkstra/"},{"name":"分层图最短路","slug":"分层图最短路","permalink":"http://yoursite.com/tags/分层图最短路/"}]},{"title":"[模板]哈夫曼树","slug":"模板-哈夫曼树","date":"2017-08-08T05:24:12.000Z","updated":"2017-08-08T05:25:00.140Z","comments":true,"path":"2017/08/08/模板-哈夫曼树/","link":"","permalink":"http://yoursite.com/2017/08/08/模板-哈夫曼树/","excerpt":"定义哈夫曼树（Huffman Tree）是一种带权路径长度最短的二叉树，也称为最优二叉树。","text":"定义哈夫曼树（Huffman Tree）是一种带权路径长度最短的二叉树，也称为最优二叉树。 树的带权路径长度：如果树中每个叶子上都带有一个权值，则把树中所有叶子的带权路径长度之和称为树的带权路径长度。 结点的带权路径长度：在一棵树中，如果其结点上附带有一个权值，通常把该结点到根结点的路径长度与该结点上的权值之积称为该结点的带权路径长度。 对一棵有$n$个叶子结点的二叉树，这棵树的带权路径长度len = \\sum_{i = 1}^{n}w_{i}l_{i}其中$w_{i}$为第$i$个叶子结点的权值，$l_{i}$为第$i$个叶子结点的路径长度。 而哈夫曼树可以最小化$\\sum_{i = 1}^{n}w_{i}l_{i}$这个式子，举一个栗子吧，如图所示 构造如果我们要构造一棵哈夫曼树，那么我们怎样来构造呢QAQ根据哈弗曼树的定义，一棵二叉树要使其带权路径长度最小，必须使权值越大的叶子结点越靠近根结点，而权值越小的叶子结点越远离根结点。 如果只要求求出最小化这个式子$\\sum_{i = 1}^{n}w_{i}l_{i}$的值： 我们可以用优先队列维护一个小根堆，先将所有的叶子结点放入小根堆。 当堆中元素个数大于$1$时，每次取出堆中两个最小元素，它们同为一个结点的左右儿子，且它们的父亲结点（非叶结点）的权值为两个元素之和 将两个叶子结点的父亲结点（非叶结点）的权值放回堆中 循环往复，直至堆中元素个数小于等于$1$ 实际上构建一棵哈夫曼树的思想和上述的差不多，具体如下： 将所有左，右子树都为空的点作为根结点。 在森林中选出两棵根结点的权值最小的树作为一棵新树的左、右子树，且令新树的新增加的根结点的权值为其左、右子树上根结点的权值之和。注意，左子树的权值应小于右子树的权值。 从森林中删除这两棵树，同时把新树加入到森林中。 重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。 哈夫曼编码哈夫曼编码（Huffman Coding）是可变字长编码(VLC)的一种，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码。我们把哈夫曼编码放在哈夫曼树上来理解，其实就是将每个二叉树的左边指定为$0$，右边指定为$1$。如图所示：一般我们所说的哈夫曼编码一般都是最有效的二进制编码，当然那么也会有最优的$k$进制编码QAQ 哈夫曼编码还有一个神奇的性质： Huffman编码使得每一个字符的编码都与另一个字符编码的前一部分不同，也就是说现在有字符$Str_{i},Str{j}$且$i &lt; j$，那么一定不存在$Str_{i}$为$Str_{j}$的前缀。 例题「NOIP 2004」 合并果子相信阅读以上之后，这道题目对你而言是一道很水的题目，相信你不看题解也能做出来哟QAQ，当然还是放上解题报告来骗流量=w=解题报告QAQ 「NOI 2015」 荷马史诗这其实维护的是一棵$k$叉的哈夫曼树具体的还是看解题报告里面吧，我觉得我写的挺清楚了QAQ解题报告QAQ","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"哈夫曼树","slug":"哈夫曼树","permalink":"http://yoursite.com/tags/哈夫曼树/"},{"name":"哈夫曼编码","slug":"哈夫曼编码","permalink":"http://yoursite.com/tags/哈夫曼编码/"}]},{"title":"「NOI 2015」 荷马史诗","slug":"「NOI-2015」-荷马史诗","date":"2017-08-08T05:19:13.000Z","updated":"2017-08-08T05:21:02.598Z","comments":true,"path":"2017/08/08/「NOI-2015」-荷马史诗/","link":"","permalink":"http://yoursite.com/2017/08/08/「NOI-2015」-荷马史诗/","excerpt":"题目地址 描述 追逐影子的人，自己就是影子。 ——荷马 Allison 最近迷上了文学。她喜欢在一个慵懒的午后，细细地品上一杯卡布奇诺，静静地阅读她爱不释手的《荷马史诗》。《荷马史诗》实在是太长了，Allison 想通过一种编码方式使得它变得短一些。 一部《荷马史诗》中有 $n$ 种不同的单词，从 $1$ 到 $n$ 进行编号。其中第 $i$ 种单词出现的总次数为 $w_{i}$。Allison 想要用 $k$ 进制串 $s_{i}$ 来替换第 $i$ 种单词，使得其满足如下要求: 对于任意的 $1 \\leq i,j \\leq n$，$i \\neq j$，都有：$s_{i}$ 不是 $s_{j}$ 的前缀。 现在 Allison 想要知道，如何选择 $s_{i}$，才能使替换以后得到的新的《荷马史诗》长度最小。在确保总长度最小的情况下，Allison 还想知道最长的 $s_{i}$ 的最短长度是多少？","text":"题目地址 描述 追逐影子的人，自己就是影子。 ——荷马 Allison 最近迷上了文学。她喜欢在一个慵懒的午后，细细地品上一杯卡布奇诺，静静地阅读她爱不释手的《荷马史诗》。《荷马史诗》实在是太长了，Allison 想通过一种编码方式使得它变得短一些。 一部《荷马史诗》中有 $n$ 种不同的单词，从 $1$ 到 $n$ 进行编号。其中第 $i$ 种单词出现的总次数为 $w_{i}$。Allison 想要用 $k$ 进制串 $s_{i}$ 来替换第 $i$ 种单词，使得其满足如下要求: 对于任意的 $1 \\leq i,j \\leq n$，$i \\neq j$，都有：$s_{i}$ 不是 $s_{j}$ 的前缀。 现在 Allison 想要知道，如何选择 $s_{i}$，才能使替换以后得到的新的《荷马史诗》长度最小。在确保总长度最小的情况下，Allison 还想知道最长的 $s_{i}$ 的最短长度是多少？ 分析我们仔细分析一下发现好像和合并果子有一点像呀QAQ $n$种不同的单词相当于树上的$n$个结点，我们可以把单词的出现次数$(w_{i}为第i个单词的出现次数)$当成该结点的权值，而结点到树的根结点的路径长度（也可以说是深度）就是$k$进制串$s_{i}$的长度$(l_{i}为第i个单词的长度)$，那么我们要最小化的就是 len = \\sum_{i = 1}^{n} w_{i}l_{i}我们发现这和之前让我们最小化的哈夫曼树的$len$形式上是一样的，我们考虑哈夫曼树的构造过程其实就是“使权值越大的叶子结点越靠近根结点，而权值越小的叶子结点越远离根结点”，那么这里也是一样的。 那么这其实就是最小化一棵$k$叉的哈夫曼树的带权路径长度。 刚开始我一直不明白为什么一定是一棵$k$叉哈夫曼树，其实很好理解，我们可以从哈夫曼编码的方面来思考： 其实我们就是每次贪心使得出现次数最多的单词用$k$ 进制串 $s_{i}$替换后的$s_{i}$长度最小 而$k$进制串$s_{i}$的长度相当于结点到树的根结点的路径长度（也可以说是深度），那么我们要最小化深度 也就是我们要尽量将哈夫曼树中每一层$k$进制在当前层对应的$k$个结点尽量填满 那么也就是说一个满$k$叉的哈夫曼树一定会更优一些 在$k$叉哈夫曼树每回都满叉的情况下，我们像维护一棵普通的二叉哈夫曼树一样用一个优先队列来维护。 但是若存在哈夫曼树的某一层的上，哈夫曼树并不能满$k$叉呢QAQ和我们构造最优二叉哈夫曼树一样每次合并引入虚拟结点令其权值为左右儿子权值之和，这里我们一样引入虚拟结点的概念，我们让权值为$0$的虚拟结点来填补使得$k$叉哈夫曼树是满$k$叉的。我们每次更新$n = n - k + 1$，然后判断$(n - 1) % (k - 1)$如果等于$0$就是满$k$叉；否则要用虚拟结点来填补，一共需要$(k - 1) - ((n - 1) \\% (k - 1))$个虚拟结点。 然而此题还要求$s_{i}$的最大值最小，那么我们让$k$叉哈夫曼树的结点代表一个二元组$(val，len)$，表示这个结点的权值和结点到根结点的路径长度。在求最小$k$个点时，把$val$作为第一比较条件，如果$val$值相等，则把$len$小的放在前面，这样在每次合并的时候，长度小的点都会被优先合并，保证了根到叶子的最长链的长度尽量小。 所以，可以得到此题的算法： 用优先队列把$(val,len = 0)$$Push$进去，处理虚拟点$(val = 0, len = 0)$。 每次用优先队列弹出前$k$小的点，求它们的$val$之和$sum$，求它们的$len$的最大值$length$，那么将结点$(sum,length+1)$加入优先队列，且$ans+=sum$。 当容器内只有一个点时，输出$ans$和这个点的$len$值。 最终时间复杂度是$\\Theta (nlogn)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 「NOI 2015」 荷马史诗// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline ll readIn() &#123; ll x = 0; int f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return (ll)x * f;&#125;const int MAX_N = 100000 + 3;const int INF = 0x3f3f3f3f;ll n, k;struct Node &#123; ll val, len; Node (const ll val, const ll len) : val(val), len(len)&#123;&#125; bool operator &lt; (const Node &amp;rhs) const &#123; if (val == rhs.val) return len &gt; rhs.len;//注意定义 return val &gt; rhs.val;// &#125;&#125;;priority_queue&lt;Node&gt; q;ll ans, sum, maxLen, cnt;int main()&#123; n = readIn(), k = readIn(); while (!q.empty()) q.pop(); for (int i = 1; i &lt;= n; ++i) &#123; ll val = readIn(); q.push(Node(val, 0)); &#125; cnt = n; if ((n - 1) % (k - 1)) cnt += ((k - 1) - ((n - 1) % (k - 1))); for (int i = n + 1; i &lt;= cnt; ++i) q.push(Node(0, 0));/* for (int i = 1; i &lt;= n; ++i) &#123; Node cur = q.top(); q.pop(); printf(\"%lld %lld\\n\", cur.val, cur.len); &#125;*/ ans = 0; while (q.size() &gt; 1) &#123; sum = 0, maxLen = 0; for (int i = 1; i &lt;= k; ++i) &#123; Node cur = q.top(); q.pop(); sum += cur.val; maxLen = max(maxLen, cur.len); &#125; ans += sum; q.push(Node(sum, maxLen + 1)); &#125; printf(\"%lld\\n%lld\\n\", ans, q.top().len); return 0;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"哈夫曼树","slug":"哈夫曼树","permalink":"http://yoursite.com/tags/哈夫曼树/"},{"name":"哈夫曼编码","slug":"哈夫曼编码","permalink":"http://yoursite.com/tags/哈夫曼编码/"},{"name":"NOI","slug":"NOI","permalink":"http://yoursite.com/tags/NOI/"}]},{"title":"「NOIP 2004」 合并果子","slug":"「NOIP-2004」-合并果子","date":"2017-08-07T16:14:34.000Z","updated":"2017-08-07T16:17:21.309Z","comments":true,"path":"2017/08/08/「NOIP-2004」-合并果子/","link":"","permalink":"http://yoursite.com/2017/08/08/「NOIP-2004」-合并果子/","excerpt":"题目地址 描述在一个果园里，多多按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过$n-1$次合并之后，就只剩下一堆了，多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。多多在合并果子时要尽可能地节省体力。假定每个果子重量都为$1$，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。$1 \\leq n \\leq 10000$","text":"题目地址 描述在一个果园里，多多按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过$n-1$次合并之后，就只剩下一堆了，多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。多多在合并果子时要尽可能地节省体力。假定每个果子重量都为$1$，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。$1 \\leq n \\leq 10000$ 分析其实是一道哈夫曼树的裸题QAQ我们仔细分析冗长的题面后发现，题目其实就是让我们最小化这个式子$\\sum_{i = 1}^{n}w_{i}l_{i}$的值，我们可以进行如下的操作： 我们可以用优先队列维护一个小根堆，先将所有的叶子结点放入小根堆。 当堆中元素个数大于$1$时，每次取出堆中两个最小元素，它们同为一个结点的左右儿子，且它们的父亲结点（非叶结点）的权值为两个元素之和。 将两个叶子结点的父亲结点（非叶结点）的权值放回堆中。 循环往复，直至堆中元素个数小于等于$1$。 时间复杂度为$\\Theta(n)$ 代码1234567891011121314151617181920212223242526272829303132333435363738// NOIP 2004 合并果子// Copyright (c) 2017年 ZJYelizaveta. All rights reserved;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int INF = 0x3f3f3f3f;int n;priority_queue&lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;int ans;int main()&#123; n = readIn(); while (!q.empty()) q.pop(); for (int i = 0; i &lt; n; ++i) &#123; int num = readIn(); q.push(num); &#125; ans = 0; while (q.size() &gt; 1) &#123; int a = q.top(); q.pop(); int b = q.top(); q.pop(); ans += (a + b); q.push(a + b); &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"NOIP","slug":"NOIP","permalink":"http://yoursite.com/tags/NOIP/"},{"name":"哈夫曼树","slug":"哈夫曼树","permalink":"http://yoursite.com/tags/哈夫曼树/"}]},{"title":"BZOJ 1578: [Usaco2009 Feb]Stock Market 股票市场","slug":"BZOJ-1578-Usaco2009-Feb-Stock-Market-股票市场","date":"2017-08-02T15:32:50.000Z","updated":"2017-08-08T07:31:07.891Z","comments":true,"path":"2017/08/02/BZOJ-1578-Usaco2009-Feb-Stock-Market-股票市场/","link":"","permalink":"http://yoursite.com/2017/08/02/BZOJ-1578-Usaco2009-Feb-Stock-Market-股票市场/","excerpt":"题目地址 描述尽管奶牛们天生谨慎，她们仍然在住房抵押信贷市场中受到打击，现在她们开始着手于股市。 Bessie很有先见之明，她不仅知道今天$S (2 \\leq S \\leq 50)$只股票的价格，还知道接下来一共$D(2 \\leq D \\leq 10)$天的（包括今天）。给定一个$D$天的股票价格矩阵$（1 \\leq 价格 \\leq 1000）$以及初始资金$M(1 \\leq M \\leq 200,000)$，求一个最优买卖策略使得最大化总获利。每次必须购买股票价格的整数倍，同时你不需要花光所有的钱（甚至可以不花）。这里约定你的获利不可能超过$500,000$。","text":"题目地址 描述尽管奶牛们天生谨慎，她们仍然在住房抵押信贷市场中受到打击，现在她们开始着手于股市。 Bessie很有先见之明，她不仅知道今天$S (2 \\leq S \\leq 50)$只股票的价格，还知道接下来一共$D(2 \\leq D \\leq 10)$天的（包括今天）。给定一个$D$天的股票价格矩阵$（1 \\leq 价格 \\leq 1000）$以及初始资金$M(1 \\leq M \\leq 200,000)$，求一个最优买卖策略使得最大化总获利。每次必须购买股票价格的整数倍，同时你不需要花光所有的钱（甚至可以不花）。这里约定你的获利不可能超过$500,000$。 分析是一道想法还是挺妙的一道题目看这道题目的时候总觉得有一点熟悉的感觉，怎么这么像背包DP，事实上这就是一个背包DP QAQ 但是还是有一个挺奇妙的想法就是“不用考虑一支买进的股票在哪一天卖出，我们只需要今天买进明天卖出就可以了” 有了这个结论那么就好做了，我们把每一天当做一个完全背包来做，背包的体积为手中持有的资金，背包有两个状态： 一个是不买进，也不卖出 还有一个是买进当前的一只股票，并在明天卖出 那么我们有状态$dp[k]$为手中持有资金为$k$时能获利最多的钱转移方程为dp[k] = max(dp[k], dp[k - w[i][j]] + w[i][j + 1] - w[i][j])(k为持有资金, i为第i支股票, j为第j天)每天做一次完全背包并更新手中持有资金，然后做出来了QAQ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243// BZOJ 1578 [Usaco2009 Feb]Stock Market 股票市场// Copyright (c) 2017年 ZJYelizaveta. All rights reserved;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_S = 50 + 3;const int MAX_D = 10 + 3;const int MAX_M = 500000 + 3;const int INF = 0x3f3f3f3f;int s, d, m;int w[MAX_S][MAX_D];int dp[MAX_M], ans;int main()&#123; s = readIn(), d = readIn(), m = readIn(); for (int i = 0; i &lt; s; ++i) &#123; for (int j = 0; j &lt; d; ++j) w[i][j] = readIn(); &#125; ans = m; memset(dp, 0, sizeof dp); for (int i = 0; i &lt; d; ++i) &#123; memset(dp, 0, sizeof dp); for (int j = 0; j &lt; s; ++j) &#123; for (int k = w[j][i]; k &lt;= ans; ++k) &#123; dp[k] = max(dp[k], dp[k - w[j][i]] + w[j][i + 1] - w[j][i]); &#125; &#125; ans += dp[ans]; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"[模板]传递闭包","slug":"模板-传递闭包","date":"2017-08-02T06:35:27.000Z","updated":"2017-08-02T06:36:50.877Z","comments":true,"path":"2017/08/02/模板-传递闭包/","link":"","permalink":"http://yoursite.com/2017/08/02/模板-传递闭包/","excerpt":"很久之前听说过，今天学习一下QAQ 简介传递闭包，在数学中表示为在集合 $X$ 上的二元关系 $R$ 的传递闭包是包含 $R$ 的 $X$ 上的最小的传递关系。","text":"很久之前听说过，今天学习一下QAQ 简介传递闭包，在数学中表示为在集合 $X$ 上的二元关系 $R$ 的传递闭包是包含 $R$ 的 $X$ 上的最小的传递关系。 而在图论中就是如果$u \\rightarrow v$有一条边，$v \\rightarrow t$有一条边，那么$u$能到达$t$。而我们求传递闭包，就是把图中所有满足这样传递性的结点都枚举出来，计算完成后，我们就知道任意两个结点之间是否相连。 应该就是这样理解的，如果有理解不当的地方欢迎指出QAQ 代码$n$个点$m$条边，用$Floyd$求传递闭包，代码应该比较好理解就不解释了QAQ12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int INF = 0x3f3f3f3f;int n, m;bool con[MAX_N][MAX_N];int main()&#123; n = readIn(), m = readIn(); memset(con, 0, sizeof con); for (int i = 0; i &lt; m; ++i) &#123; int u = readIn() - 1, v = readIn() - 1; con[u][v] = 1; &#125; for (int k = 0; k &lt; n; ++k) &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; con[i][j] = con[i][j] || (con[i][k] &amp;&amp; con[k][j]); // 判断两个点联通的两个情况 &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"传递闭包","slug":"传递闭包","permalink":"http://yoursite.com/tags/传递闭包/"}]},{"title":"BZOJ 1577: [Usaco2009 Feb]庙会捷运Fair Shuttle","slug":"BZOJ-1577-Usaco2009-Feb-庙会捷运Fair-Shuttle","date":"2017-08-01T14:42:35.000Z","updated":"2017-08-01T14:43:32.216Z","comments":true,"path":"2017/08/01/BZOJ-1577-Usaco2009-Feb-庙会捷运Fair-Shuttle/","link":"","permalink":"http://yoursite.com/2017/08/01/BZOJ-1577-Usaco2009-Feb-庙会捷运Fair-Shuttle/","excerpt":"题目地址 描述公交车一共经过$N(1 \\leq N \\leq 20000)$个站点，从站点$1$一直驶到站点$N$。$K(1\\leq K \\leq 50000)$群奶牛希望搭乘这辆公交车，第$i$群牛一共$M_{i}(1\\leq M_{i} \\leq N)$只，他们希望从$S_{i}$到$E_{i}$去。公交车只能坐$C(1\\leq C \\leq 100)$只奶牛，而且不走重复路线，请计算这辆车最多能满足多少奶牛听要求。注意：对于每一群奶牛，可以部分满足，也可以全部满足，也可以全部不满足。","text":"题目地址 描述公交车一共经过$N(1 \\leq N \\leq 20000)$个站点，从站点$1$一直驶到站点$N$。$K(1\\leq K \\leq 50000)$群奶牛希望搭乘这辆公交车，第$i$群牛一共$M_{i}(1\\leq M_{i} \\leq N)$只，他们希望从$S_{i}$到$E_{i}$去。公交车只能坐$C(1\\leq C \\leq 100)$只奶牛，而且不走重复路线，请计算这辆车最多能满足多少奶牛听要求。注意：对于每一群奶牛，可以部分满足，也可以全部满足，也可以全部不满足。 分析蒟蒻日常一水QAQ看到这个题目很容易想到贪心，实际上这道题目本质就是一道贪心的经典题目“活动安排问题”。 首先我们按照每一群奶牛的终点排序，若终点相同则按照起点排序。然后用一个数组$b[]$来维护$1 \\sim n$每个结点上的最多奶牛数量。然后$1 \\sim k$只奶牛从前到后扫一遍，对于每一只奶牛$i$若$b[i] &lt; c$则可以继续考虑，否则考虑下一只奶牛。对于每一只被考虑的奶牛，记一只奶牛从$s$到$e$中最少能够再加入的奶牛只数$temp$（相当于维护了每一个结点奶牛数量尽可能多），然后对于奶牛所处的$s$到$e$的结点扫一遍更新$temp$。然后考虑$temp$大于等于当前奶牛群只数的情况以及小于的情况，更新$b[]$以及$ans$。 在数据范围较小的时候，这样做是可以水过去的，但是在数据范围较大的时候还是需要用线段树来维护区间的最大值，所以我明天再来补一下用线段树维护的版本吧QAQ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// BZOJ 1577 [Usaco2009 Feb]庙会捷运Fair Shuttle// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 20000 + 3;const int MAX_K = 50000 + 3;const int INF = 0x3f3f3f3f;int k, n, c;// cows, points, containstruct Node &#123; int s, e, m; bool operator &lt; (const Node &amp;rhs) const &#123; if (e == rhs.e) return s &lt; rhs.s; return e &lt; rhs.e; &#125;&#125;a[MAX_K];int b[MAX_N], ans, temp;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif k = readIn(), n = readIn(), c = readIn(); for (int i = 0; i &lt; k; ++i) a[i].s = readIn(), a[i].e = readIn(), a[i].m = readIn(); sort(a, a + k); ans = 0, temp = 0; memset(b, 0, sizeof b); for (int i = 0; i &lt; k; ++i) &#123; temp = INF; if (b[a[i].s] &lt; c) &#123; for (int j = a[i].s; j &lt; a[i].e; ++j) &#123; temp = min(temp, c - b[j]); if (temp == 0) break; &#125; if (temp != 0) &#123; if (temp &gt;= a[i].m) &#123; for (int j = a[i].s; j &lt; a[i].e; ++j) b[j] += a[i].m; ans += a[i].m; &#125; else &#123; for (int j = a[i].s; j &lt; a[i].e; ++j) b[j] += temp; ans += temp; &#125; &#125; &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"}]},{"title":"[Codeforces 19D] Points","slug":"Codeforces-19D-Points","date":"2017-07-30T03:29:41.000Z","updated":"2017-07-31T05:06:54.370Z","comments":true,"path":"2017/07/30/Codeforces-19D-Points/","link":"","permalink":"http://yoursite.com/2017/07/30/Codeforces-19D-Points/","excerpt":"题目地址 描述在二维平面上内进行$n (1 \\leq n \\leq 2 \\cdot 10^{5})$次操作，一共有三种种类的操作： $add$ $x,y$ 将点$(x,y)$加入二维平面坐标系内。 $remove$ $x,y$ 将点$(x,y)$从二维平面坐标系内删除。 $find$ $x,y$ 找到点$(x,y)$右上角的点集$(x_{i} &gt; x, y_{i} &gt; y)$。如果有多个输出$x$最小的，若还是存在多个输出$y$最小的。 每次操作满足$x,y$均为非负数，且操作合法。","text":"题目地址 描述在二维平面上内进行$n (1 \\leq n \\leq 2 \\cdot 10^{5})$次操作，一共有三种种类的操作： $add$ $x,y$ 将点$(x,y)$加入二维平面坐标系内。 $remove$ $x,y$ 将点$(x,y)$从二维平面坐标系内删除。 $find$ $x,y$ 找到点$(x,y)$右上角的点集$(x_{i} &gt; x, y_{i} &gt; y)$。如果有多个输出$x$最小的，若还是存在多个输出$y$最小的。 每次操作满足$x,y$均为非负数，且操作合法。 分析是一道很有趣的题目QAQ首先我们考虑在可以完成前两个操作的前提下，如何能够快速的找到在$(x, y)$右上角中满足条件的最小的点的坐标。 显而易见我们会想到对于$x$的不同取值维护一个$set$ ( 每一个$set$中维护$x’ = val$时$y’$的取值 ) ，只要我们能快速找到满足条件的最小的$x$，那么我们就可以用$set$中的upper_bound快速查询在$x’$取最小值的时候第一个大于$y$的$y’$的取值。 那么我们现在只用实现快速查询大于$x$的第一个$x’$的值即可 ，我们可以用一棵线段树来维护和支持查询满足条件的最小的$x$。 由于$1 \\leq x_{i}, y_{i} \\leq 10^{9}$，所以我们考虑将坐标$x$离散化那么线段树上最多$2n$个结点，然后我们尝试构造一棵线段树，线段树的每个叶子节点维护一个$set$，$set$里面维护的就是我们前面说的 “ 坐标为$x’ = val$的点的$y$坐标的集合 ”，而线段树维护区间内所有点能达到的$y$的最大值。 每次插入删除点的时候就在线段树上单点更新。 查询的时候看区间$[x+1, m]$内$node[o].maxy$是否大于$y$，若不存在则返回$-1$，否则返回最左边满足集合内存在$y$坐标大于查询的值的下标，然后在下标所在的集合二分查询最小的大于$y$的$y’$值即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// Created by ZJYelizaveta on 2017年07月31日 星期一 08时09分18秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 200000 + 3;const int INF = 0x3f3f3f3f;int n, m;struct Operations &#123; char str[10]; int x, y;&#125;op[MAX_N];int a[MAX_N];set&lt;int&gt; s[MAX_N];namespace segmentTree &#123; #define ls ((o) &lt;&lt; 1) #define rs (((o) &lt;&lt; 1) + 1) #define mid (((l) + (r)) &gt;&gt; 1) struct Node &#123; int maxy; &#125;node[MAX_N * 4]; inline void build(int o, int l, int r) &#123; node[o].maxy = -1; if (l == r) return;// printf(\"%d %d %d %d %d %d\\n\", o, l, r, ls, rs, mid); build(ls, l, mid); build(rs, mid + 1, r); &#125; void modify(int o, int l, int r, int pos) &#123; if (l == r) &#123; if (s[pos].size()) node[o].maxy = *(--s[pos].end()); else node[o].maxy = -1; return; &#125; if (pos &lt;= mid) modify(ls, l, mid, pos); else modify(rs, mid + 1, r, pos); node[o].maxy = max(node[ls].maxy, node[rs].maxy); &#125; int query(int o, int l, int r, int lc, int rc, int val) &#123; if (node[o].maxy &lt;= val || lc &gt; rc) return -1;// if (l == r) return l;// if (rc &lt;= mid) return query(ls, l, mid, lc, rc, val); else if (lc &gt; mid) return query(rs, mid + 1, r, lc, rc, val);// else &#123; int temp = query(ls, l, mid, lc, rc, val); if (temp != -1) return temp; else return query(rs, mid + 1, r, lc, rc, val); &#125; &#125;&#125;using namespace segmentTree;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%s\", op[i].str); a[i] = op[i].x = readIn(), op[i].y = readIn();// printf(\"\\n\");// printf(\"%s %d %d\\n\", op[i].str, op[i].x, op[i].y); &#125; sort(a + 1, a + n + 1); m = unique(a + 1, a + n + 1) - a - 1; build(1, 1, m);// printf(\"%d\\n\", m); for (int i = 1; i &lt;= m; ++i) s[i].clear(); for (int i = 1; i &lt;= n; ++i) &#123; int x = lower_bound(a + 1, a + m + 1, op[i].x) - a;// printf(\"%d\\n\", x); if (op[i].str[0] == 'a') &#123; s[x].insert(op[i].y); modify(1, 1, m, x); &#125; else if (op[i].str[0] == 'r') &#123; s[x].erase(op[i].y); modify(1, 1, m, x); &#125; else if (op[i].str[0] == 'f') &#123; int pos = query(1, 1, m, x + 1, m, op[i].y);// printf(\"%d\\n\", pos); if (pos == -1) printf(\"%d\\n\", -1); else printf(\"%d %d\\n\", a[pos], *s[pos].upper_bound(op[i].y)); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/tags/Codeforces/"},{"name":"离散化","slug":"离散化","permalink":"http://yoursite.com/tags/离散化/"}]},{"title":"[CTSC 1999]补丁VS错误","slug":"CTSC-1999-补丁VS错误","date":"2017-07-30T03:20:50.000Z","updated":"2017-07-30T03:24:54.662Z","comments":true,"path":"2017/07/30/CTSC-1999-补丁VS错误/","link":"","permalink":"http://yoursite.com/2017/07/30/CTSC-1999-补丁VS错误/","excerpt":"题目地址 描述题面比较长而且有些晦涩，这里就不贴了。简要的描述一下：你现在有一个包含$n$种$bug$、$m$个补丁的软件，每一个补丁有五个参数，补丁的运行时间$t$，此补丁能够运行当且仅当补丁所在的软件包含$B_{i}+$中的所有$bug$而不包含$B_{i}-$中的任何$bug$，应用此补丁之后软件将修复$F_{i}-$个$bug$同时产生$F_{i}+$个新$bug$。每一个补丁可以安装多次，求修复完所有$bug$的最短的时间；如果问题有解，输出总耗时，否则输出$0$。$1 \\leq n \\leq 15, 1 \\leq m \\leq 100$","text":"题目地址 描述题面比较长而且有些晦涩，这里就不贴了。简要的描述一下：你现在有一个包含$n$种$bug$、$m$个补丁的软件，每一个补丁有五个参数，补丁的运行时间$t$，此补丁能够运行当且仅当补丁所在的软件包含$B_{i}+$中的所有$bug$而不包含$B_{i}-$中的任何$bug$，应用此补丁之后软件将修复$F_{i}-$个$bug$同时产生$F_{i}+$个新$bug$。每一个补丁可以安装多次，求修复完所有$bug$的最短的时间；如果问题有解，输出总耗时，否则输出$0$。$1 \\leq n \\leq 15, 1 \\leq m \\leq 100$ 分析题意理解了好久QAQ我们可以肯定最多只有$2^{n}$种错误情况，初始状态为$2^{n} - 1$， 最后要求达到的状态是$0$。进一步我们发现$n$实际上很小，可以状压，那么可以想到用二进制来表示出所有的错误情况。 接下来我们可以枚举所有的错误情况和当前所有的补丁，若存在当前软件的错误情况可以使用补丁$i$，那么就从当前状态添加一条指向当前状态使用完此补丁后的状态的有向边，这条有向边的权值为使用补丁$i$的运行时间。显而易见，我们只用求初始状态$s$到最终状态$t$的最短路即可。 其实，这道题目还有一个解法，就是每一次判断当前的补丁是否可用，然后对于当前状态用Hash判重+DFS也可以水过去的QAQ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// Created by ZJYelizaveta on 2017年07月29日 星期六 22时12分38秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = (1 &lt;&lt; (15 + 3));const int INF = 0x3f3f3f3f;int n, m, s, t;int w[MAX_N];char str1[MAX_N], str2[MAX_N];struct Limited &#123; int s1[MAX_N], s2[MAX_N], t1[MAX_N], t2[MAX_N]; //b+, b-, f+, f-&#125;lim;struct Edge &#123; int to, w; Edge(int to = 0, int w = 0) : to(to), w(w)&#123;&#125;&#125;;vector&lt;Edge&gt; G[MAX_N];int dist[MAX_N];bool inq[MAX_N];inline void addEdge(int from, int to, int w) &#123; G[from].push_back(Edge(to, w));&#125;inline void SPFA() &#123; memset(inq, false, sizeof inq); memset(dist, INF, sizeof dist); queue&lt;int&gt; q; q.push(s); inq[s] = true; dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (dist[e.to] &gt; dist[u] + e.w) &#123; dist[e.to] = dist[u] + e.w; if (!inq[e.to]) &#123; q.push(e.to); inq[e.to] = 1; &#125; &#125; &#125; &#125; if (dist[t] == INF) printf(\"%d\\n\", 0); else printf(\"%d\\n\", dist[t]);&#125;int main()&#123; n = readIn(), m = readIn(); s = (1 &lt;&lt; n) - 1, t = 0; for (int i = 0; i &lt; m; ++i) &#123; w[i] = readIn(); scanf(\"%s\", str1); for (int j = 0; j &lt; n; ++j) &#123; if (str1[j] == '+') lim.s1[i] |= (1 &lt;&lt; j); else if (str1[j] == '-') lim.s2[i] |= (1 &lt;&lt; j); &#125; scanf(\"%s\", str2); for (int j = 0; j &lt; n; ++j) &#123; if (str2[j] == '+') lim.t1[i] |= (1 &lt;&lt; j); else if (str2[j] == '-') lim.t2[i] |= (1 &lt;&lt; j); &#125; &#125;// for (int i = 0; i &lt; m; ++i) printf(\"%d \", lim.s1[i]); printf(\"\\n\");// for (int i = 0; i &lt; m; ++i) printf(\"%d \", lim.s2[i]); printf(\"\\n\");// for (int i = 0; i &lt; m; ++i) printf(\"%d \", lim.t1[i]); printf(\"\\n\");// for (int i = 0; i &lt; m; ++i) printf(\"%d \", lim.t2[i]); printf(\"\\n\"); for (int i = s; i &gt;= t; --i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (((i &amp; lim.s1[j]) == lim.s1[j]) &amp;&amp; ((i &amp; lim.s2[j]) == 0)) &#123; addEdge(i, ((i &amp; (~lim.t2[j])) | lim.t1[j]), w[j]);// printf(\"%d %d %d\\n\", i, (i &amp; (~lim.t2[j]) | lim.t1[j]), w[j]); &#125; &#125; &#125; SPFA(); return 0;&#125;","categories":[],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://yoursite.com/tags/位运算/"},{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/最短路/"},{"name":"SPFA","slug":"SPFA","permalink":"http://yoursite.com/tags/SPFA/"}]},{"title":"[IOI1999]花店橱窗布置","slug":"IOI1999-花店橱窗布置","date":"2017-07-30T03:19:20.000Z","updated":"2017-07-30T03:23:44.237Z","comments":true,"path":"2017/07/30/IOI1999-花店橱窗布置/","link":"","permalink":"http://yoursite.com/2017/07/30/IOI1999-花店橱窗布置/","excerpt":"描述某花店现有$F$束花，每一束花的品种都不一样，同时至少有同样数量的花瓶，被按顺序摆成一行，花瓶的位置是固定的，从左到右按$1$到$V$顺序编号，$V$是花瓶的数目。花束可以移动，并且每束花用$1$到$F$的整数标识。如$i &lt; j$，则花束$i$必须放在花束$j$左边的花瓶中。例如，假设杜鹃花的标识数为$1$，秋海棠的标识数为$2$，康乃馨的标识数为$3$，所有花束在放入花瓶时必须保持其标识数的顺序，即杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。如果花瓶的数目大于花束的数目，则多余的花瓶必须空，即每个花瓶只能放一束花。","text":"描述某花店现有$F$束花，每一束花的品种都不一样，同时至少有同样数量的花瓶，被按顺序摆成一行，花瓶的位置是固定的，从左到右按$1$到$V$顺序编号，$V$是花瓶的数目。花束可以移动，并且每束花用$1$到$F$的整数标识。如$i &lt; j$，则花束$i$必须放在花束$j$左边的花瓶中。例如，假设杜鹃花的标识数为$1$，秋海棠的标识数为$2$，康乃馨的标识数为$3$，所有花束在放入花瓶时必须保持其标识数的顺序，即杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。如果花瓶的数目大于花束的数目，则多余的花瓶必须空，即每个花瓶只能放一束花。 每个花瓶的形状和颜色也不相同，因此，当各个花瓶中放入不同的花束时，会产生不同的美学效果，并以美学值（一个整数）来表示，空置花瓶的美学值为$0$。在上述的例子中，花瓶与花束的不同搭配所具有的美学值，可以用如下的表格来表示： - 花瓶1 花瓶2 花瓶3 花瓶4 花瓶5 杜鹃花 7 23 -5 -24 16 秋海棠 5 21 -4 10 23 康乃馨 -21 5 -4 -20 20 根据表格，杜鹃花放在花瓶$2$中，会显得非常好看，但若放在花瓶$4$中，则显得很难看。为了取得最佳的美学效果，必须在保持花束顺序的前提下，使花的摆放取得最大的美学值，如果具有最大美学值的摆放方式不止一种，则输出任何一种方案即可。 分析很容易发现这道题目有很明显的阶段性且$n$也比较小可以接受$\\Theta(n^{2})$，所以我们可以往动态规划的方面来想。考虑以花朵的数目来划分阶段，那么定义$dp[i][j]$为前$i$朵花放在前$j$个花瓶李。那么我们就有规划方程dp[i][j] = max(dp[i - 1][j - 1] + w[i][j], dp[i][j - 1])方程很容易理解，我们考虑第$i$朵花应该如何放置： 选择将第$i$朵花放在第$j$个瓶子中，那么此时的美学值为$dp[i - 1][j - 1] + w[i][j]$，$w[i][j]$为将第$i$朵花放入第$j$个瓶子的美学值。 选择不将第$i$朵花放在第$j$个瓶子中，那么此时的美学值为$dp[i][j - 1]$最后递归打印路径就可以了。其实也可以选择以花瓶数为阶段来划分，这里就不写了QAQ代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Created by ZJYelizaveta on 2017年07月28日 星期五 10时49分36秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int INF = 0x3f3f3f3f;int n, m;int w[MAX_N][MAX_N];int dp[MAX_N][MAX_N];bool vis[MAX_N][MAX_N];inline void printPath(int x, int y) &#123; if (x == 0) return; else if (vis[x][y] == 1)&#123; printPath(x - 1, y - 1); printf(\"%d \", y); &#125; else printPath(x, y - 1);&#125;int main()&#123; n = readIn(), m = readIn(); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) w[i][j] = readIn(); &#125;/* for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) printf(\"%d \", w[i][j]); printf(\"\\n\"); &#125; return 0;*/ memset(vis, 0, sizeof vis); memset(dp, -INF, sizeof dp); for (int i = 0; i &lt;= m; ++i) dp[0][i] = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = i; j &lt;= m &amp;&amp; i &lt;= i + n; ++j) &#123; if (dp[i - 1][j - 1] + w[i][j] &lt;= dp[i][j - 1]) dp[i][j] = dp[i][j - 1]; else &#123; dp[i][j] = dp[i - 1][j - 1] + w[i][j]; vis[i][j] = 1; &#125; &#125; &#125; printf(\"%d\\n\", dp[n][m]); printPath(n, m); printf(\"\\n\"); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"[IOI 1994]北京2008的挂钟","slug":"IOI-1994-北京2008的挂钟","date":"2017-07-30T03:17:39.000Z","updated":"2017-07-30T03:18:43.784Z","comments":true,"path":"2017/07/30/IOI-1994-北京2008的挂钟/","link":"","permalink":"http://yoursite.com/2017/07/30/IOI-1994-北京2008的挂钟/","excerpt":"题目地址 描述在$2008$北京奥运会雄伟的主会场的墙上，挂着如上图所示的$3 \\times 3$的九个挂钟（一开始指针即时针指向的位置请根据输入数据调整）。然而此次奥运会给与了大家一个机会，去用最少的移动操作改变上面的挂钟的时间全部为$12$点正（我们只考虑时针）。然而每一次操作并不是任意的，我们必须按照下面给出的列表对于挂钟进行改变。每一次操作我们给而且必须给指定的操作挂钟进行，每一个挂钟顺时针转动$90$度。","text":"题目地址 描述在$2008$北京奥运会雄伟的主会场的墙上，挂着如上图所示的$3 \\times 3$的九个挂钟（一开始指针即时针指向的位置请根据输入数据调整）。然而此次奥运会给与了大家一个机会，去用最少的移动操作改变上面的挂钟的时间全部为$12$点正（我们只考虑时针）。然而每一次操作并不是任意的，我们必须按照下面给出的列表对于挂钟进行改变。每一次操作我们给而且必须给指定的操作挂钟进行，每一个挂钟顺时针转动$90$度。 列表给出九种操作，如下： ABDE ABC BCEF ADG BDEFH CFI DEGH GHI EFHI 分析我们我们可以发现对于一个钟表它所需的操作次数为$0 \\sim 3$次，那么也就是说对于一个序列我们最多只会调用同一个序列$3$次。那么我们可以枚举每一次操作调用的序列，如果已经调用过$3$次这个序列则这个序列不会再调用。然后判断当前状态是否满足挂钟的时间全部为$12$点正，如果满足那么输出解，否则进入下一层搜索。然后每一次搜索的时候枚举这个操作进行了几次，并用一个$cnt$数组记录下来，这样就可以不重不漏的枚举到所有的情况。听说九重循环也可以水过去QAQ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// Created by ZJYelizaveta on 2017年07月29日 星期六 09时33分38秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int MOD = 4;int a[MAX_N];const int step[10][10] = &#123; &#123;1, 1, 0, 1, 1, 0, 0, 0, 0&#125;, &#123;1, 1, 1, 0, 0, 0, 0, 0, 0&#125;, &#123;0, 1, 1, 0, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 0, 1, 0, 0, 1, 0, 0&#125;, &#123;0, 1, 0, 1, 1, 1, 0, 1, 0&#125;, &#123;0, 0, 1, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 0, 1, 1, 0&#125;, &#123;0, 0, 0, 0, 0, 0, 1, 1, 1&#125;, &#123;0, 0, 0, 0, 1, 1, 0, 1, 1&#125;&#125;;int temp[MAX_N], cnt[MAX_N];void dfs(int depth) &#123; for (int i = 0; i &lt; 9; ++i) temp[i] = a[i];// for (int i = 0; i &lt; 9; ++i) printf(\"%d \", temp[i]); printf(\"\\n\"); for (int j = 0; j &lt; 9; ++j) &#123;//每个操作中对应的钟表1~9 for (int i = 0; i &lt; 9; ++i) &#123;//操作1~9 temp[j] = (temp[j] + step[i][j] * cnt[i]) % MOD; &#125; &#125;// for (int i = 0; i &lt; 9; ++i) printf(\"%d \", temp[i]); printf(\"\\n\"); bool flag = true; for (int i = 0; i &lt; 9; ++i) if (temp[i]) &#123;flag = false; break;&#125; if (flag) &#123; for (int i = 0; i &lt; 9; ++i) &#123; for (int j = 0; j &lt; cnt[i]; ++j) &#123; printf(\"%d \", i + 1); &#125; &#125; printf(\"\\n\"); return; &#125; if (depth == 9) return; for (int i = 0; i &lt; 4; ++i) &#123; cnt[depth] = i; dfs(depth + 1); &#125;&#125;int main()&#123; for (int i = 0; i &lt; 9; ++i) a[i] = readIn(); dfs(0); return 0;&#125;","categories":[],"tags":[{"name":"DFS及BFS","slug":"DFS及BFS","permalink":"http://yoursite.com/tags/DFS及BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"}]},{"title":"BZOJ 1233 [Usaco2009Open]干草堆tower","slug":"BZOJ-1233-Usaco2009Open-干草堆tower","date":"2017-07-24T11:45:35.000Z","updated":"2017-07-24T11:47:57.950Z","comments":true,"path":"2017/07/24/BZOJ-1233-Usaco2009Open-干草堆tower/","link":"","permalink":"http://yoursite.com/2017/07/24/BZOJ-1233-Usaco2009Open-干草堆tower/","excerpt":"题目地址 描述奶牛们讨厌黑暗。 为了调整牛棚顶的电灯的亮度，Bessie必须建一座干草堆使得她能够爬上去够到灯泡。一共有$N$大包的干草$(1 \\leq N \\leq 100000)$(从$1$到$N$编号)依靠传送带连续的传输进牛棚来。第$i$包干草有一个 宽度$W_{i}(1 \\leq w_{i} \\leq 10000)$。所有的干草包的厚度和高度都为$1$。","text":"题目地址 描述奶牛们讨厌黑暗。 为了调整牛棚顶的电灯的亮度，Bessie必须建一座干草堆使得她能够爬上去够到灯泡。一共有$N$大包的干草$(1 \\leq N \\leq 100000)$(从$1$到$N$编号)依靠传送带连续的传输进牛棚来。第$i$包干草有一个 宽度$W_{i}(1 \\leq w_{i} \\leq 10000)$。所有的干草包的厚度和高度都为$1$。 Bessie必须利用所有$N$包干草来建立起干草堆，并且按照他们进牛棚的顺序摆放。她可以相放多少包就放多少包来建立起tower的地基（当然是紧紧的放在一行中）。接下来他可以放置下一个草包放在之前一级的上方来建立新的一级。注意：每一级不能比下面的一级宽。她持续的这么放置，直到所有的草包都被安 置完成。她必须按顺序堆放，按照草包进入牛棚的顺序。说得更清楚一些：一旦她将一个草包放在第二级，她不能将接下来的草包放在地基上。Bessie的目标是建立起最高的草包堆。 分析这道题目很妙呀QAQ首先肯定可以写出一个$\\Theta (n^{3})$的DP，定义$dp[i, j]$为当前层的干草是由第$[i, j)$包堆得，那么就有转移$dp[i, j] = dpj - 1, k$ 这道题目有一个很妙的结论：在许多干草堆之中，如果有一堆干草堆最下面的一段干草宽度最短，那么这一堆干草堆最高。 刚开始不会做，上网看了一下题解，结果全是“转自zkw” QAQ，然后看得我一脸懵逼 在善良的学长学姐的教导下好像明白了怎么推导，其实并不复杂。有两种方案，第一种是最下面一段干草是最短的，第二种最下面一段干草不是最短的那么我们经过一系列贪心的调整，能够将第二种转化成为第一种，那么转化后第二种的高度要么增加要么不变，可以感性的理解一下 所以问题就从维护当前干草堆最高变成了维护当前干草的宽度最短。设$f[i]$为由$i \\sim n$堆成的干草堆中最底层最短的长度。$g[i]$为处于状态$f[i]$时的最高高度。 那么有转移： f[i] = min \\{sum[j - 1] - sum[i - 1] \\}(i < j \\leq n, f[j] \\leq sum[j - 1] - sum[i - 1]) \\\\ g[i] = g[j] + 1这样我们运用结论将$\\Theta (n^{3})$的DP成功降至$\\Theta (n^{2})$，可是$1 \\leq N \\leq 100000$，$\\Theta (n^{2})$好像也不行呢，至少也得$\\Theta (nlogn)$或者$\\Theta (n)$才行呢？ 然后打表观察[滑稽.jpg]，把转移条件移一下项f[j] \\leq sum[j - 1] - sum[i - 1] \\Rightarrow sum[i - 1] = sum[j - 1] - f[j]我们发现当存在两个决策点$j, k$且$j &lt; k , sum[k - 1] - f[k] \\leq sum[j - 1] - f[j]$的时候选择$k$显然没有选择$j$优，所以我们维护$sum[i - 1] - f[i]$的单调队列即可，那么时间复杂度降至$\\Theta (n)$。如叙述不清请指出QAQ 代码123456789101112131415161718192021222324252627282930313233343536373839404142//2017/06/12 14:25:03//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1233: [Usaco2009Open]干草堆tower#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int INF = 0x3f3f3f3f;const int MAX = 100000 + 3;int n;int w[MAX];int q[MAX], sum[MAX];int f[MAX], g[MAX];int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(); for(int i = 1; i &lt;= n; ++i) w[i] = readIn(); sum[0] = 0; for(int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + w[i]; int l = 1, r = 1; q[r] = n + 1; for(int i = n; i &gt;= 1; --i)&#123; while(l &lt; r &amp;&amp; sum[q[l + 1] - 1] - sum[i - 1] &gt;= f[q[l + 1]]) l++; f[i] = sum[q[l] - 1] - sum[i - 1]; g[i] = g[q[l]] + 1; while(l &lt; r &amp;&amp; f[i] - sum[i - 1] &lt; f[q[r]] - sum[q[r] - 1]) r--; q[++r] = i; &#125; printf(\"%d\\n\", g[1]); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/单调队列/"}]},{"title":"BZOJ 1001: [BeiJing2006]狼抓兔子","slug":"BZOJ-1001-BeiJing2006-狼抓兔子","date":"2017-07-24T02:15:14.000Z","updated":"2017-07-24T09:09:38.192Z","comments":true,"path":"2017/07/24/BZOJ-1001-BeiJing2006-狼抓兔子/","link":"","permalink":"http://yoursite.com/2017/07/24/BZOJ-1001-BeiJing2006-狼抓兔子/","excerpt":"题目地址 描述现在小朋友们最喜欢的“喜羊羊与灰太狼”，话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：左上角点为$(1,1)$，右下角点为$(N,M)$(上图中$N=3,M=4$)，有以下三种类型的道路： $(x,y) \\Leftrightarrow (x+1,y)$ $(x,y) \\Leftrightarrow (x,y+1)$ $(x,y) \\Leftrightarrow (x+1,y+1)$","text":"题目地址 描述现在小朋友们最喜欢的“喜羊羊与灰太狼”，话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：左上角点为$(1,1)$，右下角点为$(N,M)$(上图中$N=3,M=4$)，有以下三种类型的道路： $(x,y) \\Leftrightarrow (x+1,y)$ $(x,y) \\Leftrightarrow (x,y+1)$ $(x,y) \\Leftrightarrow (x+1,y+1)$ 道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。 左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角$(1,1)$的窝里，现在它们要跑到右下角$(N,M)$的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为$K$，狼王需要安排同样数量的$K$只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。$(1 \\leq N, M \\leq 1000)$ 分析算法一：最小割转最大流菜啊，现在才做这道题目。首先看这道题目首先可以想到最小割，以前一直以为一定要转化为对偶图然后做最短路，后来发现把最小割转化为最大流写一发Dinic再加一点优化就可以卡过去了QAQ然后时间复杂度为$\\Theta(m \\cdot n^{2} + 3m \\cdot n)$，如果时间复杂度错了，请在评论中指出蟹蟹QAQ然后一定要注意这是一个无向图啊QAQ 算法二：平面图最小割转对偶图最短路附参考资料地址：浅析最大最小定理在信息学竞赛中的应用简单解释一下： 首先根据定义我们知道这是一个s-t平面图 而根据平面图的性质：每个平面图$G$都有一个与其对偶的平面图$G’$ $G’$中的每个点对应$G$中的一个面 对于$G$中的每条边$e$，$e$属于两个面$f_{1’},f_{2’}$，加入边$(f_{1}, f_{2})$；$e$只属于一个面$f$，加入回边$(f’,f’)$。 对于平面图$G$与其对偶图$G’$存在如下的关系： $G$的面数等于$G’$的点数，$G’$的点数等于$G$的面数，$G$与$G’$边数相同 $G’$中的环对应$G$中的割一一对应。 如图， 我们进一步发现，如果我们令每条边的长度等于它的容量，那么最小割的容量就等于最短路的长度，也就是说求原图s-t图的最小割等于求其对偶图的最短路，那么我们可以在$\\Theta (mn)$内求出答案QAQ，是这个时间复杂度吧（SPFA的复杂度玄学） 那么样例中的如我们可以表示为这样：值得注意的是这道题目比较良心在于他已经给出了这道题目的样子所以我们可以直接在原来s-t图上建立出他的对偶图，当然如果有的题目中没有给出图的样子那么就先要找出原图中的所有面并标号，然后建图（还没有见过类似的题目QAQ） 代码 算法一这是一个无向图呀QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// BZOJ 1001 [BeiJing2006]狼抓兔子// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.// 网络流#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt;'0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000000 + 3;const int MAX_M = 6000000 + 3;const int INF = 0x3f3f3f3f;int n, m, s, t;namespace Dinic &#123; struct Edge &#123; int to, next, cap; &#125;edge[MAX_M]; int head[MAX_N], cnt = 0; int iter[MAX_N], level[MAX_N]; inline void addEdge(int from, int to, int cap) &#123; edge[++cnt].to = to; edge[cnt].cap = cap; edge[cnt].next = head[from]; head[from] = cnt; edge[++cnt].to = from; edge[cnt].cap = cap; edge[cnt].next = head[to]; head[to] = cnt; &#125; bool bfs() &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = edge[i].next) &#123; if (edge[i].cap &amp;&amp; level[edge[i].to] == -1) &#123; level[edge[i].to] = level[u] + 1; q.push(edge[i].to); &#125; &#125; &#125; return level[t] != -1; &#125; int dfs(int u, int flow) &#123; if (u == t) return flow; int used = 0; for (int i = head[u]; i &amp;&amp; flow &gt; used; i = edge[i].next) &#123;// Edge &amp;e = G[u][i]; if (edge[i].cap &amp;&amp; level[edge[i].to] == level[u] + 1) &#123; int d = dfs(edge[i].to, min(flow - used, edge[i].cap));// printf(\"%d\\n\", d); used += d; edge[i].cap -= d; edge[i^1].cap += d; &#125; &#125; if (!used) level[u] = -1; return used; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int flow = 0, d = 0; while (bfs()) &#123;// memset(iter, 0, sizeof iter); while (d = dfs(s, INT_MAX), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;int main()&#123; n = readIn(), m = readIn(); s = 1, t = n * m;// printf(\"%d %d\\n\", s, t); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; m; ++j) &#123; int w = readIn();// printf(\"%d %d %d\\n\", (i - 1) * m + j, (i - 1) * m + j + 1, w); addEdge((i - 1) * m + j, (i - 1) * m + j + 1, w); &#125; &#125; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; int w = readIn();// printf(\"%d %d %d\\n\", (i - 1) * m + j, i * m + j, w); addEdge((i - 1) * m + j, i * m + j, w); &#125; &#125; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt; m; ++j) &#123; int w = readIn();// printf(\"%d %d %d\\n\", (i - 1) * m + j, i * m + j + 1, w); addEdge((i - 1) * m + j, i * m + j + 1, w); &#125; &#125; printf(\"%d\\n\", maxFlow(s, t)); return 0;&#125; 算法二当$i = 1 || i == m || j == 1 || j == m$的时候特判一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// BZOJ 1001 [BeiJing2006]狼抓兔子// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.// 对偶图 + 最短路#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 2000000 + 3;const int MAX_M = 8000000 + 3;const int INF = 0x3f3f3f3f;int n, m, s, t;namespace SPFA &#123; struct Edge &#123; int to, next, w; &#125;edge[MAX_M]; int head[MAX_N], cnt = 0; typedef pair&lt;int, int&gt; P; int dis[MAX_N]; bool inq[MAX_N]; inline void addEdge(int from, int to, int cost) &#123; edge[++cnt].to = to; edge[cnt].w = cost; edge[cnt].next = head[from]; head[from] = cnt; edge[++cnt].to = from; edge[cnt].w = cost; edge[cnt].next = head[to]; head[to] = cnt; &#125; void spfa() &#123; memset(dis, INF, sizeof dis); memset(inq, 0, sizeof inq); deque&lt;int&gt; q; q.push_front(s), dis[s] = 0, inq[s] = true; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = false; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (dis[v] &gt; dis[u] + edge[i].w) &#123; dis[v] = dis[u] + edge[i].w; if (!inq[u]) &#123; inq[v] = true; if (q.empty() || dis[v] &gt; dis[q.front()]) q.push_back(v); else q.push_front(v); &#125; &#125; &#125; &#125; &#125;&#125;using namespace SPFA;int main()&#123; n = readIn(), m = readIn(); s = 0, t = (((n - 1) * (m - 1)) &lt;&lt; 1) + 1;// printf(\"%d %d %d %d\\n\", n, m, s, t); memset(head, -1, sizeof head); for (register int i = 1; i &lt;= n; ++i) &#123; for (register int j = 1; j &lt; m; ++j) &#123; int w = readIn(); if (i == 1) addEdge(j &lt;&lt; 1, t, w); //printf(\"%d %d %d\\n\", j &lt;&lt; 1, t, w); else if (i == n) addEdge((((n - 2) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1) - 1, s, w); //printf(\"%d %d %d\\n\", (((n - 2) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1) - 1, s, w); else addEdge((((i - 2) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1) - 1, (((i - 1) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1), w);// printf(\"%d %d %d\\n\", (((i - 2) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1) - 1, (((i - 1) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1), w); &#125; &#125; for (register int i = 1; i &lt; n; ++i) &#123; for (register int j = 1; j &lt;= m; ++j) &#123; int w = readIn(); if (j == 1) addEdge(s, (((i - 1) * (m - 1)) &lt;&lt; 1) + 1, w); //printf(\"%d %d %d\\n\", s, (((i - 1) * (m - 1)) &lt;&lt; 1) + 1, w); else if (j == m) addEdge(t, (i * (m - 1)) &lt;&lt; 1, w); //printf(\"%d %d %d\\n\", t, (i * (m - 1)) &lt;&lt; 1, w); else addEdge((((i - 1) * (m - 1)) &lt;&lt; 1) + ((j - 1) &lt;&lt; 1), (((i - 1) * (m - 1)) &lt;&lt; 1) + ((j - 1) &lt;&lt; 1) + 1, w); //printf(\"%d %d %d\\n\", (((i - 1) * (m - 1)) &lt;&lt; 1) + ((j - 1) &lt;&lt; 1), (((i - 1) * (m - 1)) &lt;&lt; 1) + ((j - 1) &lt;&lt; 1) + 1, w); &#125; &#125; for (register int i = 1; i &lt; n; ++i) &#123; for (register int j = 1; j &lt; m; ++j) &#123; int w = readIn(); addEdge((((i - 1) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1) - 1, (((i - 1) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1), w); //printf(\"%d %d %d\\n\", (((i - 1) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1) - 1, (((i - 1) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1), w); &#125; &#125; spfa();// for (int i = s; i &lt;= t; ++i) printf(\"%d\\n\", dist[i]); printf(\"%d\\n\", dis[t]); return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"http://yoursite.com/tags/最大流/"},{"name":"对偶图","slug":"对偶图","permalink":"http://yoursite.com/tags/对偶图/"}]},{"title":"「雅礼集训 2017 Day2」C","slug":"「雅礼集训-2017-Day2」C","date":"2017-07-05T14:34:30.000Z","updated":"2017-07-05T14:57:15.681Z","comments":true,"path":"2017/07/05/「雅礼集训-2017-Day2」C/","link":"","permalink":"http://yoursite.com/2017/07/05/「雅礼集训-2017-Day2」C/","excerpt":"一如既往没有题目地址0w0 描述有一棵$n$个结点的树，对于点$i(i &gt; 1)$，它的父亲结点编号为$\\left \\lfloor \\frac{i}{2} \\right \\rfloor$。现在有$m$只鸟，每只鸟有初始位置$p_{i}$。树上每个结点有最大容量$c_{i}$，表示这个结点最多能容纳的鸟的数量。定义移动一只鸟的代价为树上的距离。现在询问，对于$k$从$1 \\sim m$，将前$k$只鸟移动位置使得满足每个结点上的鸟的个数不大于最大容纳量的最小代价。","text":"一如既往没有题目地址0w0 描述有一棵$n$个结点的树，对于点$i(i &gt; 1)$，它的父亲结点编号为$\\left \\lfloor \\frac{i}{2} \\right \\rfloor$。现在有$m$只鸟，每只鸟有初始位置$p_{i}$。树上每个结点有最大容量$c_{i}$，表示这个结点最多能容纳的鸟的数量。定义移动一只鸟的代价为树上的距离。现在询问，对于$k$从$1 \\sim m$，将前$k$只鸟移动位置使得满足每个结点上的鸟的个数不大于最大容纳量的最小代价。 从$0 \\sim 1$个数据：$n, m \\leq 7$从$2 \\sim 7$个数据：$n, m \\leq 100 \\times i$，其中$i$标书数据编号从$8$个数据：只有一个$c_{i} &gt; 0$从$9 \\sim 10$个数据：只有两个$c_{i} &gt; 0$从$11$个数据：$p_{i}$只有一种取值从$12 \\sim 13$个数据：$p_{i}$只有两种取值从$14 \\sim 19$个数据：$n, m \\leq 3 \\times 10^{5}$ 分析大神们都说是一眼费用流，好吧QAQ 前8个数据点大概估计一下直接见图跑费用流大概可过前$8$个数据点，那么怎么建图呢？ 首先建立超级源点$s，$以及超级汇点$t$。 将每一个点，连接汇点$t$，将点上的容量转化为边上的容量，那么每一个点到汇点$t$的边上的容量相当于这个点的容量，为费用为$0$。 对于树上的每一条边建立双向边，每条边的容量为$INF$费用为$1$。 那么对于初始条件存在鸟的结点，将这些节点连向超级源点$s$，其中每一条边上的容量为$1$，费用为$0$。 至此我们就建好图了，那么接下来从源点到汇点跑一边费用流就可以啦！跑费用流的时候要限制让鸟根据编号顺序一只一只的跑，如果存在鸟$1$没有跑而鸟$2$跑了费用流，那么这时候会存在负环。 进阶满分第一次听说手动增广[新奇.jpg]直接跑费用流的话虽然可以跑过前$8$个点，但是后面的测试点好像会T飞QAQ 因为问题中要求“将前$k$只鸟移动位置使得满足每个结点上的鸟的个数不大于最大容纳量的最小代价”，也就是说我们求费用流的过程相当于到达当前容量不为$0$的点的最短路，那么也就是说我们的增广路径一定是在最短路上的。 因为这是一棵二叉树，所以高度只有$\\Theta (logn)$。如果用SPFA跑费用流的找最短路的话在$\\Theta(nm)$可以找到，而利用这是一棵二叉树的特性则可以在$\\Theta (logn)$内找到最短路。 所以我们就先在$\\Theta (logn)$的时间复杂度内找到最短路，再模拟费用流的增广过程即可。 每跑玩一次费用流之后在上一次的残量网络上，再按最短路增广是正确的。（我不会证明呀，哪个大佬能教我一下QAQ）手动模拟费用流，新加入一只鸟，就从它的初始位置开始，找一条最短路增广。也就是找一个容量大于$0$，且距离当前鸟所在的结点最近的结点。如果走向和边上的流向相同，或边上的流为 $0$，费用为 $+1$； 否则，费用为 $-1$。学习了一下Sengxian学长的代码，表示好妙呀QAQ 代码 前8个数据点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// Created by ZJYelizaveta on Tuesday, July 04, 2017 PM04:34:04 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int INF = 0x3f3f3f3f;int n, m, s, t;int sum[MAX_N], cost;namespace MCMF&#123; struct Edge&#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N]; int dist[MAX_N], flow[MAX_N]; int prevE[MAX_N], prevV[MAX_N]; bool inq[MAX_N]; inline void addEdge(int from, int to, int cap, int cost)&#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; bool minCostMaxFlow(int s, int t)&#123; memset(dist, INF, sizeof dist); memset(inq, false, sizeof inq); queue&lt;int&gt; q; q.push(s), inq[s] = true, dist[s] = 0, flow[s] = INF; while(!q.empty())&#123; int u = q.front(); q.pop(); if(u == t) continue; inq[u] = false; for(int i = 0; i &lt; (int)G[u].size(); ++i)&#123; Edge &amp;e = G[u][i]; if(e.cap &amp;&amp; dist[e.to] &gt; dist[u] + e.cost)&#123; if(e.to == s) continue; dist[e.to] = dist[u] + e.cost; prevV[e.to] = u; prevE[e.to] = i; flow[e.to] = min(flow[u], e.cap); if(!inq[e.to]) q.push(e.to), inq[e.to] = true; &#125; &#125; &#125; if(dist[t] == INF) return false; for(int i = t; i != s; i = prevV[i])&#123; Edge &amp; e = G[prevV[i]][prevE[i]]; e.cap -= flow[t]; G[e.to][e.rev].cap += flow[t]; &#125; cost += flow[t] * dist[t]; return true; &#125;&#125;using namespace MCMF;int main()&#123; n = readIn(), m = readIn();// printf(\"%d %d\\n\", n, m);// return 0; s = n + 1, t = n + 2; for(int i = 1; i &lt;= n * 4; ++i)G[i].clear(); for(int i = 1; i &lt;= n; ++i)&#123; int c = readIn(); addEdge(i, t, c, 0); &#125; for(int i = 1; i &lt;= n; ++i)&#123; addEdge(i, i &gt;&gt; 1, INF, 1); addEdge(i &gt;&gt; 1, i, INF, 1); &#125; for(int i = 1; i &lt;= m; ++i)&#123; int pos = readIn(); addEdge(s, pos, 1, 0); while(minCostMaxFlow(s, t)) sum[i] = cost; &#125; for(int i = 1; i &lt;= m; ++i) printf(\"%d%c\", sum[i], i + 1 == m + 1 ? '\\n' : ' '); return 0;&#125; 对于$100 \\%$的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// Created by ZJYelizaveta on Wednesday, July 05, 2017 PM02:56:43 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 300000 + 3;const int INF = 0x3f3f3f3f;int n, m;int cap[MAX_N], pos[MAX_N];int dist[MAX_N], idx[MAX_N], flow[MAX_N];int ans;#define ls ((o) &lt;&lt; 1)#define rs (((o) &lt;&lt; 1) + 1)inline void update(int o)&#123; if(cap[o]) dist[o] = 0, idx[o] = o; else dist[o] = INF, idx[o] = 0; if(ls &lt;= n &amp;&amp; dist[o] &gt; dist[ls] + (flow[ls] &gt; 0 ? -1 : 1))&#123; dist[o] = dist[ls] + (flow[ls] &gt; 0 ? -1 : 1); idx[o] = idx[ls]; &#125; if(rs &lt;= n &amp;&amp; dist[o] &gt; dist[rs] + (flow[rs] &gt; 0 ? -1 : 1))&#123; dist[o] = dist[rs] + (flow[rs] &gt; 0 ? -1 : 1); idx[o] = idx[rs]; &#125;&#125;int main()&#123;#ifdef DEBUG freopen(\"C00.in\", \"r\", stdin);// freopen(\"test.out\", \"w\", stdout);#endif n = readIn(), m = readIn(); for(int i = 1; i &lt;= n; ++i) cap[i] = readIn(); for(int i = n; i &gt;= 1; --i) update(i); for(int i = 1; i &lt;= m; ++i) pos[i] = readIn(); ans = 0; for(int i = 1; i &lt;= m; ++i)&#123; int u = pos[i], now = 0, d = INF, id = 0; while(1)&#123; if(d &gt; now + dist[u])&#123; d = now + dist[u]; id = u; &#125; if (u == 1) break; now += (flow[u] &gt;= 0 ? 1 : -1); u &gt;&gt;= 1; &#125; ans += d, --cap[idx[id]];//记录最短路终止的结点编号，终点容量-- //LCA分别从最短路的终点和起点开始往上跳并更新，跳到LCA之后再一起跳到根并更新 for(int v = idx[id]; v != id; v &gt;&gt;= 1) flow[v]--, update(v); for(int v = pos[i]; v != id; v &gt;&gt;= 1) flow[v]++, update(v); for(int v = id; v != 1; v &gt;&gt;= 1) update(v); update(1); printf(\"%d%c\", ans, i + 1 == m + 1 ? '\\n' : ' '); &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/费用流/"}]},{"title":"「雅礼集训 2017 Day2」B","slug":"「雅礼集训-2017-Day2」B","date":"2017-07-04T10:56:17.000Z","updated":"2017-07-05T14:52:20.434Z","comments":true,"path":"2017/07/04/「雅礼集训-2017-Day2」B/","link":"","permalink":"http://yoursite.com/2017/07/04/「雅礼集训-2017-Day2」B/","excerpt":"当然还是没有题目地址呀QAQ我太弱了，表示这道题目想了很久才想明白题解中的方法呀，真的很巧妙呀QAQ；在chrt学姐的帮助下终于明白了，大概这次写的有点多，中间可能有描述不恰当和错误的地方，欢迎捉虫QAQSkipher和Sengxian学长写的十一个很妙的做法，好像还可以扩展到有$3$个$1$的情况，但是我好像忘了是怎么推的了[绝望.jpg]考试的时候写了一个$\\Theta(n^{2})$的DP，然后水了70分 描述考虑一个$n \\times n$的$01$矩阵，计算出所有满足每一行和每一列$1$的个数都是$2$的矩阵个数。设对于$n$的答案为$f_{n}$，你需要输出$\\sum_{i = 1}^{n}f_{i}$，答案对$998244353$取模。","text":"当然还是没有题目地址呀QAQ我太弱了，表示这道题目想了很久才想明白题解中的方法呀，真的很巧妙呀QAQ；在chrt学姐的帮助下终于明白了，大概这次写的有点多，中间可能有描述不恰当和错误的地方，欢迎捉虫QAQSkipher和Sengxian学长写的十一个很妙的做法，好像还可以扩展到有$3$个$1$的情况，但是我好像忘了是怎么推的了[绝望.jpg]考试的时候写了一个$\\Theta(n^{2})$的DP，然后水了70分 描述考虑一个$n \\times n$的$01$矩阵，计算出所有满足每一行和每一列$1$的个数都是$2$的矩阵个数。设对于$n$的答案为$f_{n}$，你需要输出$\\sum_{i = 1}^{n}f_{i}$，答案对$998244353$取模。 对于$10 \\%$的数据，满足：$n \\leq 7$对于$20 \\%$的数据，满足：$n \\leq 50$对于$30 \\%$的数据，满足：$n \\leq 150$对于$40 \\%$的数据，满足：$n \\leq 500$对于$70 \\%$的数据，满足：$n \\leq 10000$对于$100 \\%$的数据，满足：$n \\leq 10^{7}$ 分析对于$70 \\%$的数据看数据范围就知道大概要写一个DP，Orz坐我旁边的大爷DP的思路大概是这样的：我们定义$dp[i][j]$为还剩$i$列没有填过$1$，$j$列只填了一个$1$。那么我们有转移方程 dp[0][0] = 1 \\\\ dp[i][j] = \\binom{2}{i} \\cdot dp[i - 2][j + 2] + i \\cdot j \\cdot dp[i - 1][j] + \\binom{2}{j}dp[i][j - 2]这三种转移都是在一行中选两个，其实可以用滚动数组来滚动一下。 $\\binom{2}{i} \\cdot dp[i - 2][j + 2]$表示在$i$个没有填过$1$的列中选两个，然后$i$少了两个$j$多了两个 $i \\cdot j \\cdot dp[i - 1][j]$表示在$i$个没用的列中选一个，在$j$个填过一个$1$的列中选一个，那么$i$减少了一个$j$增加了一个又减少了一个没变 $\\binom{2}{j}dp[i][j - 2]$相当于在$j$个填过一个$1$的列中选两个，所以$j$少了两个而$i$没有变 因为这是一个自上而下的DP，而$dp[i][0]$表示的是”目前到达这个状态,把它填完的方案数”，而不是”到达这个状态的方案数”，所以最后答案可表示为： ans = \\sum_{i = 1}^{n}dp[i][0]对于$100 \\%$的数据其实这道题目的本质大概就是OEIS A001499题解中满分的思路大概是这样的：题解中是这样描述的将同一行和同一列之间的$1$连边，那么我们将$01$矩阵转化为一个二分图，如图所示：转化为二分图之后，考虑一个左边和右边各有$n$个点的二分图，如上图的合法方案中，左边和右边的任意两点之间有边，也就是说原题的合法方案相当于这个二分图中的多重完美最大匹配，那么也就是说原题中的答案转化成为了求二分图中多重完美最大匹配的数量。而这个多重完美最大匹配长什么样呢？ 是一堆分离的环。 于是我们枚举$1$号点所在的环的大小，删掉这个环，然后我们得到了一个更小的二分图，就这样我们得到了比原问题更小的子问题，然后建立递推关系: 我们令$f_{n}$为在$n \\times n$的矩阵中满足题目条件的方案数，因为最后是要计算所有方案的和，与其最后在相加一遍，不如现在直接计入答案中，那么，我们有递推式： f_{n} = \\sum_{i = 2}^{n}A_{i} \\cdot \\binom{i}{n}\\binom{n - 1}{i - 1} \\cdot f_{n - i}这个递推式怎么来理解呢QAQ，大概是这样的：我们把二分图中一个大小为$2i$的环分为几部分来看待：$1$号点 + 左边剩下的$(i - 1)$个点 + 右边的$i$个点。所以选出一个环有$\\binom{i}{n}\\cdot \\binom{n - 1}{i - 1} $种方法；那么$A_{n}$是什么呢，就是这个环的连边方法。那么到此为左边和右边都只剩下$(n - i)$个点了，那么这就是一个子问题$f_{n - i}$。把它们乘起来那么我们就得到了$1$号点所在的环的大小为$2i$的所有方案数了。 $A_{n}$是这个环的连边方法，我们可以把这个问题等价为：对于一个$n \\times n$的矩阵中有且仅有一个环的方案数我们称之为$A_{n}$，那么有: A_{n} = \\frac{n! \\times (n - 1)!}{2}这一部分其实比较好理解，就是先将每一行每一列放置一个$1$的方案数为$n!$，令$p_{i}$为第$i$行所在的$1$所在的列编号，那么在$p_{1}$列放的第二个$1$的方案数就为$n - 1$；令$p_{1}$列第二个$1$所在的行编号为$q_{i}$，那么在$p_{q_{i}}$列放置第$2$个$1$的方案数为$n - 2$，然后$n - 3 \\cdots$。可以自己换画一个$4 \\times 4$的图意会一下，因为这个过程被计算了两次（逆过程也被计算了一次），所以最后除以$2$。 仅仅有递推式也是很难得到满分的，$n = 10^{7}$意味着我们最好在$\\Theta(n)$的时间复杂度中算出来，$\\Theta(nlogn)$一样会超时，那么我们对式子进行如下的变换： \\because A_{n} = \\frac{n! \\times (n - 1)!}{2} \\\\ \\begin{equation}\\begin{split} f_{n} & = \\sum_{i = 2}^{n} \\frac{i! \\cdot (i - 1)!}{2} \\binom{i}{n}\\binom{n - 1}{i - 1} \\cdot f_{n - i}\\\\ & = \\sum_{i = 2}^{n} \\frac{i! \\cdot (i - 1)!}{2} \\frac{n!}{i! \\cdot (n - i)!} \\frac{(n - 1)!}{(i - 1)! \\cdot (n - i)!}\\cdot f_{n - i}\\\\ & = \\sum_{i = 2}^{n} \\frac{1}{2} \\cdot \\frac{n! \\cdot (n - 1)!}{(n - i)! \\cdot (n - i)!} \\cdot f_{n - i}\\\\ & = \\frac{n! \\cdot (n - 1)!}{2} \\sum_{i = 2}^{n} \\frac{1}{((n - i)!)^{2}} \\cdot f_{n - i} \\end{split}\\end{equation}现在等式两边同时除以$(n!)^{2}$，那么有： \\frac{f_{n}}{(n!)^{2}} = \\frac{1}{2n}\\sum_{i = 2}^{n} \\frac{1}{((n - i)!)^{2}} \\cdot f_{n - i}令$g_{n} = \\frac{f_{n}}{(n!)^{2}}$，那么$f_{n} = g_{n} \\cdot (n!)^{2}$，所以原式变为： g_{n} = \\frac{1}{2n} \\sum_{i = 2}^{n}g_{n - i}那么我们现在只需要处理出逆元然后维护$g_{n}$的前缀和，线性扫一遍就可以了，时间复杂度$\\Theta(n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//「雅礼集训 2017 Day2」B//2017/7/4#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000000 + 3;const int MOD = 998244353;const int INF = 0x3f3f3f3f;int n;ll fac[MAX_N], inv[MAX_N];//阶层，阶层的逆元ll ans;inline ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if(b == 0) &#123;x = 1, y = 0;&#125; else&#123; exgcd(b, a % b, y, x); y -= (a / b) * x; &#125;&#125;inline ll calculate(ll a, ll b)&#123;//计算逆元 ll x = 0, y = 0; exgcd(a, b, x, y); return (x % b + b) % b;&#125;inline void prepare()&#123;// printf(\"%d\\n\", n); fac[0] = 1; for(int i = 1; i &lt;= n; ++i) fac[i] = (ll)fac[i - 1] * i % MOD;// for(int i = 1; i &lt;= n; ++i) printf(\"f[%d] = %lld\\n\", i, fac[i]); inv[n] =calculate(fac[n], MOD);// printf(\"%lld\\n\", inv[n]); for(int i = n - 1; i &gt;= 0; --i) inv[i] = (ll)inv[i + 1] * (i + 1) % MOD;// for(int i = 1; i &lt;= n; ++i) printf(\"inv[%d] = %lld\\n\", i, inv[i]);&#125;int main()&#123; n = readIn();// printf(\"%d\\n\", n); prepare(); ans = 0; ll preg = 1, lastg = 0, divided = calculate(2, MOD); for(int i = 2; i &lt;= n; ++i)&#123; ll tmpg = (ll)preg * divided % MOD * inv[i] % MOD * fac[i -1] % MOD; (ans += (ll)tmpg * fac[i] % MOD * fac[i] % MOD) %= MOD; (preg += lastg) %= MOD; lastg = tmpg; &#125; printf(\"%lld\\n\", (ans % MOD + MOD) % MOD); return 0;&#125; 参考chrt学姐的博客一如既往的很赞呀","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"},{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"},{"name":"逆元","slug":"逆元","permalink":"http://yoursite.com/tags/逆元/"}]},{"title":"常系数线性齐次递推关系学习笔记","slug":"常系数线性齐次递推关系学习笔记","date":"2017-07-02T14:12:19.000Z","updated":"2017-07-03T03:39:29.486Z","comments":true,"path":"2017/07/02/常系数线性齐次递推关系学习笔记/","link":"","permalink":"http://yoursite.com/2017/07/02/常系数线性齐次递推关系学习笔记/","excerpt":"初中的班主任好像生病了，本来准备和同学一起去看望老师，但是好像去不了QAQ真的很想见一见初中的同学，好想他们呀QAQ 阅读这篇文章你所需要的前置技能大概有：基础的线性代数，以及看懂渣叙述的深厚语文功底QAQ可能有表述不清或者错误的地方，欢迎指正！","text":"初中的班主任好像生病了，本来准备和同学一起去看望老师，但是好像去不了QAQ真的很想见一见初中的同学，好想他们呀QAQ 阅读这篇文章你所需要的前置技能大概有：基础的线性代数，以及看懂渣叙述的深厚语文功底QAQ可能有表述不清或者错误的地方，欢迎指正！ 定义$h_{1}, h_{2}, \\cdots , h_{n}, \\cdots $是一个数列，称这个数列满足k阶线性递推关系是指存在量$a_{1}, a_{2}, \\cdots , a_{k}(a_{k} \\neq 0)$和量$b_{n}$(这些量$a_{1}, a_{2}, \\cdots a_{k}, b_{n}$可能依赖于$n$)，使得h_{n} = a_{1}h_{n - 1} + a_{2}h_{n - 2} + \\cdots + a_{k}h_{n - k} + b_{n}(n \\geq k) 例如斐波那契数列，就是一个典型的满足2阶递推关系的递推式。 如同栗子中所示，我们称线性递推关系是齐次的，如果$b_{n}$是常数0；而我们称它是常系数的，如果量$a_{1}, a_{2}, \\cdots , a_{k}$是常数，形如：h_{n} = a_{1}h_{n - 1} + a_{2}h_{n - 2} + \\cdots + a_{k}h_{n - k}(n \\geq k) 求解我们求解常系数线性齐次递推关系要依赖于是否能找到与$h_{n}$相关的某个多项式方程的根。其实求解常系数线性齐次递推关系和微分方程求解的方法极其相似。我们求解常系数线性齐次递推关系需要依赖一下几个定理。 定理1定义设$q$是一个非$0$的数，则$h_{n} = q^{n}$是下面常系数线性齐次递推关系$h_{n} = a_{1}h_{n - 1} + a_{2}h_{n - 2} + \\cdots + a_{k}h_{n - k}(n \\geq k, a_{k} \\neq 0)$的解，当且仅当$q$是下面这个多项式方程$x^{k} - a_{1}x^{k - 1} - a_{2}x^{k - 2} - \\cdots - a_{k} = 0$的根。 证明如果$h_{n} = q^{n}$是下面常系数线性齐次递推关系$h_{n} = a_{1}h_{n - 1} + a_{2}h_{n - 2} + \\cdots + a_{k}h_{n - k}(n \\geq k, a_{k} \\neq 0)$的解，那么我们将$h_{n} = q^{n}$带入以上常系数线性递推关系，可以得到 q^{n} - a_{1}q^{n - 1} - a_{2}q^{n - 2} - \\cdots - a_{k}q^{n - k} = 0若对于所有$n \\geq k$，$q^{n} - a_{1}q^{n - 1} - a_{2}q^{n - 2} - \\cdots - a_{k}q^{n - k} = 0$都有解（$q$有解），则$h_{n} = q^{n}$为常系数线性齐次递推关系的解。 假设$q \\neq 0$，我们可以将等式两边同时消去$q^{n - k}$，因此对于每一个$n \\geq k$都有一个的方程最后都会化为： q^{k} - a_{1}q^{k - 1} - a_{2}q^{k - 2} - \\cdots - a_{k} = 0那我们现在得出了结论若要得出$h_{n} = q^{n}$为递推式的解，当且仅当$q$为多项式方程的解。 现在只需证明$q$为多项式方程的根即可。因为假设$a_{k} \\neq 0$，所以$0$不是多项式方程的根。因此，一定存在$k$个不等于$0$的根$q_{1}, q_{2}, \\cdots , q_{k}$（这些根可以是复数，我也不知道为什么QAQ）。现在假设这$k$个根互不相同，那么h_{n} = q_{1}^{n}, h_{2} = q_{2}^{n}, \\cdots , h_{k} = q_{k}^{n}为递推式$k$个不同的解。而递推关系的线性性和齐次性意味着对于任意选定的常数$c_{1}, c_{2}, \\cdots, c_{k}$存在，h_{n} = c_{1}q_{1}^{n} + c_{2}q_{2}^{n} + \\cdots + c_{k}q_{k}^{n}使得其也为常系数齐次线性递推式的解。 定理2定义若多项式方程存在$k$个不同的根$q_{1}, q_{2}, \\cdots, q_{k}$，则$h_{n} = c_{1}q_{1}^{n} + c_{2}q_{2}^{n} + \\cdots + c_{k}q_{k}^{n}$在下述意义下是$h_{n} = a_{1}h_{n - 1} + a_{2}h_{n - 2} + \\cdots + a_{k}h_{n - k}(n \\geq k, a_{k} \\neq 0)$的通解：无论给定怎样的初始值$h_{0}, h_{1}, \\cdots, h_{k - 1}$，都存在常数$c_{1}, c_{2}, \\cdots, c_{k}$，使得$h_{n} = c_{1}q_{1}^{n} + c_{2}q_{2}^{n} + \\cdots + c_{k}q_{k}^{n}$是满足$h_{n} = a_{1}h_{n - 1} + a_{2}h_{n - 2} + \\cdots + a_{k}h_{n - k}(n \\geq k, a_{k} \\neq 0)$和初始条件的唯一数列。 证明好了定理1证明完了，那么现在只需要证明$h_{n} = c_{1}q_{1}^{n} + c_{2}q_{2}^{n} + \\cdots + c_{k}q_{k}^{n}$在下述意义下是$h_{n} = a_{1}h_{n - 1} + a_{2}h_{n - 2} + \\cdots + a_{k}h_{n - k}(n \\geq k, a_{k} \\neq 0)$的通解。 我们假设指定初始值： h_{0} = b_{0}, h_{1} = b_{1}， \\cdots, h_{k - 1} = b_{k - 1}我们是否能都选出常数$c_{1}, c_{2}, \\cdots, c_{k}$（$c$在这里相当于未知数）使得$h_{n} = c_{1}q_{1}^{n} + c_{2}q_{2}^{n} + \\cdots + c_{k}q_{k}^{n}$中的$h_{n}$满足上述初始条件，等价于，无论选择怎样的$b_{0}, b_{1}, \\cdots , b_{k - 1}$使得下列方程组有解： 我们把方程的系数矩阵表示出来是这样的： \\begin{bmatrix} 1 & 1 & \\cdots & 1\\\\ q_{1} & q_{2} & \\cdots & q_{k}\\\\ q_{1}^{2} & q_{2}^{2} & \\cdots & q_{k}^{2}\\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ q_{1}^{k - 1} & q_{2}^{k - 1} & \\cdots & q_{k}^{k - 1} \\end{bmatrix}觉不觉得这个矩阵很熟悉，对呀，不就是范德蒙矩阵吗QWQ，而范德蒙矩阵的行列式可表示为（这个就不证明啦）\\prod_{1 \\leq i < j \\leq k}(q_{j} - q_{i})当且仅当$q_{1}, q_{2}, \\cdots, q_{k}$两两之间互不相同的时候，系数矩阵才不为$0$。而系数矩阵才不为$0$，这也意味着方程组对于$b_{0}, b_{1}, \\cdots, b_{k - 1}$的每一种选择都有唯一解（方程有唯一解（克莱姆法则））。如果想进一步了解的话可以看n阶行列式 应用有常系数线性齐次递推式如下，求递推关系 首先我们可以得出递推式的特征方程： x^{3} - 2x^{2} - x + 2 = 0解得： x_{1} = -1, x_{2} = 1, x_{3} = 2因此h_{n} = c_{1}(-1)^{n} + c_{2}1^{n} + c_{3}2^{n}为常系数线性齐次递推关系的通解。 现在只需要求出常系数$c_{1}, c_{2}, c_{3}$使得方程组成立即可： 解得: c_{1} = -\\frac{2}{3}, c_{2} = 2, c_{3} = -\\frac{1}{3}因此， h_{n} = -\\frac{2}{3}\\cdot (-1)^{n} + 2 - \\frac{1}{3}\\cdot 2^{n}为原常系数线性齐次递推式的解，相当于原递推式的封闭形式。 参考资料 《组合数学》 原书第5版 P142","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"},{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"}]},{"title":"BZOJ 1575: [Usaco2009 Jan]气象牛Baric","slug":"BZOJ-1575-Usaco2009-Jan-气象牛Baric","date":"2017-06-29T13:11:43.000Z","updated":"2017-06-29T15:16:10.435Z","comments":true,"path":"2017/06/29/BZOJ-1575-Usaco2009-Jan-气象牛Baric/","link":"","permalink":"http://yoursite.com/2017/06/29/BZOJ-1575-Usaco2009-Jan-气象牛Baric/","excerpt":"题目地址 描述为了研究农场的气候，Betsy帮助农夫John做了$N(1 \\leq N \\leq 100)$次气压测量并按顺序记录了结果$M_{1} \\cdots M_{N}(1 \\leq M_{i} \\leq 1,000,000)$，Betsy想找出一部分测量结果来总结整天的气压分布，她想用$K(1 \\leq K \\leq N)$个数$s_{j} (1 \\leq s_{1} &lt; s_{2} &lt; \\cdots &lt; s_{K} \\leq N)$来概括所有测量结果。她想限制如下的误差： 对于任何测量结果子集，每一个非此子集中的结果都会产生误差，总误差是所有测量结果的误差之和。更明确第说,对于每一个和所有$s_{j}$都不同的$i$： 如果 $i$ 小于 $s_{1}$, 误差是: $2 \\times | M_{i} - M_{s_{1}} |$ 如果$i$在$s_{j}$和$s_{j+1}$之间，误差是: $| 2 \\times M_{i} - Sum(s_{j}, s_{j+1}) |$ $\\cdots$ $Sum(x, y) = M_{x} + M_{y}$；$(M_{x} 和 M_{y} 之和)$ 如果$i$大于$s_{K}$，误差为: $2 \\times | M_{i} - M_{s_{K}} |$ Besty给了最大允许的误差$E (1 \\leq E \\leq 1,000,000)$，找出最小的一部分结果使得误差最多为$E$。","text":"题目地址 描述为了研究农场的气候，Betsy帮助农夫John做了$N(1 \\leq N \\leq 100)$次气压测量并按顺序记录了结果$M_{1} \\cdots M_{N}(1 \\leq M_{i} \\leq 1,000,000)$，Betsy想找出一部分测量结果来总结整天的气压分布，她想用$K(1 \\leq K \\leq N)$个数$s_{j} (1 \\leq s_{1} &lt; s_{2} &lt; \\cdots &lt; s_{K} \\leq N)$来概括所有测量结果。她想限制如下的误差： 对于任何测量结果子集，每一个非此子集中的结果都会产生误差，总误差是所有测量结果的误差之和。更明确第说,对于每一个和所有$s_{j}$都不同的$i$： 如果 $i$ 小于 $s_{1}$, 误差是: $2 \\times | M_{i} - M_{s_{1}} |$ 如果$i$在$s_{j}$和$s_{j+1}$之间，误差是: $| 2 \\times M_{i} - Sum(s_{j}, s_{j+1}) |$ $\\cdots$ $Sum(x, y) = M_{x} + M_{y}$；$(M_{x} 和 M_{y} 之和)$ 如果$i$大于$s_{K}$，误差为: $2 \\times | M_{i} - M_{s_{K}} |$ Besty给了最大允许的误差$E (1 \\leq E \\leq 1,000,000)$，找出最小的一部分结果使得误差最多为$E$。 分析比较平常的动态规划首先我们需要预处理出所有测量结果的误差，用一个二维数组$w[i][j]$存储，这是显然的$dp$的状态定义为$dp[i][j]$为选第$i$个数，当前(在前i个数中)一共选取了$j$个数的最小误差。我们可以得出一个跟背包差不多的$\\Theta(n^{3})$的转移方程，具体见代码预处理$\\Theta(n^{3})$，转移$\\Theta(n^{3})$，但是因为$n$比较小，所以还是能够水过去的QAQ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//2017/06/14 15:55:59//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1575: [Usaco2009 Jan]气象牛Baric#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int INF = 0x3f3f3f3f;const int MAX_N = 100 + 3;const int MAX_M = 1000000 + 3;int n, e;int m[MAX_N];ll w[MAX_N][MAX_N], dp[MAX_N][MAX_N];inline void prepare()&#123; memset(w, 0, sizeof w); for(int i = 0; i &lt;= n + 1; ++i)&#123; for(int j = i + 1; j &lt;= n + 1; ++j)&#123; for(int k = i + 1; k &lt;= j - 1; ++k)&#123; if(i == 0) w[i][j] = w[i][j] + 2 * abs(m[j] - m[k]);// else if(j == n + 1) w[i][j] = w[i][j] + 2 * abs(m[k] - m[i]); else w[i][j] = w[i][j] + abs(2 * m[k] - m[i] - m[j]); &#125; &#125; &#125;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(), e = readIn(); for(int i = 1; i &lt;= n; ++i) m[i] = readIn(); m[0] = m[n + 1] = 0; prepare(); memset(dp, INF, sizeof dp); w[0][n + 1] = INF, dp[0][1] = 0; for(int i = 1; i &lt;= n + 1; ++i)&#123; for(int j = 1; j &lt;= i + 1; ++j)&#123; for(int k = 0; k &lt; i; ++k)&#123; if((j - 1) &lt;= k + 1) dp[i][j] = min(dp[i][j], dp[k][j - 1] + w[k][i]); &#125; &#125; &#125; for(int i = 1; i &lt;= n + 2; ++i)&#123; if(dp[n + 1][i] &lt;= (ll)e)&#123; printf(\"%d %lld\\n\", i - 2, dp[n + 1][i]); return 0; &#125; &#125; /* for(int i = 0; i &lt;= n + 1; ++i)&#123; for(int j = 0; j &lt;= n + 1; ++j)&#123; printf(\"%lld \", dp[i][j]); &#125; printf(\"\\n\"); &#125; */ return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"「雅礼集训 2017 Day1」say","slug":"「雅礼集训 2017 Day1」say","date":"2017-06-17T16:11:21.000Z","updated":"2017-07-04T11:06:55.997Z","comments":true,"path":"2017/06/18/「雅礼集训 2017 Day1」say/","link":"","permalink":"http://yoursite.com/2017/06/18/「雅礼集训 2017 Day1」say/","excerpt":"题目地址，可能不会放上来啦！前言，这几天集训，蒟蒻表示被虐的[生无可恋.jpg]，不过认识到了自己的许多不足和需要努力的地方，至少不像以前对自己的处境毫无头绪；认识了一些很厉害的人，Orz 人生赢家xch，以及我那个超级厉害的室友，还有学长们；每天都是坐看学长和学姐们AK，然后很努力的点亮技能树，期望不被虐QAQ也许会陆陆续续的把博客补上吧，这几天还是学到了挺多东西的 描述 “What’s left to say when every word’s been spoken?”“若沉默再无休止，是否已经话无可说？”","text":"题目地址，可能不会放上来啦！前言，这几天集训，蒟蒻表示被虐的[生无可恋.jpg]，不过认识到了自己的许多不足和需要努力的地方，至少不像以前对自己的处境毫无头绪；认识了一些很厉害的人，Orz 人生赢家xch，以及我那个超级厉害的室友，还有学长们；每天都是坐看学长和学姐们AK，然后很努力的点亮技能树，期望不被虐QAQ也许会陆陆续续的把博客补上吧，这几天还是学到了挺多东西的 描述 “What’s left to say when every word’s been spoken?”“若沉默再无休止，是否已经话无可说？” 沉默之中，我已不懂言语。幻觉之中，有人在轻声低吟。我听见，那人说了$n$句话，好多话都是重复或类似的，每句话是由若干个小写字母组成的字符串。字符串$A$和$B$的相似度定义如下：字符串$A$通过以下三种操作： 插入一个字符 删除一个字符 替换一个字符 从而使字符串$A$变换成字符串$B$的最少操作次数。 对于$10 \\%$的数据，$1 \\leq n \\leq 20$，$1 \\leq 每个字符串的长度 \\leq 12$对于$30 \\%$的数据，字符串的总长度$ \\leq 5000$对于$30 \\%$的数据，字符串的总长度$ \\leq 12000$对于$30 \\%$的数据，字符串的总长度$ \\leq 100000$对于另外$10 \\%$的数据，$1 \\leq n \\leq 70$对于$100 \\%$的数据，$1 \\leq n \\leq 200$， 字符串的总长度$\\leq 1000000$每个测试点时间$3s$，内存限制$512M$。 分析对于大部分人来说肯定能一眼AC，我比较蒻显然对于$30 \\% \\sim 40 \\%$的数据$\\Theta (n^{2})$的DP可以水过去，然而我还是太菜QAQ 现在考虑$100 \\%$的数据，我们考虑用LCS来跳过字符串中相同的位置，那么如何比较字符串是否相等呢？暴力比较显然是不可做的，以前做 BZOJ 2795: [Poi2012]A Horrible Poem 学长讲过用哈希的方法比较两个字符串，那么我们这里就用哈希就可以了。有一个优化就是，如果两个字符串一开始长度差异大于$8$那么这两个字符串显然对于答案是没有贡献的，所以我们可以不用管这样的情况，直接跳过就可以了。 我写哈希用的自然溢出，听说用unsigned int比用unsigned long long更快，但是出错率是unsigned long long的两倍？ 那个回来以后才发现好像MLE了QAQ，我以前是怎么AC的[迷茫.jpg]，改成了用$vector$存储虽然过了，但是好像有些慢。然后学习了一下Sengxian学长的代码，Sengxian学长是动态分配内存，果然代码从用$vector$改成了动态分配内存之后快了$2000ms$，Orz Sengxian学长。 代码 $vector$存储 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//「雅礼集训 2017 Day1」say//2017/6/29//hash + 二分 + dfs + LCS + vector处理不定长数组#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x;&#125;const int MAX_N = 200 + 3;const int MAX_LEN = 1000000 + 3;const int HASH_SIZE = 131;int n;char str[MAX_LEN];vector&lt;char&gt; S[MAX_N];vector&lt;ull&gt; hash[MAX_N];ull p[MAX_LEN];int len[MAX_N], ans[8 + 3];int cnt;void dfs(int a, int b, int cura, int curb, int step)&#123; if(step + abs(len[a] - cura - len[b] + curb) &gt;= cnt) return; else if(len[a] == cura)&#123; cnt = min(cnt, step + len[b] - curb); return; &#125; else if(len[b] == curb)&#123; cnt = min(cnt, step + len[a] - cura); return; &#125; if(S[a][cura] != S[b][curb])&#123; dfs(a, b, cura + 1, curb, step + 1); dfs(a, b, cura, curb + 1, step + 1); dfs(a, b, cura + 1, curb + 1, step + 1); &#125; else&#123; int l = 0, r = min(len[a] - cura, len[b] - curb); while(r - l &gt; 1)&#123; int mid = (l + r) &gt;&gt; 1; if(hash[a][cura + mid + 1] - hash[a][cura] * p[mid + 1] == hash[b][curb + mid + 1] - hash[b][curb] * p[mid + 1]) l = mid; else r = mid; &#125; dfs(a, b, cura + l + 1, curb + l + 1, step); &#125;&#125;int main()&#123;#ifndef DEBUG freopen(\"say0.in\", \"r\", stdin);#endif n = readIn(); //printf(\"%d\\n\", n); for(int i = 0; i &lt; n; ++i)&#123; scanf(\"%s\", str); //printf(\"%s\\n\", str); len[i] = strlen(str); for(int j = 0; j &lt; len[i]; ++j)&#123; S[i].push_back(str[j]); hash[i].push_back(S[i][0]); &#125; &#125; for(int i = 0; i &lt; n; ++i) for(int j = 1; j &lt; len[i]; ++j) hash[i][j] = hash[i][j - 1] * HASH_SIZE + S[i][j]; p[0] = 1; for(int i = 1; i &lt; MAX_LEN; ++i) p[i] = p[i - 1] * HASH_SIZE;// for(int i = 0; i &lt; n; ++i)&#123; for(int j = i + 1; j &lt; n; ++j)&#123; cnt = 9; if(abs(len[i] - len[j]) &gt;= cnt) continue; dfs(i, j, 0, 0, 0); if(cnt &lt;= 8) ++ans[cnt]; &#125; &#125; for(int i = 1; i &lt;= 8; ++i) printf(\"%d%c\", ans[i], i + 1 == 9 ? '\\n' : ' '); return 0;&#125; 动态分配内存 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//「雅礼集训 2017 Day1」say//2017/6/29//hash + 二分 + dfs + LCS + 动态分配内存#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int INF = 0x3f3f3f3f;const int MAX_N = 200 + 3;const int MAX_LEN = 1000000 + MAX_N + 3;const int HASH_SIZE = 131;int n;char poolStr[MAX_LEN], *pitStr = poolStr, *str[MAX_N];ull poolHash[MAX_LEN], *pitHash = poolHash, *hash[MAX_N];ull p[MAX_LEN];int len[MAX_N], ans[8 + 3];int cnt;inline bool check(int a, int cura, int b, int curb, int length)&#123; return hash[a][cura + length + 1] - hash[a][cura] * p[length + 1] == hash[b][curb + length + 1] - hash[b][curb] * p[length + 1];&#125;void dfs(int a, int b, int cura, int curb, int steps)&#123; if(steps + abs(len[a] - cura - len[b] + curb) &gt;= cnt) return; if(len[a] == cura)&#123; cnt = min(cnt, steps + len[b] - curb); return; &#125; if(len[b] == curb)&#123; cnt = min(cnt, steps + len[a] - cura); return; &#125; if(str[a][cura] != str[b][curb])&#123; dfs(a, b, cura + 1, curb + 1, steps + 1); dfs(a, b, cura + 1, curb, steps + 1); dfs(a, b, cura, curb + 1, steps + 1); &#125; else&#123; int l = 0, r = min((len[a] - cura), (len[b] - curb)); while(r - l &gt; 1)&#123; int mid = (l + r) &gt;&gt; 1; if(check(a, cura, b, curb, mid)) l = mid; else r = mid; &#125; dfs(a, b, cura + l + 1, curb + l + 1, steps); &#125;&#125;int main()&#123;#ifndef DEBUG freopen(\"say19.in\", \"r\", stdin);#endif n = readIn();// printf(\"%d\\n\", n); for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%s\", pitStr); str[i] = pitStr; len[i] = strlen(pitStr); pitStr += len[i] + 1; hash[i] = pitHash; pitHash += len[i] + 1; &#125; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; len[i]; ++j) hash[i][j + 1] = hash[i][j] * HASH_SIZE + str[i][j]; p[0] = 1; for(int i = 1; i &lt; MAX_LEN; ++i) p[i] = p[i - 1] * HASH_SIZE;// return 0; for(int i = 0; i &lt; n; ++i)&#123; for(int j = i + 1; j &lt; n; ++j)&#123; cnt = 9; if(abs(len[i] - len[j]) &gt;= cnt) continue; dfs(i, j, 0, 0, 0); if(cnt &lt;= 8) ++ans[cnt]; &#125; &#125;// return 0; for (int i = 1; i &lt;= 8; ++i) printf(\"%d%c\", ans[i], i + 1 == 9 ? '\\n' : ' '); return 0;&#125;","categories":[],"tags":[{"name":"DFS及BFS","slug":"DFS及BFS","permalink":"http://yoursite.com/tags/DFS及BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"LCS","slug":"LCS","permalink":"http://yoursite.com/tags/LCS/"},{"name":"哈希","slug":"哈希","permalink":"http://yoursite.com/tags/哈希/"}]},{"title":"BZOJ 2440: [中山市选2011]完全平方数","slug":"BZOJ-2440-中山市选2011-完全平方数","date":"2017-06-14T13:29:58.000Z","updated":"2017-06-14T13:36:39.809Z","comments":true,"path":"2017/06/14/BZOJ-2440-中山市选2011-完全平方数/","link":"","permalink":"http://yoursite.com/2017/06/14/BZOJ-2440-中山市选2011-完全平方数/","excerpt":"题目地址 描述小 X 自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。这天是小X的生日，小 W 想送一个数给他作为生日礼物。当然他不能送一个小X讨厌的数。他列出了所有小X不讨厌的数，然后选取了第$K$个数送给了小X。小X很开心地收下了。然而现在小 W 却记不起送给小X的是哪个数了。你能帮他一下吗？$T$为数据组数，对于100%的数据有 $1 \\leq K_{i} \\leq 10^{9},T \\leq 50$。","text":"题目地址 描述小 X 自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。这天是小X的生日，小 W 想送一个数给他作为生日礼物。当然他不能送一个小X讨厌的数。他列出了所有小X不讨厌的数，然后选取了第$K$个数送给了小X。小X很开心地收下了。然而现在小 W 却记不起送给小X的是哪个数了。你能帮他一下吗？$T$为数据组数，对于100%的数据有 $1 \\leq K_{i} \\leq 10^{9},T \\leq 50$。 分析看到这个的时候很容易想到二分$n$，计算区间$[1, n]$有多少个无平方因子的数。 如果我们要计算区间$[1, n]$有无平方因子的数的个数就要用到容斥原理。 很明显我们的答案可表示为\\begin{equation} \\begin{split} ans & = n - 含一个质因子的平方的数的个数 + 含两个质因子之积的平方的数的个数 - \\cdots\\\\ & = n + \\frac{n}{1 \\cdot 1} - \\frac{n}{2 \\cdot 2} - \\frac{n}{3 \\cdot 3} + \\frac{n}{4 \\cdot 4} - \\frac{n}{5 \\cdot 5} + \\frac{n}{6 \\cdot 6} + \\cdots\\end{split} \\end{equation}，然后我们会发现每一个数前面的符号其实对应的就是它的莫比乌斯函数的值。 综上所述，我们可以整理一个区间$[1, n]$答案为：ans = \\sum_{i = 1}^{n} \\mu{(i)} \\cdot \\frac{n}{i \\cdot i} 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//2017/06/14 11:31:39//Copyright (c) 2017年 ZJYelizavtea. All rights reserved.//BZOJ 2440: [中山市选2011]完全平方数#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 1000000 + 3;const int INF = 0x3f3f3f3f;int testCase;int K;int prime[MAX + 3], mu[MAX + 3];bool isNotPrime[MAX + 3];inline void seive()&#123; memset(isNotPrime, false, sizeof isNotPrime); int cnt = 0; isNotPrime[1] = true, mu[1] = 1; for(int i = 2; i &lt;= MAX; ++i)&#123; if(!isNotPrime[i])&#123; prime[++cnt] = i; mu[i] = -1; &#125; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= MAX; ++j)&#123; isNotPrime[i * prime[j]] = true; if(i % prime[j] == 0)&#123; mu[i * prime[j]] = 0; break; &#125; else mu[i * prime[j]] = -mu[i]; &#125; &#125; //for(int i = 1; i &lt;= 12; ++i) printf(\"%d \", mu[i]); printf(\"\\n\");&#125;bool check(int n)&#123; int ans = 0; for(int i = 1; i * i &lt;= n; ++i)&#123; ans += mu[i] * n / (i * i); &#125; if(ans &lt; K) return true; else return false;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif seive(); testCase = readIn(); while(testCase--)&#123; K = readIn(); ll l = 0, r = K * 2; while(r - l &gt; 1)&#123; ll mid = (l + r) &gt;&gt; 1; if(check(mid)) l = mid; else r = mid; &#125; printf(\"%lld\\n\", l + 1); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"莫比乌斯函数","slug":"莫比乌斯函数","permalink":"http://yoursite.com/tags/莫比乌斯函数/"}]},{"title":"BZOJ 1574: [Usaco2009 Jan]地震损坏Damage","slug":"BZOJ-1574-Usaco2009-Jan-地震损坏Damage","date":"2017-06-12T13:42:38.000Z","updated":"2017-06-12T13:44:13.660Z","comments":true,"path":"2017/06/12/BZOJ-1574-Usaco2009-Jan-地震损坏Damage/","link":"","permalink":"http://yoursite.com/2017/06/12/BZOJ-1574-Usaco2009-Jan-地震损坏Damage/","excerpt":"题目地址 描述农夫John的农场遭受了一场地震，有一些牛棚遭到了损坏，但幸运地，所有牛棚间的路径都还能使用。FJ的农场有$P(1 \\leq P \\leq 30,000)$个牛棚，编号$1 \\cdots P$； $C(1 \\leq C \\leq 100,000)$条双向路经联接这些牛棚，编号为$1 \\cdots C$，路经$i$连接牛棚$a_{i}$和$b_{i} (1 \\leq a_{i} \\leq P; 1 \\leq b_{i} \\leq P)$，路经可能连接$a_{i}$到它自己，两个牛棚之间可能有多条路径。农庄在编号为$1$的牛棚， $N (1 \\leq N \\leq P)$头在不同牛棚的牛通过手机短信$report_{j}(2 \\leq report_{j} \\leq P)$告诉FJ它们的牛棚$(report_{j})$没有损坏，但是它们无法通过路经和没有损坏的牛棚回到到农场。 当FJ接到所有短信之后，找出最小的不可能回到农庄的牛棚数目。这个数目包括损坏的牛棚。 注意:前50次提交将提供在一些测试数据上的运行结果。","text":"题目地址 描述农夫John的农场遭受了一场地震，有一些牛棚遭到了损坏，但幸运地，所有牛棚间的路径都还能使用。FJ的农场有$P(1 \\leq P \\leq 30,000)$个牛棚，编号$1 \\cdots P$； $C(1 \\leq C \\leq 100,000)$条双向路经联接这些牛棚，编号为$1 \\cdots C$，路经$i$连接牛棚$a_{i}$和$b_{i} (1 \\leq a_{i} \\leq P; 1 \\leq b_{i} \\leq P)$，路经可能连接$a_{i}$到它自己，两个牛棚之间可能有多条路径。农庄在编号为$1$的牛棚， $N (1 \\leq N \\leq P)$头在不同牛棚的牛通过手机短信$report_{j}(2 \\leq report_{j} \\leq P)$告诉FJ它们的牛棚$(report_{j})$没有损坏，但是它们无法通过路经和没有损坏的牛棚回到到农场。 当FJ接到所有短信之后，找出最小的不可能回到农庄的牛棚数目。这个数目包括损坏的牛棚。 注意:前50次提交将提供在一些测试数据上的运行结果。 分析DFS，题意描述的有点奇怪，一开始没有看懂。其实就是在保证损坏的牛棚与农庄（编号为$1$的牛棚）不联通的情况下，求出最小的不可能回到农庄的牛棚数目。 保证损坏的牛棚与农庄（编号为$1$的牛棚）不联通，那么我们可以先预处理吧所有与损坏的牛棚联通的点先删去。然后DFS一遍求出从农庄（编号为$1$的牛棚）能到达的最多的点的数量$cnt$，$ans = P - cnt$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//2017/06/12 11:24:07//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1574: [Usaco2009 Jan]地震损坏Damage#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 30000 + 3;int P, C, N;vector&lt;int&gt; G[MAX];bool vis[MAX], del[MAX];int ans;void dfs(int u)&#123; ans++; vis[u] = 1; for(unsigned int i = 0; i &lt; G[u].size(); ++i)&#123; if(!vis[G[u][i]] &amp;&amp; !del[G[u][i]]) dfs(G[u][i]); &#125;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif P = readIn(), C = readIn(), N = readIn(); for(int i = 0; i &lt; C; ++i)&#123; int u = readIn(), v = readIn(); u--; v--; G[u].push_back(v); G[v].push_back(u); &#125; memset(vis, 0, sizeof vis); memset(del, 0, sizeof del); for(int i = 0; i &lt; N; ++i)&#123; int x = readIn(); x--; for(unsigned int i = 0; i &lt; G[x].size(); ++i) del[G[x][i]] = true; &#125; dfs(0); printf(\"%d\\n\", P - ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"DFS及BFS","slug":"DFS及BFS","permalink":"http://yoursite.com/tags/DFS及BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"}]},{"title":"BZOJ 1572: [Usaco2009 Open]工作安排Job","slug":"BZOJ-1572-Usaco2009-Open-工作安排Job","date":"2017-06-11T16:11:21.000Z","updated":"2017-06-12T11:19:47.683Z","comments":true,"path":"2017/06/12/BZOJ-1572-Usaco2009-Open-工作安排Job/","link":"","permalink":"http://yoursite.com/2017/06/12/BZOJ-1572-Usaco2009-Open-工作安排Job/","excerpt":"题目地址 描述Farmer John 有太多的工作要做啊！为了让农场高效运转，他必须靠他的工作赚钱，每项工作花一个单位时间。他的工作日从$0$时刻开始，有$1000000000$个单位时间。在任一时刻，他都可以选择编号$1 \\sim N$的$N(1 \\leq N \\leq 100000)$项工作中的任意一项工作来完成。因为他在每个单位时间里只能做一个工作，而每项工作又有一个截止日期，所以他很难有时间完成所有$N$个工作，虽然还是有可能。 对于第i个工作，有一个截止时间$D_{i}(1 \\leq D_{i} \\leq 1000000000)$，如果他可以完成这个工作，那么他可以获利$P_{i}( 1 \\leq P_{i} \\leq 1000000000 )$。在给定的工作利润和截止时间下，FJ能够获得的利润最大为多少呢？答案可能会超过32位整型。","text":"题目地址 描述Farmer John 有太多的工作要做啊！为了让农场高效运转，他必须靠他的工作赚钱，每项工作花一个单位时间。他的工作日从$0$时刻开始，有$1000000000$个单位时间。在任一时刻，他都可以选择编号$1 \\sim N$的$N(1 \\leq N \\leq 100000)$项工作中的任意一项工作来完成。因为他在每个单位时间里只能做一个工作，而每项工作又有一个截止日期，所以他很难有时间完成所有$N$个工作，虽然还是有可能。 对于第i个工作，有一个截止时间$D_{i}(1 \\leq D_{i} \\leq 1000000000)$，如果他可以完成这个工作，那么他可以获利$P_{i}( 1 \\leq P_{i} \\leq 1000000000 )$。在给定的工作利润和截止时间下，FJ能够获得的利润最大为多少呢？答案可能会超过32位整型。 分析很典型的贪心题。 首先还是按照时间顺序排序，若时间相同按照利润的大小从小到大排序。 首先先加上所有的工作的利润，然后用按照从小到大排序的优先队列筛去同一时间但是利润不是最大的那个工作，最后就可以得到答案。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//2017/6/11 23:43//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1572 [Usaco2009 Open]工作安排Job#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; ll x = 0; int f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return (ll)x * f;&#125;const int MAX = 100000 + 3;int n;struct Work&#123; ll dl, p;//deadline, profits; bool operator &lt; (const Work &amp;rhs) const&#123; if(dl == rhs.dl) return p &lt; rhs.p;dl &lt; rhs.dl; return dl &lt; rhs.dl; &#125;&#125;work[MAX];priority_queue&lt; ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; q;//按照从小到大的顺序排序int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(); for(int i = 0; i &lt; n; ++i) &#123; work[i].dl = readIn(), work[i].p = readIn(); &#125; sort(work, work + n); ll ans = 0, sum = 0; for(int i = 0; i &lt; n; ++i)&#123; ans += work[i].p; sum++; q.push(work[i].p); if(sum &gt; work[i].dl)&#123; ans -= q.top(); q.pop(); sum--; &#125; &#125; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}]},{"title":"BZOJ 1571: [Usaco2009 Open]滑雪课Ski","slug":"BZOJ-1571-Usaco2009-Open-滑雪课Ski","date":"2017-06-11T12:57:17.000Z","updated":"2017-06-11T16:13:12.978Z","comments":true,"path":"2017/06/11/BZOJ-1571-Usaco2009-Open-滑雪课Ski/","link":"","permalink":"http://yoursite.com/2017/06/11/BZOJ-1571-Usaco2009-Open-滑雪课Ski/","excerpt":"题目地址 描述Farmer John 想要带着Bessie一起在科罗拉多州一起滑雪。很不幸，Bessie滑雪技术并不精湛。Bessie了解到，在滑雪场里，每天会提供$S(0 \\leq S \\leq 100)$门滑雪课。第$i$节课始于$M_{i}(1 \\leq M_{i} \\leq 10000)$，上的时间为$L_{i}(1 \\leq L_{i} \\leq 10000)$。上完第$i$节课后，Bessie的滑雪能力会变成$A_{i}(1 \\leq A_{i} \\leq 100)$。 注意：这个能力是绝对的，不是能力的增长值。Bessie买了一张地图，地图上显示了$N(1 \\leq N \\leq 10,000)$个可供滑雪的斜坡，从第$i$个斜坡的顶端滑至底部所需的时长$D_{i}(1 \\leq D_{i} \\leq 10000)$，以及每个斜坡所需要的滑雪能力$C_{i}(1\\leq C_{i} \\leq 100)$，以保证滑雪的安全性。Bessie的能力必须大于等于这个等级，以使得她能够安全滑下。Bessie可以用她的时间来滑雪，上课，或者美美地喝上一杯可可汁，但是她必须在$T(1 \\leq T \\leq 10000)$时刻离开滑雪场。这意味着她必须在$T$时刻之前完成最后一次滑雪。 求Bessie在实现内最多可以完成多少次滑雪。这一天开始的时候，她的滑雪能力为$1$。","text":"题目地址 描述Farmer John 想要带着Bessie一起在科罗拉多州一起滑雪。很不幸，Bessie滑雪技术并不精湛。Bessie了解到，在滑雪场里，每天会提供$S(0 \\leq S \\leq 100)$门滑雪课。第$i$节课始于$M_{i}(1 \\leq M_{i} \\leq 10000)$，上的时间为$L_{i}(1 \\leq L_{i} \\leq 10000)$。上完第$i$节课后，Bessie的滑雪能力会变成$A_{i}(1 \\leq A_{i} \\leq 100)$。 注意：这个能力是绝对的，不是能力的增长值。Bessie买了一张地图，地图上显示了$N(1 \\leq N \\leq 10,000)$个可供滑雪的斜坡，从第$i$个斜坡的顶端滑至底部所需的时长$D_{i}(1 \\leq D_{i} \\leq 10000)$，以及每个斜坡所需要的滑雪能力$C_{i}(1\\leq C_{i} \\leq 100)$，以保证滑雪的安全性。Bessie的能力必须大于等于这个等级，以使得她能够安全滑下。Bessie可以用她的时间来滑雪，上课，或者美美地喝上一杯可可汁，但是她必须在$T(1 \\leq T \\leq 10000)$时刻离开滑雪场。这意味着她必须在$T$时刻之前完成最后一次滑雪。 求Bessie在实现内最多可以完成多少次滑雪。这一天开始的时候，她的滑雪能力为$1$。 分析动态规划水题，看到的第一眼感觉和[Hnoi2017]大佬有一点像，不过相比简单多了。 定义状态：$dp[i][j]$为在$i$时刻，上第$j$堂课能够滑雪的最多次数。（也可以定义为在时刻$i$能力为$j$，能够滑雪最多的次数）一共有$3$种转移的状态： 美美地喝上一杯可可汁，$dp[i][j] = max(dp[i][j, dp[i - 1][j]) \\cdots (i \\neq 0)$ 上课，$dp[i + lst[j]][j] = max(dp[i + lst[j]][j], dp[i][k]) \\cdots (st[j] = i, k为满足st[j] = i的可供选择的课程编号)$ 滑雪，$dp[i + a[j]][j] = max(dp[i + a[j]][j], dp[i][j] + 1) \\cdots (i + a[j] \\leq T)$ 数组$a[]$中储存的是预处理出的在同一能力下能够在最短时间完成一次滑雪的时间，这是我们贪心的出来的显而易见的结论。 然后就是各种需要注意的小细节，然后，没有了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//2017/6/11 20:47//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1571 [Usaco2009 Open]滑雪课Ski#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int INF = 0x3f3f3f3f;const int MAX_S = 100 + 3;const int MAX_N = 10000 + 3;int T, S, N;int st[MAX_S], lst[MAX_S], abt[MAX_S];//start, last, abilityint cap[MAX_N], t[MAX_N];//capacity, timeint dp[MAX_N][MAX_S], minTime[MAX_S];int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif T = readIn(), S = readIn(), N = readIn(); //printf(\"%d %d %d\\n\", T, S, N); for(int i = 1; i &lt;= S; ++i) st[i] = readIn(), lst[i] = readIn(), abt[i] = readIn(); //sort(abt, abt + S) abt[0] = 1;// memset(minTime, INF, sizeof minTime);// for(int i = 1; i &lt;= N; ++i)&#123; cap[i] = readIn(), t[i] = readIn(); for(int j = 0; j &lt;= S; ++j)&#123; if(cap[i] &lt;= abt[j]) minTime[j] = min(minTime[j], t[i]); &#125; &#125; memset(dp, -INF, sizeof dp); dp[0][0] = 0, st[0] = -1; for(int i = 0; i &lt;= T; ++i)&#123; for(int j = 0; j &lt;= S; ++j)&#123; if(i != 0) dp[i][j] = max(dp[i][j], dp[i - 1][j]); if(i == st[j])&#123; for(int k = 0; k &lt;= S; ++k) dp[i + lst[j]][j] = max(dp[i + lst[j]][j], dp[i][k]); &#125; if(i + minTime[j] &lt;= T) dp[i + minTime[j]][j] = max(dp[i][j] + 1, dp[i + minTime[j]][j]); &#125; &#125; int ans = 0; for(int i = 0; i &lt;= S; ++i) ans = max(ans, dp[T][i]); printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}]},{"title":"UVa 10883 - Supermean","slug":"UVa-10883-Supermean","date":"2017-06-10T09:10:46.000Z","updated":"2017-06-10T11:42:37.208Z","comments":true,"path":"2017/06/10/UVa-10883-Supermean/","link":"","permalink":"http://yoursite.com/2017/06/10/UVa-10883-Supermean/","excerpt":"题目地址 描述给出$n(n \\leq 50000)$个数，每相邻两个数求平均数，将得到$n - 1$个数。对这$n - 1$个数每相邻两个数求平均数，将得到$n - 2$个数。以此类推，最后得到$1$个数，求这个数。","text":"题目地址 描述给出$n(n \\leq 50000)$个数，每相邻两个数求平均数，将得到$n - 1$个数。对这$n - 1$个数每相邻两个数求平均数，将得到$n - 2$个数。以此类推，最后得到$1$个数，求这个数。 分析刚拿到这道题目的时候一点头绪都没有，然后就用$a, b, c, d$模拟了一下发现了一些好玩的东西。对$a, b, c, d$进行描述中所说的操作：$ = \\frac{a + b}{2} + \\frac{b + c}{2} + \\frac{c + d}{2}$$ = \\frac{a + 2b + c}{2} + \\frac{b + 2c + d}{2}$$ = \\frac{a + 3b + 3c + d}{8}$如果还没有看出来，可以以$a, b, c, d, e, f$来模拟：$ = \\frac{a + b}{2} + \\frac{b + c}{2} + \\frac{c + d}{2} + \\frac{d + e}{2} + \\frac{e + f}{2}$$ = \\frac{a + 2b + c}{4} + \\frac{b + 2c + d}{4} + \\frac{c + 2d + e}{4} + \\frac{d + 2e + f}{4}$$ = \\frac{a + 3b + 3c + d}{8} + \\frac{b + 3c + 3d + e}{8} + \\frac{c + 3d + 3e + f}{8}$$ = \\frac{a + 4b + 6c + 4d + e}{16} + \\frac{b + 4c + 6d + 4e + f}{16}$$ = \\frac{a + 5b + 10c + 10d + 5e + f}{32}$很明显分子上$a, b, c, d$等的系数就是二项式展开的系数，而分母也有规律，那么我们要求的式子就是：($a[i]$为$n$个数）明显$n$太大了，预处理显然不可能，如果用组合数本身的定义$C_{n}^{m} = \\frac{n!}{m! \\cdot (n - m)!}$计算阶层的时候会溢出，那怎么办？我以前做过一道和这个有点类似的概率题UVa 1639 - Candy，里面是用取对数来解决的这里我们也可以这么做。这里我们用公式$C_{n}^{k + 1} = C_{n}^{k} \\cdot \\frac{n - k}{k + 1}$来递推更新组合数。$ln(ans) = \\sum_{i = 0}^{n - 1}\\frac{ln(C_{n - 1}^{i}) \\cdot ln(a[i])}{ln(2^{n - 1})}$ $ln(ans) = \\sum_{i = 0}^{n - 1}ln(C_{n - 1}^{i}) + ln(a[i]) - ln(2^{n - 1})$ 其中$(ln(C_{n - 1}^{i + 1}) = ln(C_{n - 1}^{i}) + (n - 1 - i) - (i + 1))$最后用$exp$函数还原即可。 代码1234567891011121314151617181920212223242526272829303132333435363738//2017/6/10 0:23//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//UVa 10883 - Supermean#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 50000 + 3;int testCase;int n;double a[MAX];int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif testCase = readIn(); for(int kase = 1; kase &lt;= testCase; ++kase)&#123; n = readIn(); double ans = 0.0, C = 0.0; for(int i = 0; i &lt; n; ++i)&#123; scanf(\"%lf\", &amp;a[i]); if(a[i] &gt; 0) ans += exp(log(a[i]) + C - (n - 1) * log(2)); if(a[i] &lt; 0) ans -= exp(log(-a[i]) + C - (n - 1) * log(2)); C = C + log(n - i - 1) - log(i + 1); &#125; printf(\"Case #%d: %.3lf\\n\", kase, ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"精度处理","slug":"精度处理","permalink":"http://yoursite.com/tags/精度处理/"},{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"}]},{"title":"BZOJ 1232: [Usaco2008Nov]安慰奶牛cheer","slug":"BZOJ-1232-Usaco2008Nov-安慰奶牛cheer","date":"2017-06-09T11:33:27.000Z","updated":"2017-06-09T11:40:24.158Z","comments":true,"path":"2017/06/09/BZOJ-1232-Usaco2008Nov-安慰奶牛cheer/","link":"","permalink":"http://yoursite.com/2017/06/09/BZOJ-1232-Usaco2008Nov-安慰奶牛cheer/","excerpt":"题目地址 描述Farmer John变得非常懒，他不想再继续维护供奶牛之间供通行的道路。 道路被用来连接$N (5 \\leq N \\leq 10,000)$个牧场，牧场被连续地编号为$1 \\cdots N$，每一个牧场都是一个奶牛的家。FJ计划除去$P(N-1 \\leq P \\leq 100,000)$条道路中尽可能多的道路，但是还要保持牧场之间的连通性。你首先要决定那些道路是需要保留的$N-1$条道路。 第$j$条双向道路连接了牧场$S_{j}$和$E_{j}$ $(1 \\leq S_{j} \\leq N; 1 \\leq E_{j} \\leq N; S_{j} != E_{j})$，而且走完它需要$L_{j} (0 \\leq L_{j} \\leq 1,000)$的时间， 没有两个牧场是被一条以上的道路所连接。奶牛们非常伤心， 因为她们的交通系统被削减了， 你需要到每一个奶牛的住处去安慰她们。 每次你到达第$i$个牧场的时候(即使你已经到过)，你必须花去$C_{i} (1 \\leq C_{i} \\leq 1,000)$的时间和奶牛交谈。你每个晚上都会在同一个牧场(这是供你选择的)过夜，直到奶牛们都从悲伤中缓过神来。在早上起来和晚上回去睡觉的时候，你都需要和在你睡觉的牧场的奶牛交谈一次，这样你才能完成你的交谈任务。假设FarmerJohn采纳了你的建议，请计算出使所有奶牛都被安慰的最少时间。 对于你前10次的提交，你的程序会在一部分正式的测试数据上运行， 并且返回运行的结果。","text":"题目地址 描述Farmer John变得非常懒，他不想再继续维护供奶牛之间供通行的道路。 道路被用来连接$N (5 \\leq N \\leq 10,000)$个牧场，牧场被连续地编号为$1 \\cdots N$，每一个牧场都是一个奶牛的家。FJ计划除去$P(N-1 \\leq P \\leq 100,000)$条道路中尽可能多的道路，但是还要保持牧场之间的连通性。你首先要决定那些道路是需要保留的$N-1$条道路。 第$j$条双向道路连接了牧场$S_{j}$和$E_{j}$ $(1 \\leq S_{j} \\leq N; 1 \\leq E_{j} \\leq N; S_{j} != E_{j})$，而且走完它需要$L_{j} (0 \\leq L_{j} \\leq 1,000)$的时间， 没有两个牧场是被一条以上的道路所连接。奶牛们非常伤心， 因为她们的交通系统被削减了， 你需要到每一个奶牛的住处去安慰她们。 每次你到达第$i$个牧场的时候(即使你已经到过)，你必须花去$C_{i} (1 \\leq C_{i} \\leq 1,000)$的时间和奶牛交谈。你每个晚上都会在同一个牧场(这是供你选择的)过夜，直到奶牛们都从悲伤中缓过神来。在早上起来和晚上回去睡觉的时候，你都需要和在你睡觉的牧场的奶牛交谈一次，这样你才能完成你的交谈任务。假设FarmerJohn采纳了你的建议，请计算出使所有奶牛都被安慰的最少时间。 对于你前10次的提交，你的程序会在一部分正式的测试数据上运行， 并且返回运行的结果。 分析表示题面具有一定的迷惑性。讲了一大段话其实真正的重点只有，在保证图的连通性的条件下求到每一个牧场的花费的总时间最少。这不就是最小生成树吗？不过在这道题目中的权值指的是2倍的边权和边的两个端点的权值之和。最后一定要选一个端点权值最小的点做为起点。做完Kruskal之后加上这个点的权值即为我们所求的答案 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//2017/06/09 16:54:15//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1232:[Usaco2008Nov]安慰奶牛cheer#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int MAX_M = 100000 + 3;int n, m;int a[MAX_N];int u[MAX_M], v[MAX_M], w[MAX_M];int rk[MAX_M], fa[MAX_M];inline bool cmp(int i, int j)&#123; return w[i] &lt; w[j];&#125;inline int find(int x)&#123; return fa[x] == x ? x : fa[x] = find(fa[x]);&#125;inline int Kruskal()&#123; int ans = 0; for(int i = 0; i &lt; n; ++i) fa[i] = i; for(int i = 0; i &lt; m; ++i) rk[i] = i; sort(rk, rk + m, cmp); for(int i = 0; i &lt; m; ++i)&#123; int e = rk[i]; int x = find(u[e]); int y = find(v[e]); if(x != y)&#123; ans += w[e]; fa[x] = y; &#125; &#125; return ans;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(), m = readIn(); for(int i = 0; i &lt; n; ++i) a[i] = readIn(); for(int i = 0; i &lt; m; ++i)&#123; u[i] = readIn(), v[i] = readIn(), w[i] = readIn(); u[i]--; v[i]--; w[i] = w[i] * 2 + a[u[i]] + a[v[i]]; &#125; sort(a, a + n); //for(int i = 0; i &lt; m; ++i) printf(\"%d \", w[i]); printf(\"%d\\n\", Kruskal() + a[0]); return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/最小生成树/"}]},{"title":"UVa 11174 - Stand in a Line","slug":"UVa-11174-Stand-in-a-Line","date":"2017-06-09T11:31:37.000Z","updated":"2017-06-09T11:32:52.783Z","comments":true,"path":"2017/06/09/UVa-11174-Stand-in-a-Line/","link":"","permalink":"http://yoursite.com/2017/06/09/UVa-11174-Stand-in-a-Line/","excerpt":"题目地址 描述村子里有$n(1 \\leq n \\leq 40000)$个人，有多少种方法可以把他们排成一列，是的没有人排在他父亲前面（有些人的父亲可能不在村子里）？输入$n$和每个人的编号及其父亲的编号，输出方案总数模$1000000000$的结果。","text":"题目地址 描述村子里有$n(1 \\leq n \\leq 40000)$个人，有多少种方法可以把他们排成一列，是的没有人排在他父亲前面（有些人的父亲可能不在村子里）？输入$n$和每个人的编号及其父亲的编号，输出方案总数模$1000000000$的结果。 分析村民由父子关系组织成了一个森林（森林：森林也可以看成是好多棵互不相连的非空的树），森林中可能有许多棵树，我们可以通过给森林添加一个虚拟结点从而将其转化成为树的形式，这样更方便我们求解，那么形象的表示就是这样的：考虑这棵有虚拟结点的数的排列方案数。 虚拟根下由3棵子树，每一棵子树都是相互独立的，给每一棵子树中的结点确定顺序，有$5 \\times 4 \\times 1$种方法。 再将所属同一棵子树中的结点当成相同的结点，那么接下来对三棵子树进行排列相当于对重复元素进行排列，而重复元素的全排列公式在这里运用表示为$\\frac {11!}{3! \\times 6! \\times 2!}$。 至此$ans = \\frac {11!}{3! \\times 6! \\times 2!} \\times 5 \\times 4 \\times 1 = 92400$ $f(i)$为以$i$为根的子树的方案数，$s(i)$为以$i$为根的子树的大小，$c_{j}$为结点$i$的第$j$个儿子。所以我们可以归纳出以结点$i$为根的子树有$f(i)$中排法：$f(i) = f(c_{1})f(c_{2}) \\cdots f(c_{k}) \\cdot \\frac {(s_{i} - 1)!} {s(c_{1})!s(c_{2})! \\cdots s(c_{k})!}$还可以进一步化简，对于不是根的结点$f(i) = \\frac{(s_{c_{i}} - 1)!} {s_{c_{i}}!} = \\frac {1}{s_{c_{i}}}$将其带入$ans = \\frac {(s(root) - 1)!} {s_{1} \\cdot s_{2} \\cdots s_{n}}(s(root) = n - 1)$，这一步的推导我并不是很确信，欢迎指谪。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//2017/06/09 09:13:17//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//UVa 11174 - Stand in a Line#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 40000 + 3;const int MOD = 1000000007;int testCase;int n, m;ll f[MAX];int fa[MAX], size[MAX];vector&lt;int&gt; G[MAX];inline void prepare() &#123; f[0] = 1; for(int i = 1; i &lt; MAX; ++i) f[i] = f[i - 1] * i % MOD;&#125;inline ll quickPow(ll a, ll b)&#123; ll res = 1; while(b)&#123; if(b &amp; 1) (res *= a) %= MOD; (a *= a) %= MOD; b &gt;&gt;= 1; &#125; return res;&#125;inline void dfs(int u)&#123; size[u] = 1; for(unsigned int i = 0; i &lt; G[u].size(); ++i)&#123; dfs(G[u][i]); size[u] += size[G[u][i]]; &#125;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif //printf(\"%lld\\n\", quickPow(2, 10)); prepare(); //for(int i = 1; i &lt; MAX; ++i) printf(\"%lld \", f[i]); testCase = readIn(); while(testCase--) &#123; n = readIn(), m = readIn(); memset(fa, 0, sizeof fa); memset(size, 0, sizeof size); for(int i = 0; i &lt;= n; ++i) G[i].clear(); for(int i = 0; i &lt; m; ++i) &#123; int u = readIn(), v = readIn(); G[v].push_back(u); fa[u] = v; &#125; for(int i = 1; i &lt;= n; ++i)&#123; if(!fa[i]) G[0].push_back(i); &#125; dfs(0); ll sum = 1; for(int i = 1; i &lt;= n; ++i) (sum *= size[i]) %= MOD; ll ans = (f[n] * quickPow(sum, MOD - 2)) % MOD; printf(\"%lld\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"}]},{"title":"BZOJ 1231: [Usaco2008 Nov]mixup2 混乱的奶牛","slug":"BZOJ-1231-Usaco2008-Nov-mixup2-混乱的奶牛","date":"2017-06-08T16:32:21.000Z","updated":"2017-06-08T17:12:05.651Z","comments":true,"path":"2017/06/09/BZOJ-1231-Usaco2008-Nov-mixup2-混乱的奶牛/","link":"","permalink":"http://yoursite.com/2017/06/09/BZOJ-1231-Usaco2008-Nov-mixup2-混乱的奶牛/","excerpt":"题目地址 描述混乱的奶牛 [Don Piele, 2007] Farmer John的$N(4 \\leq N \\leq 16)$头奶牛中的每一头都有一个唯一的编号$S_{i} (1 \\leq S_{i} \\leq 25,000)$。 奶牛为她们的编号感到骄傲， 所以每一头奶牛都把她的编号刻在一个金牌上， 并且把金牌挂在她们宽大的脖子上。 奶牛们对在挤奶的时候被排成一支“混乱”的队伍非常反感. 如果一个队伍里任意两头相邻的奶牛的编号相差超过$K (1 \\leq K \\leq 3400)$， 它就被称为是混乱的。比如说，当$N = 6, K = 1$时, $1, 3, 5, 2, 6, 4$ 就是一支“混乱”的队伍， 但是 $1, 3, 6, 5, 2, 4$ 不是(因为$5$和$6$只相差$1$)。那么，有多少种能够使奶牛排成”混乱”的队伍的方案呢？","text":"题目地址 描述混乱的奶牛 [Don Piele, 2007] Farmer John的$N(4 \\leq N \\leq 16)$头奶牛中的每一头都有一个唯一的编号$S_{i} (1 \\leq S_{i} \\leq 25,000)$。 奶牛为她们的编号感到骄傲， 所以每一头奶牛都把她的编号刻在一个金牌上， 并且把金牌挂在她们宽大的脖子上。 奶牛们对在挤奶的时候被排成一支“混乱”的队伍非常反感. 如果一个队伍里任意两头相邻的奶牛的编号相差超过$K (1 \\leq K \\leq 3400)$， 它就被称为是混乱的。比如说，当$N = 6, K = 1$时, $1, 3, 5, 2, 6, 4$ 就是一支“混乱”的队伍， 但是 $1, 3, 6, 5, 2, 4$ 不是(因为$5$和$6$只相差$1$)。那么，有多少种能够使奶牛排成”混乱”的队伍的方案呢？ 分析表示很久没有接触过动态规划了，今天做的时候竟没有想到是状压DP，表示实在是太弱了。首先看到$N(4 \\leq N \\leq 16)$是如此的小的时候就应该想到是状压DP，因为$N$很小的话可以用二进制来枚举每一头牛的编号的状态。记得我上次在最优配对的时候好像写过这样一句话： 其实我们从这道状压的基本题就可以看出状压DP实际上是将平面上离散的点压进二进制表示的集合中，有时候题目中不一定明确的说明它是离散的点，有时候可能是图的顶点，数轴上的坐标。 其实这道题目抽象来看每一头牛相当于一维数轴上离散的点，求每一个相邻的点之间差值大于$k$的方案数。 那么我们现在定义状态$dp[i][S]$为在已选的牛的集合$S$中最后一头牛是第$i$头牛的方案数。每一次枚举下一头牛选哪一头，每一头牛是否选择要依赖于前面那一头牛，如果当前下一头牛不在集合$S$中，且于前一头牛之间编号差值大于$k$则可以选。 所以我们有状态转移方程：$dp[j][S - \\{ j \\} ] += dp[i][S] (!(S \\&amp; (1 &lt;&lt; j)) \\&amp; \\&amp; abs(a[i] - a[j]) &gt; k)$ 最终的 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546//2017/6/8 22:39//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1231: [Usaco2008 Nov]mixup2 混乱的奶牛#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int INF = 0x3f3f3f3f;const int MAX = 16 + 3;int n, k;int a[MAX];ll dp[MAX][1 &lt;&lt; (MAX)];int main()&#123;#ifndef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(), k = readIn(); //printf(\"%d %d\\n\", n, k); for(int i = 0; i &lt; n; ++i) a[i] = readIn(); memset(dp, 0, sizeof dp); for(int i = 0; i &lt; n; ++i) dp[i][1 &lt;&lt; i] = 1; for(int S = 0; S &lt; (1 &lt;&lt; n); ++S)&#123; for(int i = 0; i &lt; n; ++i)&#123; if(S &amp; (1 &lt;&lt; i))&#123; for(int j = 0; j &lt; n; ++j)&#123; if(!(S &amp; (1 &lt;&lt; j)) &amp;&amp; abs(a[i] - a[j]) &gt; k) dp[j][S ^ (1 &lt;&lt; j)] += dp[i][S]; &#125; &#125; &#125; &#125; ll ans = 0; for(int i = 0; i &lt; n; ++i) ans += dp[i][(1 &lt;&lt; n) - 1]; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"状压DP","slug":"状压DP","permalink":"http://yoursite.com/tags/状压DP/"}]},{"title":"BZOJ 1230: [Usaco2008 Nov]lites 开关灯","slug":"BZOJ-1230-Usaco2008-Nov-lites-开关灯","date":"2017-06-08T09:07:39.000Z","updated":"2017-06-08T10:06:43.284Z","comments":true,"path":"2017/06/08/BZOJ-1230-Usaco2008-Nov-lites-开关灯/","link":"","permalink":"http://yoursite.com/2017/06/08/BZOJ-1230-Usaco2008-Nov-lites-开关灯/","excerpt":"题目地址 描述Farmer John尝试通过和奶牛们玩益智玩具来保持他的奶牛们思维敏捷， 其中一个大型玩具是牛栏中的灯。 $N (2 \\leq N \\leq 100,000)$ 头奶牛中的每一头被连续的编号为$1 \\cdots N$， 站在一个彩色的灯下面。刚到傍晚的时候, 所有的灯都是关闭的。 奶牛们通过N个按钮来控制灯的开关，按第$i$个按钮可以改变第$i$个灯的状态。奶牛们执行$M (1 \\leq M \\leq 100,000)$条指令，每个指令都是两个整数中的一个$(0 \\leq 指令号 \\leq 1)$。第$1$种指令(用$0$表示)包含两个数字$S_{i}$和$E_{i}$ $(1 \\leq S_{i} \\leq E_{i} &lt;= N)$，它们表示起始开关和终止开关，奶牛们只需要把从$S_{i}$到$E_{i}$之间的按钮都按一次，就可以完成这个指令。 第$2$种指令(用$1$表示)同样包含两个数字$S_{i}$和$E_{i}$ $(1 \\leq S_{i} \\leq E_{i} &lt;= N)$，不过这种指令是询问从$S_{i}$到$E_{i}$之间的灯有多少是亮着的。 帮助FJ确保他的奶牛们可以得到正确的答案.","text":"题目地址 描述Farmer John尝试通过和奶牛们玩益智玩具来保持他的奶牛们思维敏捷， 其中一个大型玩具是牛栏中的灯。 $N (2 \\leq N \\leq 100,000)$ 头奶牛中的每一头被连续的编号为$1 \\cdots N$， 站在一个彩色的灯下面。刚到傍晚的时候, 所有的灯都是关闭的。 奶牛们通过N个按钮来控制灯的开关，按第$i$个按钮可以改变第$i$个灯的状态。奶牛们执行$M (1 \\leq M \\leq 100,000)$条指令，每个指令都是两个整数中的一个$(0 \\leq 指令号 \\leq 1)$。第$1$种指令(用$0$表示)包含两个数字$S_{i}$和$E_{i}$ $(1 \\leq S_{i} \\leq E_{i} &lt;= N)$，它们表示起始开关和终止开关，奶牛们只需要把从$S_{i}$到$E_{i}$之间的按钮都按一次，就可以完成这个指令。 第$2$种指令(用$1$表示)同样包含两个数字$S_{i}$和$E_{i}$ $(1 \\leq S_{i} \\leq E_{i} &lt;= N)$，不过这种指令是询问从$S_{i}$到$E_{i}$之间的灯有多少是亮着的。 帮助FJ确保他的奶牛们可以得到正确的答案. 分析线段树区间异或。水题一枚，好高兴1A。我们令关灯为0，开灯为1。用线段树维护一段区间内1的个数，相当于区间求和。每次更新的时候用nodes[o].addV ^= 1就可以更新灯的当前状态了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//2017/6/8 12:25//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1230 [Usaco2008 Nov]lites 开关灯 线段树区间异或#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 100000 + 3;int n, m;namespace Segment_Tree&#123; const int MAXNODE = (1 &lt;&lt; 17) * 4; #define ls (((o) &lt;&lt; 1) + 1) #define rs (((o) &lt;&lt; 1) + 2) #define mid (((l) + (r)) &gt;&gt; 1) struct Node&#123; int addV, sum; &#125;nodes[MAXNODE]; inline void pushUp(int o)&#123; nodes[o].sum = nodes[ls].sum + nodes[rs].sum; &#125; inline void build(int o, int l, int r)&#123; nodes[o].addV = 0; if(r - l == 1) nodes[o].sum = 0; else&#123; build(ls, l, mid), build(rs, mid, r); pushUp(o); &#125; &#125; inline void giveTagAdd(int o, int l, int r, int v) &#123; nodes[o].sum = (r - l) - nodes[o].sum; nodes[o].addV ^= 1; &#125; inline void pushDown(int o, int l, int r)&#123; if(nodes[o].addV != 0)&#123; giveTagAdd(ls, l, mid, nodes[o].addV), giveTagAdd(rs, mid, r, nodes[o].addV); nodes[o].addV = 0; &#125; &#125; inline void modify(int o, int l, int r, int a, int b, int v) &#123; if(r &lt;= a || l &gt;= b) return; if(l &gt;= a &amp;&amp; r &lt;= b) &#123; nodes[o].addV ^= 1; nodes[o].sum = (r - l) - nodes[o].sum; return;&#125;// else&#123; pushDown(o, l, r); modify(ls, l, mid, a, b, v); modify(rs, mid, r, a, b, v); pushUp(o); &#125; &#125; inline int query(int o, int l, int r, int a, int b)&#123; if(b &lt;= l || a &gt;= r) return 0; if(a &lt;= l &amp;&amp; r &lt;= b) return nodes[o].sum; else&#123; pushDown(o, l, r); return query(ls, l, mid, a, b) + query(rs, mid, r, a, b); &#125; &#125;&#125;using namespace Segment_Tree;int main()&#123;#ifdef DBEUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(), m = readIn(); build(0, 0, n); while(m--)&#123; int opt = readIn(), l = readIn() - 1, r = readIn(); if(opt == 0)&#123; modify(0, 0, n, l, r, 1); &#125; else if(opt == 1)&#123; printf(\"%d\\n\", query(0, 0, n, l, r)); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"}]},{"title":"BZOJ 2480: [Spoj 3105] Mod","slug":"BZOJ-2480-Spoj-3105-Mod","date":"2017-06-05T14:28:54.000Z","updated":"2017-06-04T12:15:07.889Z","comments":true,"path":"2017/06/05/BZOJ-2480-Spoj-3105-Mod/","link":"","permalink":"http://yoursite.com/2017/06/05/BZOJ-2480-Spoj-3105-Mod/","excerpt":"题目地址 描述已知数$a,p,b$，求满足$a^{x} \\equiv b \\ (mod \\ p)$的最小自然数$x$，$1 \\leq a, n, p \\leq 10^{9}$。","text":"题目地址 描述已知数$a,p,b$，求满足$a^{x} \\equiv b \\ (mod \\ p)$的最小自然数$x$，$1 \\leq a, n, p \\leq 10^{9}$。 分析EXBSGS的模板题目，Mark一下。分析请见BSGS及EXBSGS后面数据添加的好像是$p = 1$的情况，这个时候$ans = 0$没商量。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//BZOJ 2480: Spoj3105 Mod//2017/06/01 11:26:48//离散对数 + 数学#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll readIn()&#123; ll x = 0; int f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar();&#125; return (ll)x * f;&#125;const int INF = 0x3f3f3f3f;map &lt;ll, ll&gt; Map;inline ll quickMod(ll a, ll b, ll n)&#123; //a ^ b % n ll res = 1; while(b)&#123; if(b &amp; 1) (res *= a) %= n; (a *= a) %= n; b &gt;&gt;= 1; &#125; return res;&#125;inline ll gcd(ll a, ll b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;inline void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) x = 1, y = 0; else &#123; exgcd(b, a % b, y, x); y -= (a / b) * x; &#125;&#125;inline ll inv(ll v, ll Mod) &#123; ll x = 0, y = 0; exgcd(v, Mod, x, y); return (x % Mod + Mod) % Mod;&#125;inline ll BSGS(ll a, ll b, ll n)&#123; ll e = 1; ll m = (int)(sqrt(n + 0.5));//ceil(sqrt(n)); ll v = inv(quickMod(a, m, n), n); //printf(\"%lld\\n\", m); //printf(\"%lld\\n\", quickMod(a, m, n)); //printf(\"%lld\\n\", v); Map[1] = 0; for(int i = 1; i &lt; m; ++i)&#123; (e *= a) %= n; if(!Map.count(e)) Map[e] = i; &#125; ll i; for(i = 0; i &lt; m; ++i)&#123; if(Map.count(b)) return i * m + Map[b]; (b *= v) %= n; &#125; return -1;&#125;inline void solve(ll a, ll b, ll n)&#123; ll e = 1; a %= n, b %= n; for(int i = 0; i &lt; 100; ++i)&#123; if(e == b)&#123; printf(\"%d\\n\", i); return; &#125; (e *= a) %= n; &#125; int sum = 0; while(gcd(a, n) != 1)&#123; ll factor = gcd(a, n); if(b % factor)&#123; printf(\"No Solution\\n\"); return; &#125; n /= factor, sum++, b /= factor; (b *= inv(a / factor, n)) %= n; &#125; ll ans = BSGS(a, b, n); if(ans == -1) &#123;printf(\"No Solution\\n\"); return;&#125; printf(\"%lld\\n\", ans + sum);&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif while(1)&#123; ll a = readIn(), p = readIn(), b = readIn(); //printf(\"%lld %lld %lld\\n\", a, p, b); if(a == 0 &amp;&amp; p == 0 &amp;&amp; b == 0) break; if(p == 1) &#123; printf(\"0\\n\"); continue;&#125; Map.clear(); solve(a, b, p); &#125; return 0;&#125;","categories":[],"tags":[{"name":"BSGS & EXBSGS","slug":"BSGS-EXBSGS","permalink":"http://yoursite.com/tags/BSGS-EXBSGS/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"离散对数","slug":"离散对数","permalink":"http://yoursite.com/tags/离散对数/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"}]},{"title":"BZOJ 2818: Gcd","slug":"BZOJ-2818-Gcd","date":"2017-06-05T09:08:50.000Z","updated":"2017-06-04T12:13:48.206Z","comments":true,"path":"2017/06/05/BZOJ-2818-Gcd/","link":"","permalink":"http://yoursite.com/2017/06/05/BZOJ-2818-Gcd/","excerpt":"题目地址 描述给定整数$N$，求$1 \\leq x,y \\leq N$且$Gcd(x,y)$为素数的数对$(x,y)$有多少对， $1 \\leq N \\leq 10^{7}$。","text":"题目地址 描述给定整数$N$，求$1 \\leq x,y \\leq N$且$Gcd(x,y)$为素数的数对$(x,y)$有多少对， $1 \\leq N \\leq 10^{7}$。 分析如果一开始找不到思路，可以举一两个例子看一下。如$gcd(x, y) = 2, gcd(x, y) = 3, gcd(x, y) = 5, gcd(x, y) = 7$把式子稍微变一下$gcd(x, \\frac{y}{2}) = 1, gcd(x, \\frac{y}{3}) = 1, gcd(x, \\frac{y}{5}) = 1, gcd(x, \\frac{y}{7}) = 1$咦，好想知道怎么做了$gcd(a, b) = 1 \\Leftrightarrow a, b$互质。 以$gcd(x, y) = 2$为例子：假设$x \\leq \\frac{y}{2}$，那么这部分对答案的贡献就是小于或等于$\\frac{y}{2}$的正整数中与$\\frac{y}{2}$互素的数的个数。若$x \\geq \\frac{y}{2}$部分对答案的贡献与$x \\leq \\frac{y}{2}$是一样的，但是$x = \\frac{y}{2}$这部分计算了两次，所以$gcd(x, y) = 2$对于答案的贡献为。 那么对于其他的质数的操作也是这样的，每一个$gcd(x,y) = d (d\\in \\mathbb{P}, d &lt; N)$对答案的贡献都是。 所以我们先可以处理$1\\sim n(1 \\leq n \\leq N)$的区间中每一部分的$phi[i]$的前缀和，并存入数组$sum[]$。最后在循环体中累加ans就可以了$ans = sum[\\frac{n}{prime[i]}] \\cdot 2 - 1$（$i$的循环范围为[$1$， 小于等于$n$的质数个数]）。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//BZOJ 2818: Gcd//2017/5/31 14:36//euler phi#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 10000000 + 3;int n;bool isPrime[MAX];int prime[MAX], cnt = 0;int phi[MAX];LL sum[MAX];void findPrime()&#123; memset(prime, 0, sizeof 0); memset(isPrime, true, sizeof isPrime); isPrime[0] = false, isPrime[1] = false; for(int i = 2; i &lt;= n; ++i)&#123; if(isPrime[i]) prime[++cnt] = i; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j)&#123; isPrime[i * prime[j]] = false; if(i % prime[j] == 0) break; &#125; &#125;&#125;void eulerTable(int n)&#123; for(int i = 2; i &lt;= n; i++) phi[i] = 0; phi[1] = 1; for(int i = 2; i &lt;= n; i++)&#123; if(!phi[i])&#123; for(int j = i; j &lt;= n; j += i)&#123; if(!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); &#125; &#125; &#125;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(); eulerTable(n); findPrime(); memset(sum, 0, sizeof sum); for(int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + phi[i]; LL ans = 0; for(int i = 1; i &lt;= cnt; ++i) ans += sum[n / prime[i]] * 2 - 1; printf(\"%lld\\n\", ans); //check(); //for(int i = 1; i &lt;= n; ++i) printf(\"%d %lld\\n\", i, sum[i]); return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://yoursite.com/tags/欧拉函数/"}]},{"title":"BSGS及EXBSGS","slug":"BSGS及EXBSGS","date":"2017-06-02T14:28:20.000Z","updated":"2017-06-03T16:20:07.024Z","comments":true,"path":"2017/06/02/BSGS及EXBSGS/","link":"","permalink":"http://yoursite.com/2017/06/02/BSGS及EXBSGS/","excerpt":"离散对数定义在初等代数中，如果$a^{x} = b$，就说$x = log{_{a}}^{b}$，即$x$是以$a$为底$b$的对数。在模运算中也有相似的概念，但比初等对数中的要稍微复杂一些。对于$a^{x}\\equiv b(mod \\ n)$，我们要分成以下几种情况来讨论： $n$为素数，且$gcd(a, n) = 1$。 $n$为合数，且$gcd(a, n) \\neq 1$。 $n = 1$。","text":"离散对数定义在初等代数中，如果$a^{x} = b$，就说$x = log{_{a}}^{b}$，即$x$是以$a$为底$b$的对数。在模运算中也有相似的概念，但比初等对数中的要稍微复杂一些。对于$a^{x}\\equiv b(mod \\ n)$，我们要分成以下几种情况来讨论： $n$为素数，且$gcd(a, n) = 1$。 $n$为合数，且$gcd(a, n) \\neq 1$。 $n = 1$。 计算对于情况一，用BSGS算法来计算就可以了；对于情况二，用EXBSGS算法。 BSGS算法定义给定$a,b,n$，求最小的非负整数$x$，满足$a^{x}\\equiv b(mod \\ n)$，其中$n\\in \\mathbb{P}$。 分析最天真的算法暴力枚举，只要我们在稍微看一下方程的形式$a^{x}\\equiv b(mod \\ n)$，就可以联想到费马小定理$a^{n - 1} \\equiv 1 (mod \\ n)$。怎样在这里运用费马小定理呢？ 我们有式子这里简要的证明一下：$a^{x \\ (mod \\ (n - 1))} \\equiv a^{x} (mod \\ n)$$a^{x - k\\cdot (n - 1)} \\equiv a^{x} (mod \\ n)$$\\frac{a^{x}}{a^{k\\cdot (n - 1)}}\\equiv a^{x} (mod \\ n)$$\\frac{a^{x}}{(a^{n - 1})^{k}}\\equiv a^{x} (mod \\ n)$ $\\because n\\in \\mathbb{P}$ $\\therefore a^{n - 1} \\equiv 1 (mod \\ n)$ $\\therefore \\frac{a^{x}}{1^{m}}\\equiv a^{x} (mod \\ n)$ $\\because a^{x} \\equiv a^{x} (mod \\ n)$ $\\therefore a^{x \\ (mod \\ (n - 1))} \\equiv a^{x} (mod \\ n)$ 因为这个式子$a^{x \\ (mod \\ (n - 1))} \\equiv a^{x} (mod \\ n)$成立，所以我们确定答案$x$一定在$[0, n - 1)$的范围内，所以现在我们可以缩小暴力枚举的范围了。那么除了枚举之外我们还可以做什么？ 令$x = i \\cdot m + j$，原式写为：$a^{i \\cdot m + j} \\equiv b (mod \\ n)$$a^{j} \\equiv b \\cdot a^{-m \\cdot i} (mod \\ n)$$a^{j} \\equiv b \\cdot (a^{-m})^{i} (mod \\ n)$咦，$a^{-m}$这不是求$a^{m}$在模$n$下的逆元吗，$m$到到底值为什么我们现在还没有定义。我们取$m = n^{\\frac{1}{2}}$，后面证明这样取$m$算法实现起来最快。 现在预处理式子的左边，先求出$a^{j} \\ mod \\ n$的值，j的循环范围为$[1, m)$避免$x$的值超过$n$。然后用$map$来存$a^{j} \\ mod \\ n$和与其对应的$j$值，按照$a^{j}\\ (mod \\ n)\\rightarrow j$的关系映射到$map$中。 处理完式子左边之后，我们来处理式子的右边， 首先先处理处$a^{m}$的逆元，然后$i$循环的范围为$[0, m)$，开始枚举$i$，同时计算$b \\cdot (a^{-m})^{i} (mod \\ n)$的值，一旦存在一个$i$值，使得$a^{j} \\equiv b \\cdot (a^{-m})^{i} (mod \\ n)$，那么取出对应的$j$值，答案$x = i \\cdot m + j$。 当然如果不想求逆元的可以在开始的时候令$x = i \\cdot m - j$，那么式子就变为$(a^{m})^{i} \\equiv b \\cdot a^{j} \\ (mod \\ n)$，然后后面的处理都是一样的。 步骤1时间复杂度为$\\Theta (mlogm)$，每一轮都需要$\\Theta (logm)$，一共$\\Theta (\\frac{n}{m})$轮，总时间复杂度为$\\Theta ((m + \\frac{n}{m})logm)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657typedef long long ll;inline ll readIn()&#123; ll x = 0; int f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar();&#125; return (ll)x * f;&#125;const int INF = 0x3f3f3f3f;map &lt;ll, ll&gt; Map;inline ll quickMod(ll a, ll b, ll n)&#123; //a ^ b % n ll res = 1; while(b)&#123; if(b &amp; 1) (res *= a) %= n; (a *= a) %= n; b &gt;&gt;= 1; &#125; return res;&#125;inline ll gcd(ll a, ll b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;inline void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) x = 1, y = 0; else &#123; exgcd(b, a % b, y, x); y -= (a / b) * x; &#125;&#125;inline ll inv(ll v, ll Mod) &#123; ll x = 0, y = 0; exgcd(v, Mod, x, y); return (x % Mod + Mod) % Mod;&#125;inline ll BSGS(ll a, ll b, ll n)&#123; ll e = 1; ll m = (int)(sqrt(n + 0.5));//ceil(sqrt(n)); ll v = inv(quickMod(a, m, n), n); Map[1] = 0; for(int i = 1; i &lt; m; ++i)&#123; (e *= a) %= n; if(!Map.count(e)) Map[e] = i; &#125; ll i; for(i = 0; i &lt; m; ++i)&#123; if(Map.count(b)) return i * m + Map[b]; (b *= v) %= n; &#125; return -1;&#125; EXBSGS算法定义给定$a,b,n$，求最小的非负整数$x$，满足$a^{x}\\equiv b(mod \\ n)$。 分析此时我们对$a, b, n$都没有任何性质了，但是不幸的是费马小定理在某些情况下好像不成立了，怎么办？ 继续分类讨论，首先对于$n = 1$时，肯定$x = 0$，这是毫无疑问的。那么$n$为合数，且$gcd(a, n) \\neq 1$的时候怎么办？我们考虑将其往$n$为质数的情况上靠。$a^{x} \\equiv b \\ (mod \\ n)$$a^{x} = b + k \\cdot n$$a^{x} - k \\cdot n = b$现在令$d = gcd(a, n)$，如果$b \\nmid d$，那么$a^{x}\\equiv b(mod \\ n)$无解。如果$b \\mid d$，则有：$\\frac{a^{x}}{d} - \\frac{k \\cdot n}{d} = \\frac{b}{d}$$a^{x - 1}\\cdot \\frac{a}{d} - \\frac{k \\cdot n}{d} = \\frac{b}{d}$即，$a^{x - 1}\\cdot \\frac{a}{d} = \\frac{b}{d}+ \\frac{k \\cdot n}{d}$$a^{x - 1}\\cdot \\frac{a}{d} \\equiv \\frac{b}{d} (mod \\ \\frac{k \\cdot n}{d})$若此时$gcd(\\frac{a}{d}, \\frac{n}{d}) = 1$，那么将式子变化为$a^{x - 1} \\equiv \\frac{b}{d}\\cdot (\\frac{a}{d})^{-1} \\ (mod \\ n)$。此时调用BSGS就可以了。若$gcd(\\frac{a}{d}, \\frac{n}{d}) \\neq 1$，那么继续如上的操作，直至$gcd(a, n) = 1$为止。 代码1234567891011121314151617181920212223242526inline void EXBSGS(ll a, ll b, ll n)&#123; ll e = 1; a %= n, b %= n; for(int i = 0; i &lt; 100; ++i)&#123; if(e == b)&#123; printf(\"%d\\n\", i); return; &#125; (e *= a) %= n; &#125;//force(可要可不要) int sum = 0; while(gcd(a, n) != 1)&#123; ll factor = gcd(a, n); if(b % factor)&#123; printf(\"No Solution\\n\"); return; &#125; n /= factor, sum++, b /= factor; (b *= inv(a / factor, n)) %= n; &#125; ll ans = BSGS(a, b, n); if(ans == -1) &#123;printf(\"No Solution\\n\"); return;&#125; printf(\"%lld\\n\", ans + sum);&#125;","categories":[],"tags":[{"name":"BSGS & EXBSGS","slug":"BSGS-EXBSGS","permalink":"http://yoursite.com/tags/BSGS-EXBSGS/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"离散对数","slug":"离散对数","permalink":"http://yoursite.com/tags/离散对数/"}]},{"title":"UVa 11609 - Teams","slug":"UVa-11609-Teams","date":"2017-06-02T12:48:25.000Z","updated":"2017-06-02T12:49:53.566Z","comments":true,"path":"2017/06/02/UVa-11609-Teams/","link":"","permalink":"http://yoursite.com/2017/06/02/UVa-11609-Teams/","excerpt":"题目地址 描述有$n$个人，选一个或多个参加比赛，其中先一个人当队长，有多少种方案？如果参赛者完全相同，但队长不同，算作不同方案。输入$n(1 \\leq n \\leq 10^{9})$，输出方案数总数除以$1000000007$。","text":"题目地址 描述有$n$个人，选一个或多个参加比赛，其中先一个人当队长，有多少种方案？如果参赛者完全相同，但队长不同，算作不同方案。输入$n(1 \\leq n \\leq 10^{9})$，输出方案数总数除以$1000000007$。 分析首先因为$n(1 \\leq n \\leq 10^{9})$，所以预处理出所有的组合数肯定是不行的，那么我们尝试对式子进行化简，使得我们仅通过$n$就可以算出方案数。我们可以将答案表示为$ans = \\sum_{k = 1}^{n}k \\cdot C_{n}^{k}$（这个应该容易想到ans ） $ \\therefore ans = 1 \\cdot C_{n}^{1} + 2 \\cdot C_{n}^{2} + \\cdots + (n - 1) \\cdot C_{n}^{n - 1} + n \\cdot C_{n}^{n}$ $\\because C_{n}^{k} = \\frac{n!}{(n - k)!k!}$ $\\therefore k \\cdot C_{n}^{1} = k \\cdot \\frac{n!}{(n - k)!k!} = \\frac{n!}{(n - k)!(k - 1)!} = n \\cdot \\frac{(n - 1)!}{(n - k)!(k - 1)!} = n \\cdot C_{n - 1}^{k - 1}$ $\\therefore ans = n \\cdot (C_{n - 1}^{0} + C_{n - 1}^{1} + \\cdots + C_{n - 1}^{n - 2} + C_{n - 1}^{n - 1})$ $\\because (a + b)^{n} = \\sum_{k = 0}^{n}C_{n}^{k}a^{n - k}b^{k}$为二项式展开系数。 $\\therefore ans = n \\cdot ((1 + 1)^{n - 1}) = n \\cdot 2^{n - 1}$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041//UVa 11609 - Teams//2017/06/02 12:55:35#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;inline ull readIn()&#123; ull x = 0; int f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MOD = 1000000007;int testCase;ull n;inline ull quickPow(ull a, ull b)&#123; ull res = 1; while(b)&#123; if(b &amp; 1) (res *= a) %= MOD; (a *= a) %= MOD; b &gt;&gt;= 1; &#125; return res;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif scanf(\"%d\", &amp;testCase); for(int kase = 1; kase &lt;= testCase; ++kase)&#123; printf(\"Case #%d: \", kase); n = readIn(); ull ans = (n * quickPow(2, n - 1)) % MOD; printf(\"%llu\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"快速幂&快速幂取模","slug":"快速幂-快速幂取模","permalink":"http://yoursite.com/tags/快速幂-快速幂取模/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"}]},{"title":"欧拉函数","slug":"欧拉函数","date":"2017-05-31T13:38:03.000Z","updated":"2017-08-28T02:17:10.701Z","comments":true,"path":"2017/05/31/欧拉函数/","link":"","permalink":"http://yoursite.com/2017/05/31/欧拉函数/","excerpt":"定义对于正整数$n$，欧拉函数$\\phi (n)$表示小于或等于$n$的正整数中与$n$互素的数的个数。 性质欧拉函数有一下四种性质：$\\bigstar \\phi(1) = 1$$\\bigstar \\phi (n) = n \\cdot \\prod_{p\\mid n}(\\frac{p - 1}{p})$$\\bigstar \\phi (p^{k}) = p^{k} - p^{k - 1}\\cdots \\cdots (p\\in \\mathbb{P})$$\\bigstar \\phi (mn) = \\phi (m) \\phi (n)\\cdots \\cdots gcd(m, n) = 1$","text":"定义对于正整数$n$，欧拉函数$\\phi (n)$表示小于或等于$n$的正整数中与$n$互素的数的个数。 性质欧拉函数有一下四种性质：$\\bigstar \\phi(1) = 1$$\\bigstar \\phi (n) = n \\cdot \\prod_{p\\mid n}(\\frac{p - 1}{p})$$\\bigstar \\phi (p^{k}) = p^{k} - p^{k - 1}\\cdots \\cdots (p\\in \\mathbb{P})$$\\bigstar \\phi (mn) = \\phi (m) \\phi (n)\\cdots \\cdots gcd(m, n) = 1$ 证明1$\\bigstar \\phi(1) = 1$ 根据欧拉函数$phi(i)$的定义推知，这是显然的。 证明2$\\bigstar \\phi (p^{k}) = p^{k} - p^{k - 1}\\cdots \\cdots (p\\in \\mathbb{P})$ $\\because p\\in \\mathbb{P}$$\\therefore$小于或等于$p^{k}$的正整数中与$p^{k}$互素的数只有$p$的倍数。$\\because$小于或等于$p^{k}$的正整数中与$p^{k}$互素的数的个数为$\\frac{p^{k}}{p}$，化简之后为$p^{k - 1}$$\\therefore \\phi (p^{k}) = p^{k} - p^{k - 1}\\cdots \\cdots (p\\in \\mathbb{P})$ 证明3$\\bigstar \\phi (mn) = \\phi (m) \\phi (n)\\cdots \\cdots gcd(m, n) = 1$很惭愧这一个我还不会证明，不过数论概论（原书第三版）$P44 \\sim P45$给出了证明。 计算现在要计算$phi[i]$的值，我们有公式$phi(n) = n \\cdot (1 - \\frac{1}{p_{1}})(1 - \\frac{1}{p_{2}})\\cdots (1 - \\frac{1}{p_{n}})$ 又$\\because n = p_{1}^{k_{1}}p_{1}^{k_{2}}\\cdots p_{n - 1}^{k_{n - 1}}p_{n}^{k_{n}}$ $\\therefore \\phi (n) = \\phi (p_{1}^{k_{1}})\\phi (p_{2}^{k_{2}})\\cdots \\phi (p_{n - 1}^{k_{n - 1}})\\phi (p_{n}^{k_{n}})\\$ $= (p_{1}^{k_{1}} - p_{1}^{k_{1} - 1})(p_{2}^{k_{2}} - p_{2}^{k_{2} - 1})\\cdots (p_{n}^{k_{n}} - p_{n}^{k_{n} - 1})\\$ $=p_{1}^{k_{1} - 1}(p_{1} - 1)p_{2}^{k_{2} - 1}(p_{2} - 1)\\cdots p_{n}^{k_{n} - 1}(p_{n} - 1)\\$ $= p_{1}^{k_{1}}\\frac{(p_{1} - 1)}{p_{1}}p_{2}^{k_{2}}\\frac{(p_{2} - 1)}{p_{2}}\\cdots p_{n}^{k_{n}}\\frac{(p_{n} - 1)}{p_{n}}\\$ $= p_{1}^{k_{1}}p_{2}^{k_{2}}\\cdots p_{n}^{k_{n}}\\cdot \\frac{(p_{1} - 1)}{p_{1}}\\frac{(p_{2} - 1)}{p_{2}}\\cdots \\frac{(p_{n} - 1)}{p_{n}}\\$ $= n \\cdot (1 - \\frac{1}{p_{1}})(1 - \\frac{1}{p_{2}})\\cdots (1 - \\frac{1}{p_{n}})\\$ $\\bigstar \\phi (n) = n \\cdot \\prod_{p\\mid n}(\\frac{p - 1}{p})$那么这个式子也得证了，这个式子只是用于计算单个$phi[i]$的值，来构造一个小于等于$n$的$phi$表。计算第$n$个数的$phi$值，要用到这个式子： 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10000 + 3;int n;int phi[MAX];//求与第n个数互素的数的个数int euler_phi(int n) &#123; int m = (int)sqrt(n + 0.5); LL ans = n; for (int i = 2; i &lt;= m; i++) &#123; if (n % i == 0)&#123; ans = ans / i * (i - 1); while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) ans = ans / n * (n - 1); return ans;&#125;//1~n中所有数的欧拉phi函数值 O(nloglogn)void phi_table(int n)&#123; for(int i = 2; i &lt;= n; i++) phi[i] = 0; phi[1] = 1; for(int i = 2; i &lt;= n; i++)&#123; if(!phi[i])&#123; for(int j = i; j &lt;= n; j += i)&#123; if(!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); &#125; &#125; &#125;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\",\"r\",stdin);#endif scanf(\"%d\", &amp;n); printf(\"phi(%d) = %d\\n\", n, euler_phi(n)); for(int i = 1; i &lt;= n; i++)&#123; phi_table(i); printf(\"phi[%d] = %d\\n\", i, phi[i]); &#125; return 0;&#125;/*phi(n) 表示的含义是,不超过x且和x互素的整数个数.*/","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://yoursite.com/tags/欧拉函数/"}]},{"title":"BZOJ 1008: [HNOI2008]越狱","slug":"BZOJ-1008-HNOI2008-越狱","date":"2017-05-31T12:46:28.000Z","updated":"2017-06-03T16:30:15.362Z","comments":true,"path":"2017/05/31/BZOJ-1008-HNOI2008-越狱/","link":"","permalink":"http://yoursite.com/2017/05/31/BZOJ-1008-HNOI2008-越狱/","excerpt":"题目地址 描述监狱有连续编号为$1, 2, 3 \\cdots , N - 1, N$的$N(1 \\leq N \\leq 10^{12})$个房间，每个房间关押一个犯人，有$M(1 \\leq M \\leq 10^{8})$种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能越狱的状态数，模$100003$取余。","text":"题目地址 描述监狱有连续编号为$1, 2, 3 \\cdots , N - 1, N$的$N(1 \\leq N \\leq 10^{12})$个房间，每个房间关押一个犯人，有$M(1 \\leq M \\leq 10^{8})$种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能越狱的状态数，模$100003$取余。 分析 可能越狱的状态数$ans$，等于所有的状态数$sum$减去不可能越狱的状态数$total$。 我们要求所有的状态数$sum$的时候是没有任何限制的所以$sum = m^{n}$。 对于不可能越狱的状态数$total$： 当$n = 1$的时候，$total = m$； 当$n = 2$的时候，$total = m \\cdot (m - 1)$； 当$n = 3$的时候，$total = m \\cdot (m - 1) \\cdot (m - 1)$；$\\vdots $ 当$n = N$的时候，$total = m \\cdot (m - 1) ^ {n - 1}$ 对于除第一个监狱以外，每一个监狱选择的信仰依赖于前面那一个监狱，即选择与前一个监狱不一样的信仰，就可以让每一个相邻的监狱没有犯人的宗教相同。 $\\therefore ans = m^{n} - m \\cdot (m - 1)^{n - 1}(1 \\leq m \\leq 10^{8}, 1 \\leq n \\leq 10^{12})$因为$m, n$都太大了直接强行计算幂次方的时候容易溢出，所以这里用快速幂取模来算。快速幂取模依赖于以下递推式：我们也可以证明$a^{b} \\ \\%\\ Mod = [(a \\ \\% \\ Mod) \\cdot b] \\ \\% \\ Mod$两者等价。 代码123456789101112131415161718192021222324252627282930313233343536373839// BZOJ 1008: [HNOI2008]越狱//2017/5/31 8:32//数学 + 快速幂#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline LL readIn()&#123; LL x = 0; int f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MOD = 100003;const int INF = 0x3f3f3f3f;LL n, m;LL quickPow(LL a, LL b)&#123; LL res = 1; while(b)&#123; if(b &amp; 1) (res *= a) %= MOD; (a *= a) %= MOD; b &gt;&gt;= 1; &#125; return res;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif m = readIn(), n = readIn(); //printf(\"%lld\\n\", quickPow(m - 1, n - 1)); LL ans = (quickPow(m, n) - (m * quickPow(m - 1, n - 1)) % MOD + MOD) % MOD; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"快速幂&快速幂取模","slug":"快速幂-快速幂取模","permalink":"http://yoursite.com/tags/快速幂-快速幂取模/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"}]},{"title":"关于图的连通性的三个Tarjan算法","slug":"关于图的连通性的三个Tarjan算法","date":"2017-05-28T04:35:54.000Z","updated":"2017-05-29T14:51:43.885Z","comments":true,"path":"2017/05/28/关于图的连通性的三个Tarjan算法/","link":"","permalink":"http://yoursite.com/2017/05/28/关于图的连通性的三个Tarjan算法/","excerpt":"无向图的割点和桥定义对于无向图$G$，如果删除某点$u$之后，连通分量数目增加，称$u$为图的割点。对于无向图$G$， 如果删除某一条边$e = (u, v)$，连通分量数目增加，称$e$为图的桥。","text":"无向图的割点和桥定义对于无向图$G$，如果删除某点$u$之后，连通分量数目增加，称$u$为图的割点。对于无向图$G$， 如果删除某一条边$e = (u, v)$，连通分量数目增加，称$e$为图的桥。 分析求割点方法1： 尝试删除每一个结点，然后DFS一遍判断连通分量是否增加。$\\Theta (n)$删点，$\\Theta (n + m)$来DFS，时间复杂度为$\\Theta (n(n + m))$。 方法2： 尝试在线性时间内求出所有的割点，即DFS一遍，时间复杂度$\\Theta (n + m)$。那么首先我们我们将无向连通图DFS一遍之后会得到一个DFS森林，对于每一结点都有进入DFS森林的时间和出去的时间，那么我们记录每一条边进入的时间和出去的时间，也就是先后顺序（DFS序），就可以处理出每一个点与点之间、边与边之间的关系。通过每一个点的时间戳，我们可以知道DFS森林中有四种边。 树边：无向图的边$e = (u, v)$，会被访问两次，访问$u$的时候一次，访问$v$的时候一次。换句话就是，顶点v是在访问边$e = (u, v)$的时候才首次被访问的。 反向边：第一次处理的时候，对于边$e = (u, v)$，从$u$的后代$v$指向u的祖先的边，意味着存在自环。 前向边：连接顶点$u$到它的某一个后裔$v$的非树边 交叉边：在于同一棵深度优先树中的两个顶点$u, v$之间，条件是顶点$u$不是顶点$v$的祖先。交叉边也可以在不同的深度优先树的顶点之间。 无向图之后反向边和树边，而有向图除了树边和反向边之外还有前向边和交叉边。 假设当前的DFS森林中只有一棵树，那么根据定义树根肯定不是割点，当且仅当树根有两个及以上子树的时候，他才会是割点。 那么对于非根结点一般的情况如何判断其实不是割点就要依靠定理：在无向连通图$G$的DFS树中，非根结点$u$是$G$割点当且仅当$u$存在一个子结点$v$，使得$v$及其所有后代都没有反向边连回$u$的祖先，连回$u$的不算，即不存在反向边。证明：看一下图就可以明白了，如图所示： 考虑$u$的任意子结点$v$，如果$v$及其后代不能连回$f$，那么删除$u$之后$f$和$v$不再连通，此时$u$为割点。 反之，如果$v$或它的任意一个后代存在一条反向边连向$f$，那么，删除结点$u$以后$v$及$v$的子树中的结点仍能够通过这条反向边连回$f$，那么此时因为图仍是连通的，所以$u$不一定是割点。以上，得证。 那么我们的线性算法也就出来了，流程是这样的： 记$pre(u)$为结点$u$进入DFS森林中的时间戳，$low(u)$为$u$及其后代所能连回的最早的祖先的$pre$值。 依次访问结点$u$的每一个子结点。 对于没有访问过的子结点，DFS并用后代的$low$值来更新结点$u$的$low$函数，如果后代的$low$值均小于等于$pre[u]$，那么$u$结点为割点。 如果存在反向边，用反向边来更新$u$的$low$函数。 最后处理树根的情况。 求桥理解求割点，那么求桥就简单了。如果$v$的后代只能连回$v$自己，那么只需删除$(u, v)$一条边就能够使图非连通了，此时边$e = (u, v)$为桥。那么只需要把求割点的第三步改一下就可以了。 记$pre(u)$为结点$u$进入DFS森林中的时间戳，$low(u)$为$u$及其后代所能连回的最早的祖先的$pre$值。 依次访问结点$u$的每一个子结点。 对于没有访问过的子结点，DFS并用后代的$low$值来更新结点$u$的$low$函数，如果后代的$low$值均小于等于$pre[u]$，那么$e = (u, v)$为桥。 如果存在反向边，用反向边来更新$u$的$low$函数。 最后处理树根的情况。 代码1234567891011121314151617int dfs(int u, int fa)&#123; int lowu = pre[u] = ++timeStamp; int child = 0; for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(!pre[v])&#123;//u的子结点v没有访问过 child++; int lowv = dfs(v, u); lowu = min(lowu, lowv);//用子树中结点的low值来更新u结点的low函数 if(lowv &gt;= pre[u]) isCut[u] = true;//割边:lowv &gt; pre[u] &#125; else if(pre[v] &lt; pre[u] &amp;&amp; v != fa) lowu = min(lowu, pre[v]);//存在反向边，用反向边更新u的low函数 &#125; if(fa &lt; 0 &amp;&amp; child == 1) isCut[u] = false;//树根 low[u] = lowu; return lowu;&#125; 无向图的双连通分量定义对于一个连通图，如果任意两点至少存在两条“点不重复”的路径，则这个图是点-双连通的；即任意两条边都在同一个简单换中，连通图中不存在割点。对于一个连通图，如果人意两点之间至少存在两条“边不重复”的路径，则这个图是边-双连通的；即内一条边都至少在一个简单环中，连通图中不存在桥。 分析如图所示，这是一个无向图双连通分量例子： 点-双连通分量对于一张无向图，点-双连通的极大子图称为双连通分量。我们可以发现，每一条边有且仅属于一个点-双连通分量，但是不同的点-双连通分量可能会有公共点。可以证明不同的点-双连通分量最多只有一个公共点，且它一定是割点。这一个很好证明，我们假设两个点-双连通分量有两个及以上的公共点，那么无论删除其中哪一个点图的连通性也不会改变，根据割点的定义，这些公共点没有哪一个会是割点。任意割点也都至少会是两个不同点-双连通分量的公共点。 回顾求个点的过程，当我们找到割顶的时候，就已经完成了一次对某个极大点双连通子图的访问，那么我们如果在进行DFS的过程中将遍历过的点保存起来，那么就可以得到点双连通分量了。 为了实现算法，我们可以在求解割顶的过程中用一个栈保存遍历过的边（注意不是点！因为不同的双连通分量存在公共点即割顶），之后每当找到一个点双连通分量，即子结点$v$与父节点$u$满足关系$low[v]&gt;=pre[u]$，我们就将栈里的东西拿出来直到栈中没有与$u$相关联的点为止且现在取出的是当前边。 这里注意放入栈中的不是点，而是边，这是因为点双连通分量是存在重复点的，如果我们放入栈中的是点，那么对于某些点双连通分量，就会少掉一些点（这些点都是割顶）。栈S保存当前双连通分量中的边，注意这里是边不是点 边-双连通分量同理，边-双连通的极大子图称之为边-双连通分量。除了桥不属于任何边-双连通分量之外，其他每一条边恰好属于一个边-双连通分量。所以我们只要把图中的桥边都删除之后，那么此时每一个连通分量就是此无向图中的边-双连通分量。那么求边-双连通分量的方法也就很清晰了。 边双连通分量例题，将稍后填坑。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct Edge&#123; int from, to;&#125;;int pre[MAX_N], bccno[MAX_N], bcc_cnt, timeStamp;//结点进入DFS森林的值，编号为i的点所属的双连通分量，双连通分量个数，时间戳bool isCut[MAX_N];vector&lt;int&gt; G[MAX_N], bcc[MAX_N];//保存图和双连通分量stack&lt;int&gt; S;int dfs(int u, int fa)&#123; int lowu = pre[u] = ++timeStamp; int child = 0; for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; Edge e = edge&#123;u, v&#125;; if(!pre[v])&#123;//没有访问过的u的子结点v S.push(e); child++; int lowv = dfs(v, u); lowu = min(lowu, lowv);//有u的后代来更新u的low函数 if(lowv &gt;= pre[u])&#123;//边-双连通分量：lowv &gt; pre[u] isCut[u] = true; bcc_cnt++; bcc[bcc_cnt].clear();//BCC编号从1开始 while(1)&#123; Edge x = S.top(); S.pop();//逐一将边取出 if(bccno[x.u] != bcc_cnt) &#123;//这个点还没有统计到这个连通分量。 bcc[bcc_cnt].push_back(x.u); bccno[x.u] = bcc_cnt;&#125; if(bccno[x.v] != bcc_cnt) &#123; bcc[bcc_cnt].push_back(x.v); bccno[x.v] = bcc_cnt;&#125; if(x.u == u &amp;&amp; x.v == v) break;//扫到u-v，栈中又没有与u相连的边了。继续试试其他孩子 &#125; &#125; &#125; else if(pre[v] &lt; pre[u] &amp;&amp; v! = fa)&#123;//对于反向边 S.push(e); lowu = min(lowu, pre[v]);//用反向边更新u的low函数 &#125; &#125; if(fa &lt; 0 &amp;&amp; child == 1) isCut[u] = false;//树根 return lowu;&#125;void find_scc()&#123; memset(pre, 0, sizeof pre);//初始化 memset(bccno, 0, sizeof bccno); memset(isCut, 0, sizeof isCut); bcc_cnt = timeStamp = 0; for(int i = 0; i &lt; n; ++i) id(!pre[i]) dfs(i, -1);&#125; 有向图的强连通分量定义如无向图一样，有向图也有相互到达这概念，对于可相互到的点我们把这些点看做一个集合，每一个集合称为有向图的一个强连通分量，简称为SCC。如果把一个集合看做一个点，那么所有的SCC构成了一个SCC图，而这个SCC图根据定义肯定是一个有向无环图，也就是一个DAG，因为一单还存环肯定会缩成一个新的SCC。 如图所示，从$G$开始DFS，最后原图会变成如下所示： 分析如果我们从$A$开始DFS，那么最终算法会得出整个有向图都是连通的，也就是这颗DSF树会包含整个图。所以有时候从不同的点出发得出的SCC图和我们定义上所期望的会相差甚远，那么如何来解决这个问题呢？我们要将多哥SCC从一颗DFS树中分离出来。考虑一个强连通分量$C$，设其中第一个被发现的点为$x$，则$C$中其他的点我们认为是$x$的后代。我们希望在$x$的子节点访问完回到$x$之后就输强联通分量$C$，这样我们就可以把一棵树中的SCC都分离开。 如图所示：然后我们需要判断结点$u$是否为此SCC第一个被访问到的结点。 如果我们发现$u$的子结点出发可以到达$u$的祖先$w$，显然$u, v,w$在同一个SCC中但是此时$u$并不会是此SCC中第一个被访问到的结点而至少会是$w$。 如果$u$的所有子结点最多只能到达$u$，那么，$u$就是该SCC中第一个被发现的点。 问题被转化成为了求每一个点岁远能到达的祖先的low函数的值，这里的到达指的是通过当前SCC中的点到达，而不是通过已经确定SCC编号的其他点。 代码123456789101112131415161718192021222324252627282930313233vector&lt;int&gt; G[MAX_N];int pre[MAX_N], lowlink[MAX_N], sccno[MAX_N], scc_cnt, timeStamp;stack&lt;int&gt; S;void dfs(int u)&#123; pre[u] = lowlink[u] = ++timeStamp;//进入DFS树的时间 S.push(u); for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(!pre[v])&#123;//没有遍历过 dfs(v);//递归处理 lowlink[u] = min(lowlink[u], lowlink[v]);//回溯时发现v可以到达更小（DFS上更远）的时间戳 &#125; else if(!sccno[v]) lowlink[u] = min(lowlink[u], pre[v]);//访问过，且不在其他连通分量中的栈内的结点，反向边 &#125; if(lowlink[u] == pre[u])&#123;//u为当前强连通分量第一个访问到的结点 scc_cnt++; while(1)&#123; int x = S.top(); S.pop(); sccno[x] = scc_cnt; size[scc_cnt]++; if(x == u) break; &#125; &#125; //printf(\"%d\\n\", scc_cnt);&#125;void Tarjan()&#123; timeStamp = 0, scc_cnt =0;//初始化 memset(sccno, 0, sizeof sccno); memset(pre, 0, sizeof pre); for(int i = 1; i &lt;= n; ++i) if(!pre[i]) dfs(i);&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"割点","slug":"割点","permalink":"http://yoursite.com/tags/割点/"},{"name":"桥","slug":"桥","permalink":"http://yoursite.com/tags/桥/"},{"name":"边-双连通分量","slug":"边-双连通分量","permalink":"http://yoursite.com/tags/边-双连通分量/"},{"name":"点-双连通分量","slug":"点-双连通分量","permalink":"http://yoursite.com/tags/点-双连通分量/"},{"name":"强联通分量","slug":"强联通分量","permalink":"http://yoursite.com/tags/强联通分量/"},{"name":"Tarjan","slug":"Tarjan","permalink":"http://yoursite.com/tags/Tarjan/"}]},{"title":"UVa 12167 - Proving Equivalences","slug":"UVa-12167-Proving-Equivalences","date":"2017-05-28T03:02:19.000Z","updated":"2017-05-30T15:44:49.733Z","comments":true,"path":"2017/05/28/UVa-12167-Proving-Equivalences/","link":"","permalink":"http://yoursite.com/2017/05/28/UVa-12167-Proving-Equivalences/","excerpt":"题目地址 描述在数学中，我们常常需要完成若干个命题的等价性证明。比如，有4个命题$a, b, c, d$，我们证明$a \\leftrightarrow b$，然后$b\\leftrightarrow c$，最后$c\\leftrightarrow d$。注意每次证明都是双向的，一次一共完成了6次推导。另一种方法是证明$a\\rightarrow b$，然后$b\\rightarrow c$，接着$c\\rightarrow d$，最后$d\\rightarrow a$，只需4次。现在你的任务是证明$n(1 \\leq n \\leq 20000)$个命题是全部等价的，且你的朋友已经帮你做出了$m(0 \\leq m \\leq 50000)$次推导（已知每次推导的内容），你至少还需要做几次推导才能完成整个证明，输出最少的推导次数。","text":"题目地址 描述在数学中，我们常常需要完成若干个命题的等价性证明。比如，有4个命题$a, b, c, d$，我们证明$a \\leftrightarrow b$，然后$b\\leftrightarrow c$，最后$c\\leftrightarrow d$。注意每次证明都是双向的，一次一共完成了6次推导。另一种方法是证明$a\\rightarrow b$，然后$b\\rightarrow c$，接着$c\\rightarrow d$，最后$d\\rightarrow a$，只需4次。现在你的任务是证明$n(1 \\leq n \\leq 20000)$个命题是全部等价的，且你的朋友已经帮你做出了$m(0 \\leq m \\leq 50000)$次推导（已知每次推导的内容），你至少还需要做几次推导才能完成整个证明，输出最少的推导次数。 分析刘汝佳先生说的解释，其实有一些绕还有一些定理没有证明，这里我简要的理了一下逻辑，然后把证明做了。 我们其实可以把每一个命题看成一个结点，把推到看成一条有向边，如由$a$推导出$b$，那么连边$a\\rightarrow b$。那么我们一开始得到的其实是有$n$个结点$m$条有向边的有向图，而最终的等价性证明相当于添加最少的边，使当前的有向图形成一个环。也就是所有的点最终都会包含在同一个强连通分量中。那么，我们首先在原图上找出所有的强连通分量，然后把每一个强连通分量缩成一个点，得到一个DAG。 定理：设原图有$a$个入度为$0$的结点，$b$个出度为$0$的结点，则$max \\{a, b\\}$就是答案（这里的每一个结点对应原图的一个SCC）。 证明：既然要证明，那么我们就要构造出在任何情况下都能使结论成立的方案，那么进行如下的分类讨论。当入度为0的点多于出度为0的点的时候很好构造，如图：我们要分成两种情况来讨论： 我们把DAG看成一棵有向的树，有一种可能就是转化成树后是多个互不相干的树，我们进行如图的转换：若这多棵树中有树存在公共的叶结点，那么只需要在进行第一步的时候选择不与之相连的点连接，如图： 我们将DAG看成一棵有向树之后发现，最终只会形成一棵有向树，那么按照如图的方式处理： 综上所述，我们已经处理了所有的情况下构造方式，证毕。Orz Skipher学长，Sengxian学长 ヾ(o°ω°O)ノ゙ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//UVa 12167 - Proving Equivalences//2017/5/22 14:48//SCC#include &lt;bits/stdc+.h&gt;using namespace std;typedef long long LL;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 20000 + 3;const int MAX_M = 50000 + 3;const int INF = 0x3f3f3f3f;int testCase;int n, m;int pre[MAX_N], lowlink[MAX_N], sccno[MAX_N], scc_cnt, timeStamp;vector&lt;int&gt; G[MAX_M];stack&lt;int&gt; S;int in[MAX_N], out[MAX_N];namespace SCC&#123; void dfs(int u)&#123; pre[u] = lowlink[u] = ++timeStamp; S.push(u); for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(!pre[v])&#123; dfs(v); lowlink[u] = min(lowlink[u], lowlink[v]); &#125; else if(!sccno[v]) lowlink[u] = min(lowlink[u], pre[v]); &#125; if(lowlink[u] == pre[u])&#123; scc_cnt++; while(1)&#123; int x = S.top(); S.pop(); sccno[x] = scc_cnt; if(x == u) break; &#125; &#125; &#125; void findSCC(int n)&#123; memset(pre, 0, sizeof pre); memset(lowlink, 0, sizeof lowlink); memset(sccno, 0, sizeof sccno); timeStamp = scc_cnt = 0; for(int i = 0; i &lt; n; ++i) if(!pre[i]) dfs(i); &#125;&#125;using namespace SCC;int main()&#123;#ifndef DEBUG freopen(\"test.in\", \"r\", stdin);#endif testCase = readIn(); while(testCase--)&#123; n = readIn(), m = readIn(); for(int i = 0; i &lt; n; ++i) G[i].clear(); for(int i = 0; i &lt; m; ++i)&#123; int u = readIn(), v = readIn(); u--; v--; G[u].push_back(v); &#125; findSCC(n); for(int i = 1; i &lt;= scc_cnt; ++i) in[i] = out[i] = 1; for(int u = 0; u &lt; n; ++u)&#123; for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(sccno[u] != sccno[v]) out[sccno[u]] = in[sccno[v]] = 0; &#125; &#125; int cnt1 = 0, cnt2 = 0; for(int i = 1; i &lt;= scc_cnt; ++i)&#123; if(in[i]) cnt1++; if(out[i]) cnt2++; &#125; int ans = max(cnt1, cnt2); if(scc_cnt == 1) ans = 0; printf(\"%d\\n\", ans); &#125; return 0;&#125; 另一种思路首先对于如下的图我们我们肯定可以在$max \\{a, b \\}$a条边内构造出一个SCC，那么我们用递归的思想将其转化为这样的形式即可。其实这种思路我并没有完全理解，我再想一下，还是太蒻（；´д｀）ゞ","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"强连通分量","slug":"强连通分量","permalink":"http://yoursite.com/tags/强连通分量/"}]},{"title":"UVa 1391 - Astronauts","slug":"UVa-1391-Astronauts","date":"2017-05-28T02:58:39.000Z","updated":"2017-05-28T04:30:24.191Z","comments":true,"path":"2017/05/28/UVa-1391-Astronauts/","link":"","permalink":"http://yoursite.com/2017/05/28/UVa-1391-Astronauts/","excerpt":"题目地址 描述有$A, B, C$三种任务要分给n个宇航员，其中每个宇航员恰好分到一个任务。设$n(1 \\leq n \\leq 100000)$个宇航员的平均年龄为$x$，只有年龄大于等于$x$的宇航员才能分配任务$A$；只有年龄严格小于$x$的宇航员才能分到任务$B$，而任务$C$没有限制。有$m(1 \\leq m \\leq 100000)$对宇航员相互讨厌，因此不能分配到同一任务。找出满足上述所有要求的方案。 分析这道题目和之前的见图有些不一样，因为$true$和$false$对于每一个点的意义都不一样，但是不变的是每一个变量（宇航员）只有两个选择。用布尔变量$X_{i}$表示第$i$个宇航员的的分配方案。 对于年轻的宇航员，即年老的宇航员，要么做任务$B(X_{i} = true)$，要么做任务$C(X_{i} = false)$。 对于年龄大于等于平均年龄的宇航员，要么做任务$A(X_{i} = true)$，要么做任务$C(X_{i} = false)$。","text":"题目地址 描述有$A, B, C$三种任务要分给n个宇航员，其中每个宇航员恰好分到一个任务。设$n(1 \\leq n \\leq 100000)$个宇航员的平均年龄为$x$，只有年龄大于等于$x$的宇航员才能分配任务$A$；只有年龄严格小于$x$的宇航员才能分到任务$B$，而任务$C$没有限制。有$m(1 \\leq m \\leq 100000)$对宇航员相互讨厌，因此不能分配到同一任务。找出满足上述所有要求的方案。 分析这道题目和之前的见图有些不一样，因为$true$和$false$对于每一个点的意义都不一样，但是不变的是每一个变量（宇航员）只有两个选择。用布尔变量$X_{i}$表示第$i$个宇航员的的分配方案。 对于年轻的宇航员，即年老的宇航员，要么做任务$B(X_{i} = true)$，要么做任务$C(X_{i} = false)$。 对于年龄大于等于平均年龄的宇航员，要么做任务$A(X_{i} = true)$，要么做任务$C(X_{i} = false)$。 现在考虑一对相互讨厌的宇航员$i, j$， 如果他们同属于年轻或年老，那么$X_{i}, X_{j}$必须不相同，这里用一个或语句表示不清要用两个。 第一个或语句用合取范式来表示就是$X_{i} \\vee X_{j}$，意思是两者至少有一个为$true$。即一对相互讨厌的宇航员，不管这一对是年轻的宇航员还是年老的宇航员都不能同时分派到任务$C$，所以加边$addClause(a, 1, b, 1)$。 第二个约束条件用合取范式来表示就是$\\neg X_{i} \\vee \\neg X_{j}$，意思是两者至少有一个为$false$。即一对相互讨厌的年轻宇航员不能同时分派到任务$B$，所以加边$addClause(a, 0, b, 0)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//UVa 1391 - Astronauts//2017/5/25 13:47//2-SAT#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100000 + 3;const int MAX_M = 100000 + 3;const int INF = 0x3f3f3f3f;int n, m;vector&lt;int&gt; G[MAX_N &lt;&lt; 1];int S[MAX_N &lt;&lt; 1], c;bool mark[MAX_N &lt;&lt; 1];int totalAge, age[MAX_N];namespace TwoSAT&#123; void init(int n)&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); ++i) G[i].clear(); memset(mark, 0, sizeof mark); &#125; void addClause(int x, int xval, int y, int yval)&#123; x = (x &lt;&lt; 1) + xval; y = (y &lt;&lt; 1) + yval; G[x^1].push_back(y); G[y^1].push_back(x); &#125; bool dfs(int x)&#123; if(mark[x^1]) return false; if(mark[x]) return true; mark[x] = true; S[c++] = x; for(int i = 0; i &lt; G[x].size(); ++i) if(!dfs(G[x][i])) return false; return true; &#125; bool solve()&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); i += 2)&#123; if(!mark[i] &amp;&amp; !mark[i + 1])&#123; c = 0; if(!dfs(i))&#123; while(c &gt; 0) mark[S[--c]] = false; if(!dfs(i + 1)) return false; &#125; &#125; &#125; return true; &#125;&#125;using namespace TwoSAT;bool check(int x)&#123; return age[x] * n &lt; totalAge ? 1 : 0;&#125;int main()&#123;#ifndef DEBUG freopen(\"test.in\", \"r\", stdin);#endif while(scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n &amp;&amp; m)&#123; init(n); totalAge = 0; memset(age, 0, sizeof age); //printf(\"%d %d\\n\", n, m); for(int i = 0; i &lt; n; ++i)&#123; age[i] = readIn(); totalAge += age[i]; &#125; //printf(\"%d\\n\", totalAge); for(int i = 0; i &lt; m; ++i)&#123; int u = readIn(), v = readIn(); //printf(\"%d %d\\n\", u, v); u--; v--; if(u == v) continue; addClause(u, 1, v, 1); if(check(u) == check(v)) addClause(u, 0, v, 0); &#125; if(!solve()) printf(\"No solution.\"); else&#123; for(int i = 0; i &lt; n; ++i)&#123; if(mark[i &lt;&lt; 1]) printf(\"C\\n\");// x[i]=false，去任务C else if(check(i)) printf(\"B\\n\");// x[i]=true的年轻宇航员去任务B else printf(\"A\\n\");// x[i]=true的年轻宇航员去任务A &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://yoursite.com/tags/2-SAT/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"}]},{"title":"UVa 1146 - Now or later","slug":"UVa-1146-Now-or-later","date":"2017-05-26T15:35:26.000Z","updated":"2017-05-28T04:31:02.353Z","comments":true,"path":"2017/05/26/UVa-1146-Now-or-later/","link":"","permalink":"http://yoursite.com/2017/05/26/UVa-1146-Now-or-later/","excerpt":"题目地址 描述$n$($n \\leq 2000$)班飞机，每个飞机有一个早到时间和一个晚到时间，问怎么安排飞机，使得飞机到的间隔的最小值最大？ 分析最小化最大值，首先想到的是二分。 这里回顾一下二分法。我习惯是遵循一闭一开原则维护答案，假设下标为$0, 1, 2, ···, n - 1$，如果要求最大化答案，那么维护区间$[l, r)$；如果要求最小化答案，那么维护区间$(l, r]$。12345while(r - l &gt; 1)&#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) l = mid; else r = mid;&#125;","text":"题目地址 描述$n$($n \\leq 2000$)班飞机，每个飞机有一个早到时间和一个晚到时间，问怎么安排飞机，使得飞机到的间隔的最小值最大？ 分析最小化最大值，首先想到的是二分。 这里回顾一下二分法。我习惯是遵循一闭一开原则维护答案，假设下标为$0, 1, 2, ···, n - 1$，如果要求最大化答案，那么维护区间$[l, r)$；如果要求最小化答案，那么维护区间$(l, r]$。12345while(r - l &gt; 1)&#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) l = mid; else r = mid;&#125; 这道题目我们二分时间间隔，每一个飞机为一个变量，而早到和晚到的时间为一个集合中不能共存的两个元素。$false$表示早到，$true$表示晚到。枚举每一个飞机之间的情况，存在冲突则添加条件使其不能一起选择，最后判断是否矛盾即可。 每一个飞机之间的情况有四种： A飞机早到，B飞机早到； A飞机早到，B飞机晚到； A飞机晚到，B飞机早到； A飞机晚到，B飞机晚到； 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//UVa 1146 - Now or later//2017/5/34 16:57//2-SAT + 二分(最大化最小值)#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ago;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 2000 + 3;const int INF = 1e7 + 3;int n;vector&lt;int&gt; G[MAX_N &lt;&lt; 1];int S[MAX_N &lt;&lt; 1], c;bool mark[MAX_N &lt;&lt; 1];int T[MAX_N &lt;&lt; 1][3];namespace TwoSAT&#123; void init(int n)&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); ++i) G[i].clear(); memset(mark, false, sizeof mark); &#125; void addClause(int x, int xval, int y, int yval)&#123; x = (x &lt;&lt; 1) + xval; y = (y &lt;&lt; 1) + yval; G[x^1].push_back(y);// G[y^1].push_back(x); &#125; bool dfs(int x)&#123; if(mark[x^1]) return false; if(mark[x]) return true; mark[x] = true; S[c++] = x; for(int i = 0; i &lt; G[x].size(); ++i) if(!dfs(G[x][i])) return false; return true; &#125; bool solve()&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); i += 2)&#123; if(!mark[i] &amp;&amp; !mark[i + 1])&#123; c = 0; if(!dfs(i))&#123; while(c &gt; 0) mark[S[--c]] = false; if(!dfs(i + 1)) return false; &#125; &#125; &#125; return true; &#125;&#125;using namespace TwoSAT;bool check(int diff)&#123; init(n); for(int i = 0; i &lt; n; ++i) for(int a = 0; a &lt; 2; ++a) for(int j = i + 1; j &lt; n; ++j) for(int b = 0; b &lt; 2; ++b) if(abs(T[i][a] - T[j][b]) &lt; diff) addClause(i, a ^ 1, j, b ^ 1);// return solve();&#125;int main()&#123;#ifndef DEBUG freopen(\"test.in\", \"r\", stdin);#endif while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n)&#123; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; 2; ++j)&#123; T[i][j] = readIn(); &#125; &#125; int l = -1, r = INF; /*也是一种二分的办法 while(l &lt; r)&#123; int mid = l + (r - l + 1) / 2; if(check(mid)) l = mid; else r = mid - 1; &#125; */ while(r - l &gt; 1)&#123; int mid = (r + l) / 2; //printf(\"%d \", mid); if(check(mid)) l = mid; //return 0; else r = mid; &#125; printf(\"%d\\n\", l); &#125; return 0;&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://yoursite.com/tags/2-SAT/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"}]},{"title":"POJ 3678 Katu Puzzle","slug":"POJ-3678-Katu-Puzzle","date":"2017-05-25T01:36:26.000Z","updated":"2017-05-28T04:33:00.136Z","comments":true,"path":"2017/05/25/POJ-3678-Katu-Puzzle/","link":"","permalink":"http://yoursite.com/2017/05/25/POJ-3678-Katu-Puzzle/","excerpt":"题目地址 描述有$n$($n \\leq 1000$)个变量和$m$($m \\leq 1000000$)个式子，给出一些条件 （‘AND’，‘OR’，‘XOR’）以及值，问能否对这些变量赋值，使得条件全部满足。满足输出 YES，否则输出 NO。$m$个式子中包含有向边$e(a, b)$，操作$opt$以及结果$c(0\\leq c\\leq 1)$，每一个顶点$V_{i}$存在一个$X_{i}$使得式子$X_{a} \\ opt \\ X_{b} = c$成立。 And 0 1 Or 0 1 Xor 0 1 0 0 0 0 0 1 0 0 1 1 0 1 1 1 1 1 1 0","text":"题目地址 描述有$n$($n \\leq 1000$)个变量和$m$($m \\leq 1000000$)个式子，给出一些条件 （‘AND’，‘OR’，‘XOR’）以及值，问能否对这些变量赋值，使得条件全部满足。满足输出 YES，否则输出 NO。$m$个式子中包含有向边$e(a, b)$，操作$opt$以及结果$c(0\\leq c\\leq 1)$，每一个顶点$V_{i}$存在一个$X_{i}$使得式子$X_{a} \\ opt \\ X_{b} = c$成立。 And 0 1 Or 0 1 Xor 0 1 0 0 0 0 0 1 0 0 1 1 0 1 1 1 1 1 1 0 分析 首先对于And操作： 当$c = 0$ 时，若$a = 0$，则$b = 1 \\parallel b = 0 $，因为$a，b$之间的关系不是确定的所以不连边；$a = 1$时$b = 0$，$a$与$b$之间关系是确定的所以连$a\\rightarrow \\neg b$；同理$b = 1$时$a = 0$，所以连边$\\neg b\\rightarrow a$；表示出来就是$addClause(a, 0, b, 0)$。 当$c = 1$ 时，$a, b$必须满足$a = 1 且 b = 1$，所以加入边$\\neg a \\rightarrow a \\ \\wedge \\neg b \\rightarrow b$，转换成为$addClause$操作就是$addClause(a, 1, b, 1),\\ \\ \\ addClause(a, 1, b, 0), \\ \\ \\ addClause(a, 0, b, 1)$。$addClause(a, 1, b, 0), \\ \\ \\ addClause(a, 0, b, 1)$操作表示$a = b$这个关系，而加上$addClause(a, 1, b, 1)$操作表示则表示$a = b = 1$。 对于Or操作其实与And操作是一样的： 当$c = 0$ 时，$a, b$必须满足$a = 0 且 b = 0$，所以加入边$a \\rightarrow \\neg a \\wedge b \\rightarrow \\neg b$，表示出来就是转换成为$addClause$操作就是$addClause(a, 0, b, 0),\\ \\ \\ addClause(a, 1, b, 0), \\ \\ \\ addClause(a, 0, b, 1)$。 当$c = 1$ 时，$a, b$满足不能同时为$0$，表示为$addClause(a, 1, b, 1)$。 而Xor操作稍微有一些不同： 当$c = 0$ 时，$a, b$必须满足$a = b$，所以加入边$addClause(a, 0, b, 1), \\ \\ \\ addClause(a, 1, b, 0)$。 当$c = 1$ 时，$a, b$必须满足$a\\neq b$，所以加入边$addClause(a, 1, b, 1), \\ \\ \\ addClause(a, 0, b, 0)$。 如果还不理解的话就自己模拟一下就可以了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//POJ 3678 Katu Puzzle//2017/5/22 16:50//2-SAT#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int MAX_M = 1000000 + 3;const int INF = 0x3f3f3f3f;int n, m;vector&lt;int&gt; G[MAX_M &lt;&lt; 1];int S[MAX_M &lt;&lt; 1], c;bool mark[MAX_M &lt;&lt; 1];namespace TwoSAT&#123; void init(int n)&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); ++i) G[i].clear(); memset(mark, 0, sizeof mark); &#125; void addClause(int x, int xval, int y, int yval)&#123; x = (x &lt;&lt; 1) + xval; y = (y &lt;&lt; 1) + yval; G[x^1].push_back(y); G[y^1].push_back(x); &#125; bool dfs(int x)&#123; if(mark[x^1]) return false; if(mark[x]) return true; mark[x] = true; S[c++] = x; for(int i = 0; i &lt; G[x].size(); ++i) if(!dfs(G[x][i])) return false; return true; &#125; bool solve()&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); i += 2)&#123; if(!mark[i] &amp;&amp; !mark[i + 1])&#123; c = 0; if(!dfs(i))&#123; while(c &gt; 0) mark[S[--c]] = false; if(!dfs(i + 1)) return false; &#125; &#125; &#125; return true; &#125;&#125;using namespace TwoSAT;int main()&#123;#ifndef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(), m = readIn(); init(n); for(int i = 0; i &lt; m; ++i)&#123; int a, b, c; char opt[10]; a = readIn(), b = readIn(), c = readIn(), scanf(\"%s\", opt); //printf(\"%d %d %d %s\\n\", a, b, c,opt); if(opt[0] == 'A')&#123; if(c == 1)&#123; addClause(a, 1, b, 0); addClause(a, 0, b, 1); addClause(a, 1, b, 1); &#125; else addClause(a, 0, b, 0); &#125; else if(opt[0] == 'O')&#123; if(c == 0)&#123; addClause(a, 0, b, 0); addClause(a, 1, b, 0); addClause(a, 0, b, 1); &#125; else addClause(a, 1, b, 1); &#125; else if(opt[0] == 'X')&#123; if(c == 1)&#123; addClause(a, 0, b, 0); addClause(a, 1, b, 1); &#125; else&#123; addClause(a, 0, b, 1); addClause(a, 1, b, 0); &#125; &#125; &#125; if(solve()) printf(\"YES\\n\"); else printf(\"NO\\n\"); return 0;&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://yoursite.com/tags/2-SAT/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"位运算","slug":"位运算","permalink":"http://yoursite.com/tags/位运算/"},{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"2-SAT 问题","slug":"2-SAT问题","date":"2017-05-24T16:21:22.000Z","updated":"2017-06-04T09:07:55.405Z","comments":true,"path":"2017/05/25/2-SAT问题/","link":"","permalink":"http://yoursite.com/2017/05/25/2-SAT问题/","excerpt":"定义现有$n$个布尔变量 $x_{i}$，给出一些限制关系，比如$x_{1}$为真或者$x_{2}$为假、$x_{3}$为真或者$x_{4}$为真等（注意这里的‘或’是指至少有一个条件成立），2-SAT问题是要确定$n$个布尔变量的值，使得其满足所有限制关系。特别的，若每种限制关系中最多只对两个元素进行限制，则称为2-SAT问题。我们这里讨论$2-SAT$问题。n-SAT问题在$(n &gt; 2)$目前是没有多项式时间内的算法，是NP问题。通常我们都利用合取范式来抽象的描述我们需要求解的布尔方程。如$(a\\vee \\neg b) \\wedge (b \\vee c) \\wedge (\\neg c \\vee \\neg a)$。 其中$\\vee$为析取，即$(a \\parallel b)$只要$a, b$中满足任意一个值为真即可 $\\wedge$为合取， 即$(a \\ \\&amp;\\&amp; \\ b)$只要$a, b$均为真则成立 $\\neg$简单来说就相当于取反 所以这个合取范式当$a$和$b$为真而$c$为假的时候成立。","text":"定义现有$n$个布尔变量 $x_{i}$，给出一些限制关系，比如$x_{1}$为真或者$x_{2}$为假、$x_{3}$为真或者$x_{4}$为真等（注意这里的‘或’是指至少有一个条件成立），2-SAT问题是要确定$n$个布尔变量的值，使得其满足所有限制关系。特别的，若每种限制关系中最多只对两个元素进行限制，则称为2-SAT问题。我们这里讨论$2-SAT$问题。n-SAT问题在$(n &gt; 2)$目前是没有多项式时间内的算法，是NP问题。通常我们都利用合取范式来抽象的描述我们需要求解的布尔方程。如$(a\\vee \\neg b) \\wedge (b \\vee c) \\wedge (\\neg c \\vee \\neg a)$。 其中$\\vee$为析取，即$(a \\parallel b)$只要$a, b$中满足任意一个值为真即可 $\\wedge$为合取， 即$(a \\ \\&amp;\\&amp; \\ b)$只要$a, b$均为真则成立 $\\neg$简单来说就相当于取反 所以这个合取范式当$a$和$b$为真而$c$为假的时候成立。当只有少量合取表达式的时候我们可以手算，当存在很多个合取表达式的时候我们就要尝试用程序和思维来帮助我们实现。 解法2-SAT问题难在建模，所以一般来说不会在时间上卡你，故用一种较为简洁，较好理解的方法就可以了，不需要那么麻烦。首先最重要的一定要记住2-SAT 问题添加的条件只能是 ‘或’ ，即两个之中有一个成立即可，但我们可以通过添加多条‘或’语句，来表示其他逻辑关系。因此我们先由如何建模开始，首先我们要建立一个图首先要定义图中的点和边。图中的点一般而言都是题目中的集合中的两个不能共存的元素，比如飞机降落时早降的时间和晚降的时间、位运算中$a \\bigoplus b = c$中的$a, b$；而图中的边一般为有向边表示只要满足条件1则一定可以满足条件2。 现在我们就要对于实际问题来建立图中的点和边。 构造一张有向图G，其中每一个变量$X_{i}$拆成两个结点$2i$和$2i + 1$，分别表示$X_{i}$为假和$X_{i}$为真。最后要为每一个变量选择其中一个结点标记，若标记结点$2i$表示$X_{i}$为假，反之若标记结点$2i + 1$表示$X_{i}$为真。 对于“$X_{i}$为假或$X_{j}$假”这样的条件用合取范式来表示就是$\\neg X_{i}\\vee \\neg X_{j}$，我们将限制条件拆分成为如果A成立那么B成立来表示就是$X_{i} \\Rightarrow \\neg X_{j} \\wedge X_{j} \\Rightarrow \\neg X_{i}$，所以这里连边$X_{i} \\rightarrow \\neg X_{j}$和$X_{j} \\rightarrow \\neg X_{i}$，用刘汝佳的建图方式就表示为$addClause(a, 0, b, 0)$，表示如果$X_{i}$为真那么$X_{j}$必须为假条件才成立，同理$X_{j}$为真那么$X_{i}$必须为假条件才成立。这条有向边相当于推导出的意思，对于其他的情况我们也可以类似连边。换句话说，每一个体检对应两条对称的边。 接下来注意考虑每个没有赋值的变量，设为$X_{i}$。我们先假定它为假，然后标记结点$2i$，并且沿这条有向边标记所有能标记的结点。如果标记过程中发现某个变量对应的两个结点都被标记，则$X_{i}$为假这个条件不成立，需要改成$X_{i}$为真，然后重新标记。注意，这里改为$X_{i}$为真继续尝试，并不是代表回溯的过程，而是打了标记的点重新设为没有被标记，如果回溯的话，时间复杂度爆炸。如果当前考虑的变量赋值不管为真还是为假都会引发矛盾，那么可以证明整个2-SAT问题无解。 拓展 - 条件 对应语句 1 $a = b$ $addClause(a, 1, b, 0);\\ \\ \\ \\ addClause(a, 0, b, 1);$ 2 $a \\neq b$ $addClause(a, 0, b, 0); \\ \\ \\ addClause(a, 1, b, 1);$ 3 $a = b = true$ $addClause(a, 1, b, 1); \\ \\ addClause(a, 0, b, 1); \\ \\ \\ addClause(a, 1, b, 0);$ 4 $a = b = false$ $addClause(a, 0, b, 0); \\ \\ addClause(a, 1, b, 0); \\ \\ addClause(a, 0, b, 1);$ $a \\neq b$等价于$a \\ \\ xor \\ \\ b = true$，同理$a = b$等价于$a \\ \\ xor \\ \\ b = false$。 模板（代码）1234567891011121314151617181920212223242526272829303132333435363738394041namespace TwoSAT&#123; vector&lt;int&gt; G[MAX_N &lt;&lt; 1];//节点数为 2 * n int S[MAX_N &lt;&lt; 1], c;//S为栈，用于反悔。c 为栈大小 bool mark[MAX_N &lt;&lt; 1];//表示是否选中 void init(int n)&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); ++i) G[i].clear(); memset(mark, 0, sizeof mark); &#125; //x == xval || y == yval void addClause(int x, int xval, int y, int yval)&#123; x = (x &lt;&lt; 1) + xval; y = (y &lt;&lt; 1) + yval; G[x^1].push_back(y); G[y^1].push_back(x); &#125; bool dfs(int x)&#123; if(mark[x^1]) return false;//如果另一个节点已经被选，那么不能成立！ if(mark[x]) return true; S[c++] = x;//入栈 mark[x] = true;//选中 for(int i = 0; i &lt; G[x].size(); ++i) if(!dfs(G[x][i])) return false;//从当前点出发，沿着有向边标记所有能标记的节点 return true; &#125; bool solve()&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); i += 2)&#123; if(!mark[i] &amp;&amp; !mark[i + 1])&#123;//找到还没被标记的变量 c = 0;//栈清空 if(!dfs(i))&#123;//如果尝试 false 不行，反悔到之前的情况，尝试 true while(c &gt; 0) mark[S[--c]] = false;//退栈，反悔 if(!dfs(i + 1)) return false; &#125; &#125; &#125; return true; &#125;&#125;using namespace TwoSAT; 例题POJ 3678 Katu Puzzle题目地址运用扩展中的内容如果不理解扩展中由条件到加边是如何过来的的一看一下，毕竟当时我是绕了好久才绕过来的，这道题是2-SAT模板题，可以用来练简单的建模。POJ 3678 Katu Puzzle解题报告 POJ 3207 - Ikki’s Story IV - Panda’s Trick题目地址 和Sengxian学长讲的一样，题义明白了，那么看图就可以懂了，若会相交，则一定是是在圆内或者圆外相交，若一条线在圆内一条线在圆外这种情况下不会相交。那么圆内表示为0，圆外表示为1；如果一条线在圆外，另一条线一定在圆内，反之亦然。 UVa 1146 - Now or laterUVa 1146 - Now or later解题报告 UVa 1391 - AstronautsUVa 1391 - Astronauts解题报告未待续完","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"2-SAT","slug":"2-SAT","permalink":"http://yoursite.com/tags/2-SAT/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"}]},{"title":"BZOJ 1823: [JSOI2010]满汉全席","slug":"BZOJ-1823-JSOI2010-满汉全席","date":"2017-05-24T11:30:51.000Z","updated":"2017-05-28T04:33:10.963Z","comments":true,"path":"2017/05/24/BZOJ-1823-JSOI2010-满汉全席/","link":"","permalink":"http://yoursite.com/2017/05/24/BZOJ-1823-JSOI2010-满汉全席/","excerpt":"题目地址 描述满汉全席是中国最丰盛的宴客菜肴，有许多种不同的材料透过满族或是汉族的料理方式，呈现数量繁多的菜色之中。由于菜色众多而繁杂，只有极少数博学多闻技艺高超的厨师能够做出满汉全席，而能够烹饪出经过专家认证的满汉全席，也是中国厨师最大的荣誉之一。 世界满汉全席协会是由能够做出满汉全席的专家厨师们所组成，而他们之间还细分为许多不同等级的厨师。为了招收新进的厨师进入世界满汉全席协会，将于近日举办满汉全席大赛，协会派遣许多会员当作评审员，为的就是要在参赛的厨师之中，找到满汉料理界的明日之星。大会的规则如下：每位参赛的选手可以得到$n$种材料，选手可以自由选择用满式或是汉式料理将材料当成菜肴。大会的评审制度是：共有$m$位评审员分别把关。每一位评审员对于满汉全席有各自独特的见解，但基本见解是，要有两样菜色作为满汉全席的标志。如某评审认为，如果没有汉式东坡肉跟满式的涮羊肉锅，就不能算是满汉全席。但避免过于有主见的审核，大会规定一个评审员除非是在认为必备的两样菜色都没有做出来的状况下，才能淘汰一位选手，否则不能淘汰一位参赛者。换句话说，只要参赛者能在这两种材料的做法中，其中一个符合评审的喜好即可通过该评审的审查。","text":"题目地址 描述满汉全席是中国最丰盛的宴客菜肴，有许多种不同的材料透过满族或是汉族的料理方式，呈现数量繁多的菜色之中。由于菜色众多而繁杂，只有极少数博学多闻技艺高超的厨师能够做出满汉全席，而能够烹饪出经过专家认证的满汉全席，也是中国厨师最大的荣誉之一。 世界满汉全席协会是由能够做出满汉全席的专家厨师们所组成，而他们之间还细分为许多不同等级的厨师。为了招收新进的厨师进入世界满汉全席协会，将于近日举办满汉全席大赛，协会派遣许多会员当作评审员，为的就是要在参赛的厨师之中，找到满汉料理界的明日之星。大会的规则如下：每位参赛的选手可以得到$n$种材料，选手可以自由选择用满式或是汉式料理将材料当成菜肴。大会的评审制度是：共有$m$位评审员分别把关。每一位评审员对于满汉全席有各自独特的见解，但基本见解是，要有两样菜色作为满汉全席的标志。如某评审认为，如果没有汉式东坡肉跟满式的涮羊肉锅，就不能算是满汉全席。但避免过于有主见的审核，大会规定一个评审员除非是在认为必备的两样菜色都没有做出来的状况下，才能淘汰一位选手，否则不能淘汰一位参赛者。换句话说，只要参赛者能在这两种材料的做法中，其中一个符合评审的喜好即可通过该评审的审查。如材料有猪肉，羊肉和牛肉时，有四位评审员的喜好如下表： - 评审一 评审二 评审三 评审四 1 满式牛肉 满式猪肉 汉式牛肉 汉式牛肉 2 汉式猪肉 满式羊肉 汉式猪肉 满式羊肉 如参赛者甲做出满式猪肉，满式羊肉和满式牛肉料理，他将无法满足评审三的要求，无法通过评审。而参赛者乙做出汉式猪肉，满式羊肉和满式牛肉料理，就可以满 足所有评审的要求。 但大会后来发现，在这样的制度下如果材料选择跟派出的评审员没有特别安排好的话，所有的参赛者最多只能通过部分评审员的审查而不是全部，所以可能会发生没有人通过考核的情形。如有四个评审员喜好如下表时，则不论参赛者采取什么样的做法，都不可能通过所有评审的考核： - 评审一 评审二 评审三 评审四 1 满式羊肉 满式猪肉 汉式羊肉 汉式羊肉 2 汉式猪肉 满式羊肉 汉式猪肉 汉式猪肉 所以大会希望有人能写一个程序来判断，所选出的$m$位评审，会不会发生 没有人能通过考核的窘境，以便协会组织合适的评审团。 分析题面很长，但是仔细分析以后可以提炼出来一下几点： 对于每一种材料只能选择一种料理方式；选了满式就不能选汉式，选了汉式就不能选满式。 对于每一个评委的要求满足其中一个即可，可表示为$x == xval || y == yval$， 如果$x$如果不能满足评委，那么就必须让$y$满足评委；同理，如果$y$如果不能满足评委，那么就必须让$x$满足评委。 那么分类讨论： 存在$m_{a}$和$h_{b}$，如果存在$m_{a}$不满足评委，那么一定让$h_{b}$满足评委，转换一下就是如果存在$h_{a}$就一定存在$h_{b}$；如果存在$m_{b}$则一定存在$m_{a}$。 存在$h_{a}$和$h_{b}$，如果存在$m_{a}$就一定存在$h_{b}$；如果存在$m_{b}$则一定存在$h_{a}$。 存在$m_{a}$和$m_{b}$，如果存在$h_{a}$就一定存在$m_{b}$；如果存在$h_{b}$则一定存在$m_{a}$。 存在$h_{a}$和$m_{b}$，如果存在$m_{a}$就一定存在$m_{b}$；如果存在$h_{b}$则一定存在$h_{a}$。 根据$2-SAT$的定义，我们用一条有向边$i\\rightarrow j$来表示选$i$的情况下，一定要选$j$，然后我们根据分类讨论出来的情况连边就可以了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//BZOJ 1823: [JSOI2010]满汉全席//2017/5/23 16:09//2-SAT#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int MAX_M = 10000 + 3;const int INF = 0x3f3f3f3f;int testCase;int n, m;vector&lt;int&gt; G[MAX_M &lt;&lt; 1];int S[MAX_M], c;int mark[MAX_M &lt;&lt; 1];char str1[MAX_M], str2[MAX_M];namespace TwoSAT&#123; void init(int n)&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); ++i) G[i].clear(); memset(mark, 0, sizeof mark); &#125; void addClause(int x, int xval, int y, int yval)&#123; x = (x &lt;&lt; 1) + xval; y = (y &lt;&lt; 1) + yval; G[x^1].push_back(y); G[y^1].push_back(x); &#125; bool dfs(int x)&#123; if(mark[x^1]) return false; if(mark[x]) return true; mark[x] = true; S[c++] = x; for(unsigned int i = 0; i &lt; G[x].size(); ++i) if(!dfs(G[x][i])) return false; return true; &#125; bool solve()&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); i += 2)&#123; if(!mark[i] &amp;&amp; !mark[i + 1])&#123; c = 0; if(!dfs(i))&#123; while(c &gt; 0) mark[S[--c]] = false; if(!dfs(i + 1)) return false; &#125; &#125; &#125; return true; &#125;&#125;using namespace TwoSAT;int main()&#123;#ifndef DEBUG freopen(\"test.in\", \"r\", stdin);#endif testCase = readIn(); while(testCase--)&#123; n = readIn(), m = readIn(); init(n); for(int i = 0; i &lt; n; ++i)&#123; addClause(i, 1, i, 0); addClause(i, 0, i ,1); &#125; for(int i = 1; i &lt;= m; ++i)&#123; scanf(\"%s%s\", str1, str2); //printf(\"%s %s\\n\", str1, str2); int x, y; sscanf(str1 + 1, \"%d\", &amp;x); sscanf(str2 + 1, \"%d\", &amp;y); x--; y--; //printf(\"%d %d\\n\", x, y); if(str1[0] == 'h' &amp;&amp; str2[0] == 'h') addClause(x, 1, y, 1); else if(str1[0] == 'h' &amp;&amp; str2[0] == 'm') addClause(x, 1, y, 0); else if(str1[0] == 'm' &amp;&amp; str2[0] == 'h') addClause(x, 0, y, 1); else addClause(x, 0, y, 0); &#125; if(solve()) printf(\"GOOD\\n\"); else printf(\"BAD\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://yoursite.com/tags/2-SAT/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"}]},{"title":"WHEZOJ 83 - 棋子","slug":"WHEZOJ-83-棋子","date":"2017-05-23T16:56:40.000Z","updated":"2017-06-29T02:55:44.567Z","comments":true,"path":"2017/05/24/WHEZOJ-83-棋子/","link":"","permalink":"http://yoursite.com/2017/05/24/WHEZOJ-83-棋子/","excerpt":"描述$n$个有一面是黑色的棋子排成一排， 从$1$到$n$编号， 一开始有的棋子黑色面朝上，有的朝下。 接下来第$1$秒， 把所有编号为$1$的倍数的棋子翻转； 第$2$秒， 把所有编号为$2$的倍数的棋子翻转； 第$3$秒， 把所有编号为$3$的倍数的棋子翻转…… 这样的操作一直持续了$n$秒。现在想知道$n$秒后一共有多少个棋子是黑色朝上。第一行输入一个整数$n$，表示棋子的数量。第二行输入$3$个整数$a_1,p,q$，对于$2\\leq i\\leq n$，$a_{i} = ((a_{i - 1} \\times p + q) \\ mod\\ (10^{9} + 7)) mod \\ 2$。表示若$a_{i}$为$1$，表示最开始第$i$个棋子黑色面朝上，为$0$则表示朝下。","text":"描述$n$个有一面是黑色的棋子排成一排， 从$1$到$n$编号， 一开始有的棋子黑色面朝上，有的朝下。 接下来第$1$秒， 把所有编号为$1$的倍数的棋子翻转； 第$2$秒， 把所有编号为$2$的倍数的棋子翻转； 第$3$秒， 把所有编号为$3$的倍数的棋子翻转…… 这样的操作一直持续了$n$秒。现在想知道$n$秒后一共有多少个棋子是黑色朝上。第一行输入一个整数$n$，表示棋子的数量。第二行输入$3$个整数$a_1,p,q$，对于$2\\leq i\\leq n$，$a_{i} = ((a_{i - 1} \\times p + q) \\ mod\\ (10^{9} + 7)) mod \\ 2$。表示若$a_{i}$为$1$，表示最开始第$i$个棋子黑色面朝上，为$0$则表示朝下。 分析子任务$3$一看就很好过呀，找了半天规律，无奈智商太低，没找出来就先打了一个$30$分的暴力。其实正解应该也不难想，还是自己太弱。正解其实就是在约数个数定理上稍微变通了一下。只有在秒数为棋子编号的约数的时候，棋子才会被翻。如果棋子原本只黑色的面朝上，那么翻偶数次之后仍然是黑色面朝上，翻奇数次后就会是白色的面朝上。所以我么现在只需要判断棋子的编号的约数个数是偶数还是奇数就可以了。假设我们现在有一颗棋子编号为$n$，我们得出正整数$n$的唯一分解式$n =p_{1}^{a^{1}}p_{2}^{a_{2}}p_{3}^{a_{3}}\\cdots p_{k}^{a_{k}}$，现在可以计算出编号为$n$的棋子的约数个数为$\\prod_{i=1}^{k}(a_{i}+1)=(a_{1}+1)(a_{2}+1)\\cdots (a_{k}+1)$，而当且仅当$a_{i}(1 \\leq i \\leq k)$为偶数的时候约数的个数才会是奇数，即$n$为平方数的时候。所以我们的答案只需要关心： 第一个棋子是否白色朝上（因为第一个棋子有且仅会翻转一次）。 有什么棋子以开始是黑色朝上的。 如果棋子原本只黑色的面朝上，那么翻偶数次之后仍然是黑色面朝上，翻奇数次后就会是白色的面朝上，答案减去编号为平方数的。 如果棋子原本只白色的面朝上，那么翻偶数次之后仍然是白色面朝上，翻奇数次后就会是黑色的面朝上，答案加上编号为平方数的。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 10000000 + 3;const int MOD = 1000000000 + 7;;int n;LL a[MAX], p, q;//int ans = 0;int main()&#123; freopen(\"chess.in\",\"r\",stdin); freopen(\"chess.out\",\"w\",stdout); n = readIn(); scanf(\"%lld%lld%lld\", &amp;a[1], &amp;p, &amp;q); if(!a[1]) ans++;//only reverse once for(int i = 2; i &lt;= n; i++)&#123; a[i] = ((a[i - 1] * p + q) % MOD) &amp; 1; if(a[i]) ans++; &#125; for(int i = 2; i * i &lt;= n; i++)&#123; if(a[i * i]) ans--; else ans++; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"约数个数定理","slug":"约数个数定理","permalink":"http://yoursite.com/tags/约数个数定理/"}]},{"title":"[模板]高斯消元法","slug":"模板-高斯消元法","date":"2017-05-23T16:54:58.000Z","updated":"2017-05-23T16:56:09.801Z","comments":true,"path":"2017/05/24/模板-高斯消元法/","link":"","permalink":"http://yoursite.com/2017/05/24/模板-高斯消元法/","excerpt":"高斯消元法 (Gaussian Elimination)，是线性代数中的一个算法，可用来为线性方程组求解。","text":"高斯消元法 (Gaussian Elimination)，是线性代数中的一个算法，可用来为线性方程组求解。 推导假设现在有如下的方程组：现在把方程组写为矩阵形式为：然后我们我们可以对方程组进行3种操作而不改变方程组的解集： 交换两行。 把第i行乘以一个非$0$系数$k$。即对于$j=1\\cdots n$， 令$a_{ij} = k \\times a_{ij}, b_{i}=k \\times b_{i}$。 把第$p$行乘以一个非$0$系数$k$之后加在第$i$行上。即对于$j=1\\cdots n$， 令$a_{ij} = a_{ij} + k \\times a_{pj}, b_{i}=b_{i} + k \\times p_{i}$。 以上三个操作叫做初等行变换。我们可以使用它们，对矩阵中的$a_{ij}$进行加减乘除变换。如图所示是一个栗子： 实现的时候简单来说就是，从上到下依次处理每一行，处理完第$i$行后，让$A_{ii}$非$0$，而$A_{ji}$均为$0$，其中最后一个增广矩阵的系数部分是上三角阵。 方程的解的情况上面的过程，描述了一个美好的过程，不错，若有$n$个方程，$n$个未知数，要是我们每次都能选定一个未知数，且总有一个且之前未选过的方程使得这个未知数的系数不为 $0$，那么所有的方程就一定会变成仅包含一个未知数的形式。所以，每次都能选定一个未知数是方程有解的充分必要条件！但是有时候方程并不是那么美好，在解方程的过程中一样需要找出无解的情况并舍去。 情况一：存在矛盾方程假设现在有一个含有两个未知数的线性方程组：$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ a + 3b = 7 \\cdots \\cdots 方程1$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 2a + 6b = 10 \\cdots \\cdots 方程2$我们模拟高斯消元的过程先消去$a$，用方程$2$乘以$\\frac{1}{2}$减去方程$1$，得:$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ a + 3b = 7 \\cdots \\cdots 方程1$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 0a + 0b = -2 \\cdots \\cdots 方程2$$0x + 0y = -2$，这个方程显然是不成立的。所以我们得出结论：不难得出，存在矛盾方程当且仅当有一方程问未知数系数全为 0，但等号右边却不为 0。 存在自由变量关于自由变量学长是这么解释的高斯消元法。就是有重复的方程，即方程之间存在倍数关系，比如：$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ a + 3b = 5 \\cdots \\cdots 方程1$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 2a + 6b = 10 \\cdots \\cdots 方程2$按照高斯消元的过程执行之后，得到的：$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ a + 3b = 5 \\cdots \\cdots 方程1$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 0a + 0b = 0 \\cdots \\cdots 方程2$这样的方程组中有两个变量却只有一个方程，可见这个方程组在某些方面上相当于一个不定方程组了，这时我们说，自由变量有$1$个，因为确定任何一个变量，整个方程就解出来了。引申到矩阵上是当且仅当所有行的向量是线性无关的时候方程组才有解，线性无关指的是，一行向量不得由矩阵中的其他行向量通过加、减和数乘得到。 代码说实话，我不是很喜欢高斯-约旦消元法，所以我写的就是一般的消元法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int max_n = 500 + 3;const int max_m = 1000 + 3;const double eps = 1e-6;//一般还是取1e-6或1e-7int n, m;typedef double Matrix[max_m][max_n];double b[max_m];int ans[max_n];int gauss(Matrix a, int n, int m)&#123; for(int i = 1; i &lt;= n; ++i)&#123; int idx = 0;//行的编号 for(int j = i; j &lt;= m; ++j) if(fabs(a[j][i]) &gt; fabs(a[idx][i])) idx = i; if(!idx) return 2;//无数解 swap(i, idx);//交换行的编号 //与第i + 1 ~ m行进行消元 for(int j = i + 1; j &lt;= m; ++j)&#123; double f = 1.0 * a[j][i] / a[i][i]; for(int k = 1; k &lt;= n; ++k) a[j][k] -= a[i][k] * f; b[j] -= b[i] * f; &#125; &#125; //未知数系数全为0，而常数项不为0；无解 for(int i = 1; i &lt;= m; ++i)&#123; bool flag = true; for(int j = 1; j &lt;= n; ++j) if(fabs(a[i][j]) &gt;= eps) flag = false; if(flag &amp;&amp; fabs(b[i]) &lt; eps) flag = false; if(flag) return 0; &#125; for(int i = n; i &gt;= 1; --i)&#123; for(int j = i+1; j &lt;= n; ++j)&#123; b[i] -= a[i][j] * ans[j]; a[i][j] = 0; &#125; ans[i] = b[i] / a[i][i] + 0.5; &#125; return 1;&#125;Matrix a;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif n = readIn(), m = readIn(); for(int i = 1; i &lt;= m; ++i)&#123; for(int j = 1; j &lt;= n; ++j) a[i][j] = readIn(); b[i] = readIn(); &#125; int flag = gauss(a, n, m); if(flag == 1) for(int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", ans[i]); else if(flag == 0) puts(\"No solutions\"); else puts(\"Many solutions\"); return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://yoursite.com/tags/高斯消元/"}]},{"title":"UVa 11997 - K Small Sums","slug":"UVa-11997-K-Small-Sums","date":"2017-05-23T16:53:36.000Z","updated":"2017-05-28T04:32:38.688Z","comments":true,"path":"2017/05/24/UVa-11997-K-Small-Sums/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-11997-K-Small-Sums/","excerpt":"题目地址 描述有$k$个整数数组，各包含$k$个元素。在每一个数组中组一个元素加起来，可以得到$k^{k}$个和。求这些和中最小的$k$个值（重复的只算多次）。输入包含$k$组数据$(1 \\leq k \\leq 750)$，以下$k$行包含$k$个不大于$10^{6}$的正整数。输出$k$个最小和的值。","text":"题目地址 描述有$k$个整数数组，各包含$k$个元素。在每一个数组中组一个元素加起来，可以得到$k^{k}$个和。求这些和中最小的$k$个值（重复的只算多次）。输入包含$k$组数据$(1 \\leq k \\leq 750)$，以下$k$行包含$k$个不大于$10^{6}$的正整数。输出$k$个最小和的值。 分析还是从小规模的入手，考虑有两个有序序列$A, B$，$A, B$中各有$n$个元素，现在要求从序列$A, B$中各取一个数相加，求出所有的$n_{2}$的和中最小的$n$个。那么这个问题可以转化成为多路归并问题，这样就有$n$个有序表，这$n$个有序表一定满足：$表1：A_{1}+B_{1}\\leq A_{1}+B_{2}\\leq \\cdots \\leq A_{1}+B_{n}$$表2：A_{2}+B_{1}\\leq A_{2}+B_{2}\\leq \\cdots \\leq A_{2}+B_{n}$$表3：A_{3}+B_{1}\\leq A_{3}+B_{2}\\leq \\cdots \\leq A_{3}+B_{n}$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\vdots$$表n：A_{n}+B_{1}\\leq A_{1}+B_{2}\\leq \\cdots \\leq A_{n}+B_{n}$这里第一列的$n$个和就是我们所求的所有的$n^{2}$的和中最小的$n$个。首先最小的一定是$A_{1}+B_{1}$ ，但问题求最小的$n$个和，那第二小的是谁呢？显然只可能存在于剩下的数列的第一个和以及数列一的第二个和中，我们可以知道，如果一个数列的前一个位置没有被选中，那么这个数列后面的数也不可能被选中。所以我们建立一个优先队列（最小堆），一开始 $push$ 进去所有数列的第一个数，如果某一个和出队，它一定是当前最小和。接着它所在的数列在它后面的一个和就要进队。第$i$次出队得到第$i$小的和，队列总是有$n$个和，复杂度$\\Theta (nlogn)$ 。这被称为多路归并问题。那么这个题目也就不难解决了，根据贪心思想，将表两两合并，就能得到最小的$n$个和。我们令表$a$中的元素形为$A_{a} + B_{b}$，$s = A_{a} + B_{b}$，这样可以用一个二元组$(s, b)$来表示一个元素，表$a$中的下一个元素是$(s’, b + 1)$，其中$s’ = A_{a} + B_{b + 1} = s - B_{b} + B_{b + 1}$。因此我们根本用不到a呀！其实就是把$k$个有序表，两两合并生成新的表，然后维护每个表中的当前元素，相当于程序中的$merge$，所以$merge$的时间复杂度为$\\Theta (nlogn)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 750 + 3;int k;int A[MAX][MAX];struct Node&#123; int s, b; Node(int s = 0, int b = 0) : s(s), b(b) &#123;&#125; bool operator &lt; (const Node&amp; rhs) const&#123; return s &gt; rhs.s; &#125;//priority_queue的优先级&#125;;void merge(int* A, int* B, int *C, int n)&#123; priority_queue&lt;Node&gt; pq; for(int i = 0; i &lt; n; i++) pq.push(Node(A[i] + B[0], 0)); for(int i = 0; i &lt; n; i++)&#123; Node node = pq.top(); pq.pop(); C[i] = node.s; if(node.b + 1 &lt; k) pq.push(Node(node.s - B[node.b] + B[node.b + 1], node.b + 1)); &#125;&#125;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif while(scanf(\"%d\", &amp;k) != EOF)&#123; memset(A, 0, sizeof A); for(int i = 0; i &lt; k; i++)&#123; for(int j = 0; j &lt; k; j++) scanf(\"%d\", &amp;A[i][j]); sort(A[i], A[i] + k); &#125; for(int i = 1; i &lt; k; i++) merge(A[0], A[i], A[0], k); printf(\"%d\", A[0][0]); for(int i = 1; i &lt; k; i++) printf(\" %d\", A[0][i]);// printf(\"\\n\"); &#125; return 0;&#125; 一道思想类似的题目1203 - Argus","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"多路归并问题","slug":"多路归并问题","permalink":"http://yoursite.com/tags/多路归并问题/"},{"name":"优先队列","slug":"优先队列","permalink":"http://yoursite.com/tags/优先队列/"}]},{"title":"UVa 1401 - Remember the Word & UVa 11732 - strcmp Anyone?","slug":"UVa-1401-Remember-the-Word-UVa-11732-strcmp-Anyone","date":"2017-05-23T16:51:38.000Z","updated":"2017-05-28T04:31:14.001Z","comments":true,"path":"2017/05/24/UVa-1401-Remember-the-Word-UVa-11732-strcmp-Anyone/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-1401-Remember-the-Word-UVa-11732-strcmp-Anyone/","excerpt":"$UVa 1401 - Remember \\ the \\ Word$UVa 1401题目地址 描述给出一个由$S$个不同单词组成的字典一个长字符串。把这个字符串分解成若干的单词的连接（单词可以重复使用），有多少种方法？输入包含多组数据。每组数据为小写字母组成的待分解的字符串，长度$L$不超过$300000$。第二行单词个数为$S(1 \\leq S \\leq 4000)$。以下$S$行为一个长度不超过$100$由小写字母组成的单词。","text":"$UVa 1401 - Remember \\ the \\ Word$UVa 1401题目地址 描述给出一个由$S$个不同单词组成的字典一个长字符串。把这个字符串分解成若干的单词的连接（单词可以重复使用），有多少种方法？输入包含多组数据。每组数据为小写字母组成的待分解的字符串，长度$L$不超过$300000$。第二行单词个数为$S(1 \\leq S \\leq 4000)$。以下$S$行为一个长度不超过$100$由小写字母组成的单词。 分析用指针实现的比数组稍微快一点儿吧。。。很容易想到一道关于字符串的动态规划。我们令$d(i)$表示从字符$i$开始的字符串的分解方案数（即后缀$S[i…L]$）。我们通过递推式定义可以推导出递推方程$d(i) = sum(d(i + len(x)) \\mid x为S[i…L]的前缀 )$，递推时一定要注意递推的边界。在推导递推式的时候我们要判断$x$是否为$S[i…L]$的前缀，如果我们要来枚举的话在最坏的情况下我们要依次判断$4000$个单词，每一个单词长度最坏的情况下将长达$100$，我们显然无法在一定的时间范围中的出结果。这时候我们想到把所有的单词先组织成一颗$Trie$，然后试着在$Trie$中来判断$x$是否为$S[i…L]$的前缀。查找过程中我们每经过一个单词结点，就找到上述状态转移方程中的$x$，最多只需要比较$100$次就能找到所有的$x$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXNODE = 4000 * 100 + 3;const int SIGMA_SIZE = 26;const int maxl = 300000 + 3;// 文本串最大长度const int maxw = 4000 + 3;// 文本串最大长度const int maxwl = 100 + 3;// 文本串最大长度const int MOD = 20071027;int d[maxl], len[maxw], S;char text[maxl], word[maxwl];struct Trie&#123; struct Node&#123; Node *ch[SIGMA_SIZE]; int val; &#125;pool[MAXNODE], *pit, *root; void init()&#123; pit = pool, root = pit++; root-&gt;val = 0; memset(root-&gt;ch, 0, sizeof root-&gt;ch); &#125; void insert(char* s, int id)&#123; Node *cur = root; for(int i = 0; s[i]; ++i)&#123; int c = s[i] - 'a'; if(!cur-&gt;ch[c])&#123; memset(pit-&gt;ch, 0, sizeof pit-&gt;ch); pit-&gt;val = -1; cur-&gt;ch[c] = pit++; &#125; cur = cur-&gt;ch[c]; &#125; cur-&gt;val = id; &#125; void find_prefixes(const char *s, int len, vector&lt;int&gt;&amp; ans)&#123; Node *cur = root; for(int i = 0; s[i]; i++)&#123; if(s[i] == '\\0') break; int c = s[i] - 'a'; if(!cur-&gt;ch[c]) break; cur = cur-&gt;ch[c]; if(cur-&gt;val &gt;= 0) ans.push_back(cur-&gt;val); // 找到一个前缀 &#125; &#125;&#125;trie;int main()&#123;#ifndef DBEUG //freopen(\"test.in\",\"r\",stdin);#endif int kase = 0; while(scanf(\"%s%d\", text, &amp;S) == 2)&#123; trie.init(); for(int i = 1; i &lt;= S; i++)&#123; scanf(\"%s\", word); len[i] = strlen(word); trie.insert(word, i); &#125; memset(d, 0, sizeof(d)); int L = strlen(text); d[L] = 1; for(int i = L - 1; i &gt;= 0; i--)&#123; vector&lt;int&gt; p; trie.find_prefixes(text + i, L - i, p); for(unsigned int j = 0; j &lt; p.size(); j++) d[i] = (d[i] + d[i + len[p[j]]]) % MOD; &#125; printf(\"Case %d: %d\\n\", ++kase, d[0]); &#125; return 0;&#125; $UVa 11732 - “strcmp()” \\ Anyone?$UVa 11732题目地址 描述输入$n$个字符串，两两调用一次$strcmp()$（即一共调用$\\frac{n(n - 1)}{2}$次），问字符比较的总次数是？ 分析我觉得这道题目很巧妙呀，虽然它是在$Trie$部分后面的习题，但是整道题目正解的思想很巧妙呀。只要想到用$Trie$最后一般都是可以把比较次数的式子推出来的。从这道题目的数据范围可以知道，一般的朴素暴力算法（两两比较）是效率很低的，在最坏的情况下用朴素的思想显然是不行的。那么我们把所有的字符串插入到一颗$Trie$树中呢？因为题目中字符集较大，所以我们这里用左儿子右兄弟的方式建图， 就是将多叉树转为二叉树。如图所示，这里就不解释了。这里我们还要计算一个$tot[i]$即为第$i$个结点为根的子树包含的叶结点总数，也就是有多少字符串经过这个结点。比较分为两种情况： $n$字符串两两比较一共要比较$\\frac{n(n-1)}{2}$组字符串，因为是两两比较所以比较$n(n-1)$次，若字符串两两相等（此处为完全相等，即长度与字符均相等）模拟运用$strcmp$则需要比较$n(n-1) \\cdot length$次（题目中的$length$为字符串相等长度$+1$）。 若字符串中结点$u$之前的字符串完全相等，而结点$v$之后的字符串开始不相等，因为我们前面用左儿子右兄弟的方式来存数，所以我们比较$\\frac{tot[v] \\cdot (tot[u] - tot[v])}{2}$对字符串，比较次数为$tot[v] \\cdot (tot[u] - tot[v])$，比较完最左边的儿子以后，我们找与最左边的儿子属于同一层的相邻的右兄弟，计算右兄弟与除右兄弟以外属于结点$u$的其他字符串所需要的比较次数；我们举例之后发现，这样子计算比较次数会因为重复计算而变为正常所需比较次数的两倍。最终的比较次数为$\\frac{tot[v] \\cdot (tot[u] - tot[v])}{2} \\mid v\\in u$。 这样预处理完每个结点的$tot$之后，$DFS$一次就可以了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxnode = 4000 * 1000 + 3;const int sigma_size = 26;const int maxl = 1000 + 10;int n;char word[maxl];struct Trie&#123; int head[maxnode];// head[i]为第i个结点的左儿子编号 int next[maxnode];//next[i]为第i各节点的右兄弟编号 int tot[maxnode];// tot[i]为第i个结点为根的子树包含的叶结点总数 int ch[maxnode]; int sz; LL ans; void clear()&#123; sz = 1; head[0] = next[0] = tot[0] = 0;&#125; void insert(char *s)&#123; int u = 0, v, n = strlen(s); tot[0]++; for(int i = 0; i &lt;= n; i++)&#123;//included '\\0' bool equal = false; for(v = head[u]; v != 0; v = next[v])&#123; if(ch[v] == s[i])&#123; equal = true; break; &#125; &#125; if(!equal)&#123; v = sz++; tot[v] = 0; ch[v] = s[i]; next[v] = head[u]; head[u] = v;// 插入到链表的首部 head[v] = 0; &#125; u = v; tot[u]++; &#125; &#125; void dfs(int depth, int u)&#123; if(head[u] == 0) ans += tot[u] * (tot[u] - 1) * depth; else&#123; int sum = 0; for(int v = head[u]; v != 0; v = next[v]) sum += tot[v] * (tot[u] - tot[v]); ans += sum / 2 * (2 * depth + 1); for(int v = head[u]; v != 0; v = next[v]) dfs(depth + 1, v); &#125; &#125; LL count()&#123; ans = 0; dfs(0, 0); return ans; &#125;&#125;trie;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif int kase = 0; while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n)&#123; trie.clear(); for(int i = 0; i &lt; n; i++)&#123; scanf(\"%s\", word); trie.insert(word); &#125; printf(\"Case %d: %lld\\n\", ++kase, trie.count()); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"Trie","slug":"Trie","permalink":"http://yoursite.com/tags/Trie/"},{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/树形DP/"}]},{"title":"[模板]树状数组","slug":"模板-树状数组","date":"2017-05-23T16:47:36.000Z","updated":"2017-05-23T17:09:22.376Z","comments":true,"path":"2017/05/24/模板-树状数组/","link":"","permalink":"http://yoursite.com/2017/05/24/模板-树状数组/","excerpt":"定义先学完线段树后再学树状数组比较好理解。树状数组又称为二叉索引树，可以支持以下两种操作： $Add(x, d)$操作，让$A_{i}$增加$d$。 $Query(L, R)$：计算$A_{L} + A_{L + 1} + \\cdots + A_{R}$。","text":"定义先学完线段树后再学树状数组比较好理解。树状数组又称为二叉索引树，可以支持以下两种操作： $Add(x, d)$操作，让$A_{i}$增加$d$。 $Query(L, R)$：计算$A_{L} + A_{L + 1} + \\cdots + A_{R}$。 分析我们之所以用树状数组来进行整两个操作是因为树状数组可以在$\\Theta (nlobn)$的时间复杂度下完程这两个操作，我们看树状数组时如何巧妙快速的完成的 (´▽`ʃ♡ƪ)。对于正整数$x$，我们定义$lowbit(x)$为$x$二进制表达式中最右边的$1$所对应的值。如$34 = 00100010$，那么$34$的$lowbit = 10 = 2$。我们如何快速的求出每一个数的$lowbit$呢？后面再说我们为什么要用到$lowbit$。123int lowbit(int x)&#123; x &amp; (~x + 1);&#125; 我们根据补码的特性，可以描述为123int lowbit(int x)&#123; x &amp; (-x);&#125; 现在看一下树状数组的结构吧，如图所示，这个图是我画的(੭ˊᵕˋ)੭ଘ。我们来明确图中每一个元素的意义。会的结点时$BIT$中的结点，每一层结点的$lowbit$都相同，$lowbit$越大越靠近根结点。编号$0$时虚拟结点，我们在循环中通常要从$1$开始遍历。对于结点$i$，如果$i$时左子结点，那么他父亲的编号为$i + lowbit(i)$；如果$i$为右子结点，那么他父亲的编号为$i - lowbit(i)$。现在我们引入辅助数组$C$，其中$C_{i} = A_{i - lowbit(i) + 1} + A_{i - lowbit(i) + 2} + \\cdots + A_{i}$。$C$中的每一个元素都是$A$数组中一段连续和，如：$C_{12} = A_{9} + A_{10} + A_{11} + A_{12}$。相信你看到这里，已经明白了树状数组的奥妙了吧。所以我们计算前缀和$S_{i}$，只需要顺着结点$i$一边往左走，一边往上走。如图所示，求$S_{23}$的前缀和。我们修改了一个$A_{i}$当然就要把用$A_{i}$计算的$C_{i}$的值也进行修改，*那么我一边往右走，一边往上走。如图所示，修改$A_{9}$的值。 代码现在给出树状数组的模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 100 + 3;int n;int A[MAX];inline int lowbit(int x)&#123; return x &amp; (-x);// x &amp; (~x+1);&#125;struct FenwickTree&#123; int n; vector&lt;int&gt; C; void resize(int n)&#123;//resize(x) 重新指定树状数组的大小为x, O(1), x&gt;=0 this-&gt;n = n; C.resize(n); &#125; void clear()&#123; fill(C.begin(), C.end(), 0); &#125; int sum(int x)&#123; int ret = 0; while(x &gt; 0)&#123; ret += C[x]; x -= lowbit(x); &#125; return ret; &#125; int query_sum(int x, int y)&#123; return sum(y) - sum(x - 1); &#125; void add(int x, int d)&#123; while(x &lt;= n)&#123; C[x] += d; x += lowbit(x); &#125; &#125;&#125;FT;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif scanf(\"%d\", &amp;n); int max_a = 0; for(int i = 1; i &lt;= n; i++)&#123;//from 1 to n scanf(\"%d\", &amp;A[i]); max_a = max(max_a, A[i]); &#125; FT.resize(max_a); int ans[MAX]; int Interval = 0; for(int i = 1; i &lt;= n; i++)&#123; FT.add(A[i], i); ans[i] = FT.sum(A[i]); Interval = FT.query_sum(1, 5); &#125; for(int i = 1; i &lt;= n; i++) printf(\"%d \", ans[i]); printf(\"\\n\"); printf(\"%d\\n\", Interval); return 0;&#125; 应用现在来解决一道问题吧！$UVa 1428 - Ping \\ pong$题目地址代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 20000 + 3;int n;int a[MAX], c[MAX], d[MAX];inline int lowbit(int x)&#123; return x &amp; (-x);//x &amp; (~x + 1)&#125;struct FenwickTree&#123; int n; vector&lt;int&gt; C; void resize(int n)&#123; this-&gt;n = n; C.resize(n); &#125; void clear()&#123; fill(C.begin(), C.end(), 0); &#125; int sum(int x)&#123; int ret = 0; while(x &gt; 0)&#123; ret += C[x]; x -= lowbit(x); &#125; return ret; &#125; void add(int x, int d)&#123;// while(x &lt;= n)&#123; C[x] += d; x += lowbit(x); &#125; &#125;&#125;FT;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif int T; scanf(\"%d\", &amp;T); while(T--)&#123; scanf(\"%d\", &amp;n); int max_a = 0; for(int i = 1; i &lt;= n; i++)&#123; scanf(\"%d\", &amp;a[i]); max_a = max(max_a, a[i]); &#125; FT.resize(max_a); FT.clear(); for(int i = 1; i &lt;= n; i++)&#123; FT.add(a[i], 1); c[i] = FT.sum(a[i]-1); &#125; FT.clear(); for(int i = n; i &gt;= 1; i--)&#123; FT.add(a[i], 1); d[i] = FT.sum(a[i]-1); &#125; LL ans = 0; for(int i = 1; i &lt;= n; i++) ans += (LL)c[i]*(n-i-d[i]) + (LL)(i-c[i]-1)*d[i]; printf(\"%lld\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"}]},{"title":"UVa 10881 - Piotr's Ants","slug":"UVa-10881-Piotr-s-Ants","date":"2017-05-23T16:46:04.000Z","updated":"2017-05-28T04:31:56.741Z","comments":true,"path":"2017/05/24/UVa-10881-Piotr-s-Ants/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-10881-Piotr-s-Ants/","excerpt":"题目地址 描述一根长度为$L$厘米的木棍上有$n$只蚂蚁，每只蚂蚁要么向左爬，要么向右爬，速度为$1$厘米/秒。当两只蚂蚁相撞时，二者同时掉头（掉头时间忽略不计）。给出每只蚂蚁的初始位置和朝向（单位：厘米）。字母表示初始朝向（$L$表示朝左，$R$表示朝右）。第一行输入$3$个正整数$L, T, n(0\\leq n\\leq 10000)$，以下$n$行描述一只蚂蚁的初始位置，$x$为蚂蚁距离木棍左端的距离，字母表示朝向。对于每组数据按顺序输出每只蚂蚁的位置和朝向。","text":"题目地址 描述一根长度为$L$厘米的木棍上有$n$只蚂蚁，每只蚂蚁要么向左爬，要么向右爬，速度为$1$厘米/秒。当两只蚂蚁相撞时，二者同时掉头（掉头时间忽略不计）。给出每只蚂蚁的初始位置和朝向（单位：厘米）。字母表示初始朝向（$L$表示朝左，$R$表示朝右）。第一行输入$3$个正整数$L, T, n(0\\leq n\\leq 10000)$，以下$n$行描述一只蚂蚁的初始位置，$x$为蚂蚁距离木棍左端的距离，字母表示朝向。对于每组数据按顺序输出每只蚂蚁的位置和朝向。 分析很多人把这类题目称为弹性碰撞，听起来比较玄学，但是理解以后就很简单了。先引入两个定理： 忽略个体的差异，那么两个物体相撞掉头可以看作保持原样运动擦身而过。 无论如何碰撞，物体的顺序始终与开始时相同（即相对位置不变）。我们来模拟以下样例: 输入：$10 , 2 , 3 \\mid (3, R), (5, L), (8, R)$ 输出：$(3, L), (5, R), (10, R)$图片我弄了好久QAQ首先依次读入$n$个蚂蚁的编号，位置，方向，然后根据相对位置对蚂蚁进行排序也就是图中所示的初始状态。每只蚂蚁速度均为$1$厘米/秒，模拟一秒以后的状态。$A$和$B$相撞，因为蚂蚁$A$和蚂蚁$B$其本质上都是蚂蚁，并没有任何区别(☄⊙ω⊙)☄。所以我们这里默认蚂蚁$A$和蚂蚁$B$是一样的，认为他们相撞后相当于擦肩而过，这时候$A$走$B$应该走的路，而$B$走$A$应该走的路。所以我们在给出初始状态的时候，分别计算出每个初始初始状态一一对应的末状态。以上运用定理一。因为几只蚂蚁在一根木棍是怎样相撞的，什么时候相撞的，撞了几次，这些因素对蚂蚁的相对位置是没有任何影响的，也就是定理二无论如何碰撞，物体的顺序始终与开始时相同（即相对位置不变）。已知一只蚂蚁初始位置在第$1$个，那么它的末位置也一定是在第$1$个，所以我们可以应用定理二可推出每只蚂蚁的末位置。所以我们用一个$before$和$after$的结构体来对应蚂蚁的初始状态和末状态（此时我们认为蚂蚁相撞后擦肩而过没有掉头，因此方向与初始状态方向一样，用定义的方向推出相对位置，但是此时的输入顺序是未知的），所以要再用一个数组$order$来记录初始状态时每只蚂蚁的相对位置。将$after$结构体根据相对位置排序后一一对应同样根据相对位置排序后的初始状态的序号，然后按照顺序依次输出。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 10000 + 3;const char Orientation[][10] = &#123;\"L\", \"Turning\",\"R\"&#125;;int N;int L, T, n;int order[MAX];struct Ant&#123; int id, pos, dir;//left -1, turning 0, right 1 bool operator &lt; (const Ant&amp; rhs) const&#123; return pos &lt; rhs.pos; &#125;&#125;before[MAX], after[MAX];int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin); //freopen(\"test.out\",\"w\",stdout);#endif scanf(\"%d\", &amp;N); for(int kase = 1; kase &lt;= N; kase++)&#123; printf(\"Case #%d:\\n\", kase); scanf(\"%d%d%d\", &amp;L, &amp;T, &amp;n); for(int i = 0; i &lt; n; i++)&#123; int p; char ch; scanf(\"%d %c\", &amp;p, &amp;ch);// Why need a tab here? int d = (ch == 'R' ? 1 : -1); before[i] = (Ant)&#123;i, p, d&#125;; after[i] = (Ant)&#123;0, p + T * d, d&#125;; &#125; sort(before, before + n); for(int i = 0; i &lt; n; i++) order[before[i].id] = i; sort(after, after + n); for(int i = 0; i &lt; n - 1; i++) if(after[i].pos == after[i + 1].pos) after[i].dir = after[i + 1].dir = 0; for(int i = 0; i &lt; n; i++)&#123; int a = order[i]; if(after[a].pos &lt; 0 || after[a].pos &gt; L) printf(\"Fell off\\n\"); else printf(\"%d %s\\n\", after[a].pos , Orientation[after[a].dir + 1]); &#125; printf(\"\\n\"); &#125; return 0;&#125; $Attention:$这个地方的$+1$我一直没有弄明白后面弄清楚了。其实是这样的，此时$after$数组已经按初始状态的序号一一对应了，但因为我们定义向左走为$-1$为保证输出的常量数组下标不为$-1$，所以我们这里要$+1$。1else printf(\"%d %s\\n\", after[a].pos , Orientation[after[a].dir + 1]);","categories":[],"tags":[{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"弹性碰撞","slug":"弹性碰撞","permalink":"http://yoursite.com/tags/弹性碰撞/"}]},{"title":"超大背包问题","slug":"超大背包问题","date":"2017-05-23T16:43:38.000Z","updated":"2017-05-23T16:58:47.624Z","comments":true,"path":"2017/05/24/超大背包问题/","link":"","permalink":"http://yoursite.com/2017/05/24/超大背包问题/","excerpt":"描述有重量和价值分别为$W_{i}, V_{i}$的$n$个物品。从这些物品中挑选总重量不超过$W$的物品，求所有挑选方案中价值总和最大值。$1\\leq n\\leq 40$$1\\leq w_{i},v_{i}\\leq 10^{15}$$1\\leq W\\leq 10^{15}$ 分析在一般的背包问题中，$w_{i}, v_{i}和W$一般都比较小，所以我们可以用$DP$来解决。但是现在这道题目$w_{i}, v_{i}和W$的范围都扩大了很多，因为$DP$求解背包的复杂度是$\\Theta(nW)$，所以我们从数据范围上可以判断这道题目不能使用$DP$进行求解。因为此处$n$的数据范围较小所以我们考虑从$n$来找问题的突破口。因为挑选物品的方法总共有$2^{n}$（每个物品有选与不选两种状态），我们肯定会想到枚举，但是$2^{n}$还是太大了不能直接枚举，所以我们考虑把物品的个数分为一半来枚举，这样只用枚举$2\\cdot 2^{20}$。","text":"描述有重量和价值分别为$W_{i}, V_{i}$的$n$个物品。从这些物品中挑选总重量不超过$W$的物品，求所有挑选方案中价值总和最大值。$1\\leq n\\leq 40$$1\\leq w_{i},v_{i}\\leq 10^{15}$$1\\leq W\\leq 10^{15}$ 分析在一般的背包问题中，$w_{i}, v_{i}和W$一般都比较小，所以我们可以用$DP$来解决。但是现在这道题目$w_{i}, v_{i}和W$的范围都扩大了很多，因为$DP$求解背包的复杂度是$\\Theta(nW)$，所以我们从数据范围上可以判断这道题目不能使用$DP$进行求解。因为此处$n$的数据范围较小所以我们考虑从$n$来找问题的突破口。因为挑选物品的方法总共有$2^{n}$（每个物品有选与不选两种状态），我们肯定会想到枚举，但是$2^{n}$还是太大了不能直接枚举，所以我们考虑把物品的个数分为一半来枚举，这样只用枚举$2\\cdot 2^{20}$。 我们把前半部分中的选取办法对应的重量和价值的总和记为$w_{1}, v_{1}$，然后在后半部分找满足$w_{2}\\leq W - w_{1}$对应的最大的$v_{2}$就行了。因此我们思考从枚举得到的$(w_{2}, v_{2})$的集合中高效的寻找$max(v_{2}\\mid w_{1}\\leq W’)$。首先我们可以排除所有满足$w_{2}[i] \\leq w_{2}[j] 且 v_{2}[i]\\geq v_{2}[j]$的$j$。之后剩余的元素均满足$w_{2}[i] &lt; w_{2}[j] \\Leftrightarrow v_{2}[i] &lt; v_{2}[j]$，若要计算$max(v_{2}\\mid w_{1}\\leq W’ )$，只要寻找满足$w_{2}[i] \\leq W’$的最大的$i$即可。 这个这一用二分搜索来完成。所以总的时间复杂度为$\\Theta (2^{\\frac{n}{2}}n)$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 40 + 3;int n, W;int w[MAX], v[MAX];pair&lt;int, int&gt; Interval[1 &lt;&lt; (MAX / 2)];int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif scanf(\"%d%d\", &amp;n, &amp;W); for(int i = 0; i &lt; n; i++) scanf(\"%d%d\", &amp;w[i], &amp;v[i]); int S = n / 2;//折半 for(int i = 0; i &lt; (1 &lt;&lt; S); i++)&#123; int weight = 0; int value = 0; for(int j = 0; j &lt; S; j++)&#123; if(i &gt;&gt; (j &amp; 1))&#123;//if(i &amp; (1 &lt;&lt; j)) weight += w[j]; value += v[j]; &#125; &#125; Interval[i] = make_pair(weight, value); &#125; sort(Interval, Interval + (1 &lt;&lt; S)); //去除多余元素 int m = 0; for(int i = 0; i &lt; (1 &lt;&lt; S); i++)&#123; if(Interval[m - 1].second &lt; Interval[i].second) Interval[m++] = Interval[i]; &#125; int ans = 0; for(int i = 0; i &lt; 1 &lt;&lt; (n - S); i++)&#123; int weight = 0; int value = 0; for(int j = 0; j &lt; n - S; j++)&#123; if(i &gt;&gt; (j &amp; 1))&#123;//if(i &amp; (1 &lt;&lt; j)) weight += w[S + j]; value += v[S + j]; &#125; &#125; if(weight &lt;= W)&#123; int sumv = (lower_bound(Interval, Interval + m, make_pair(W - weight, INF)) - 1)-&gt;second; ans = max(ans, value + sumv); &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125;/*输入 n = 4, W = 5; 2 3 1 2 3 4 2 2 输出 7 */","categories":[],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"折半搜索 & 双向枚举","slug":"折半搜索-双向枚举","permalink":"http://yoursite.com/tags/折半搜索-双向枚举/"}]},{"title":"UVa 11300 - Spreading the Wealth","slug":"UVa-11300-Spreading-the-Wealth","date":"2017-05-23T16:42:17.000Z","updated":"2017-05-28T04:32:18.939Z","comments":true,"path":"2017/05/24/UVa-11300-Spreading-the-Wealth/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-11300-Spreading-the-Wealth/","excerpt":"题目地址 描述圆桌旁坐着$n$个人，每人有一定数量的的金币，金币数总能被$n$整除。每个人可以给他左右相邻的人一些金币，最终使得每个人的金币数目相等。你的任务是求出被转手的金币数量的最小值。每组数据第一行为整数$n(n\\leq 1000000)$，以下$n$行每行为一个整数，按逆时针顺序给出每个人应有的金币数。输入结束标志为$EOF$。对于每组数据输出被转手金币的数量的最小值。","text":"题目地址 描述圆桌旁坐着$n$个人，每人有一定数量的的金币，金币数总能被$n$整除。每个人可以给他左右相邻的人一些金币，最终使得每个人的金币数目相等。你的任务是求出被转手的金币数量的最小值。每组数据第一行为整数$n(n\\leq 1000000)$，以下$n$行每行为一个整数，按逆时针顺序给出每个人应有的金币数。输入结束标志为$EOF$。对于每组数据输出被转手金币的数量的最小值。 分析首先我们可以先计算出最终每个人手中持有的金币数量$M$，$M$等于总金币数量除以人数$n$。假设有$4$个人，按顺序编号为$1， 2， 3， 4$。假设$1$号给$2$号$3$枚金币，然后$2$号给$1$号$5$枚金币，实际上相当于$2$号给$1$号$2$枚金币，而$1$号什么都没有给$2$号。这样，我们设$x_{2}$表示$2$号给了$1$号多少金币，如果$x_{2}$小于$0$说明$1$号给了$2$号$-x_{2}$枚金币。现在假设编号为$i$的人初始有$A_{1}$枚金币。对于$1$号，他给了$4$号$x_{1}$枚金币，还剩$A_{1} - x_{1}$枚金币；又因为$2$号给了他$x_{2}$枚金币，所以最终他剩$A_{1} - x_{1} + x_{2}$枚金币。对于剩下的人也是一样的，依次我们可以得到$n$个等式：这里我们令$C_{n} = A_{n} - M$，进行移项变为第二项是这样子变过来的$A_{2} -x_{2} +x_{3} = M\\rightarrow x_{3} = M - A_{2} + x_{2} = 2M -A_{1} -A_{2}+x_{1} = x_{1} - C_{2}$第三项同理$A_{3} -x_{3} +x_{4} = M\\rightarrow x_{4} = M - A_{3} + x_{3} = 3M -A_{1} -A_{2} - A_{3}+x_{1} = x_{1} - C_{3}$ 其实在实际应用中我们并不需要第$n$个等式，因为这道题目中题到过这是一个环形。我们希望所有的$x_{i}$的绝对值最小，即$|x_{1}| + |x_{1} - C_{1}| + |x_{1} - C_{2}| + \\cdots + |x_{1} - C_{n - 1}|$的绝对值最小。$ |x_{1} - C_{i}|$的几何意义是数轴上点$x_{1}$到$C_{i}$的距离。至此问题就变为了给定数轴上的$n$个点，找出一个到它们距离之和尽量小的点。这里我们简要的证明一下，为什么最优的的$x_{1}$是这些数的中位数。如图，任意找一个点，如图中灰色的圆，它左边有$4$个输入点，右边有$2$个输入点。当灰色的圆向左平移$d$个单位，灰点左边的$4$个点到它的距离距离各减少了$d$，而灰点右边的$2$个点各增加了$d$，总共距离减少了$2d$。当灰点右边有$4$个点左边有$2$个点的时候，同理，将灰点向右平移$d$个单位长度，距离减少$2d$。所以如果输入点的个数有奇数个，则灰点必定会与中间的那个点重合，即为中位数；当个数为偶数，那么灰点可以位于中间的两个点之间的任意位置，仍然是中位数。有许多题目中，我们转化为这个模型后，都可以用中位数进行求解。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1000000 + 3;int n;LL A[MAX];LL C[MAX];int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif while(scanf(\"%d\", &amp;n) != EOF)&#123; LL sum = 0; for(int i = 0; i &lt; n; i++)&#123; scanf(\"%lld\", &amp;A[i]); sum += A[i]; &#125; LL M = sum / n; C[0] = 0; for(int i = 1; i &lt; n; i++) C[i] = C[i - 1] + A[i] - M; sort(C, C + n); LL x1 = C[n/2], ans = 0; for(int i = 0; i &lt; n; i++) ans += abs(x1 - C[i]); printf(\"%lld\\n\", ans); &#125; return 0;&#125; 其实代码还可以进一步优化，如运用快速选择，在线性时间内求出中位数。（＾∀＾●）ﾉｼ","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"}]},{"title":"UVa 11729 - Commando War","slug":"UVa-11729-Commando-War","date":"2017-05-23T16:39:44.000Z","updated":"2017-05-28T04:32:28.566Z","comments":true,"path":"2017/05/24/UVa-11729-Commando-War/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-11729-Commando-War/","excerpt":"题目地址 描述你有$n$个部下，每个部下需要完成一项任务。第$i$个部下需要你花$B_{i}$分钟交待任务，然后他会立刻独立地、无间断地执行$J_{i}$分钟任务。你徐亚选择交待任务的顺序，使得所有任务尽早执行完毕（即最后一个执行完的任务应尽早结束）。注意，不能同时给两个部下交待任务，但是部下可以同时执行他们各自的任务。每组数据第一行$N(1\\leq N\\leq 1000)$为部下的人数。以下$N$行每一行有两个正整数$B$和$J$$(1\\leq B,J\\leq 10000)$，即交待任务的时间和完成任务的时间。输入结束标志为$N = 0$。输出完成任务所需的最短的时间。","text":"题目地址 描述你有$n$个部下，每个部下需要完成一项任务。第$i$个部下需要你花$B_{i}$分钟交待任务，然后他会立刻独立地、无间断地执行$J_{i}$分钟任务。你徐亚选择交待任务的顺序，使得所有任务尽早执行完毕（即最后一个执行完的任务应尽早结束）。注意，不能同时给两个部下交待任务，但是部下可以同时执行他们各自的任务。每组数据第一行$N(1\\leq N\\leq 1000)$为部下的人数。以下$N$行每一行有两个正整数$B$和$J$$(1\\leq B,J\\leq 10000)$，即交待任务的时间和完成任务的时间。输入结束标志为$N = 0$。输出完成任务所需的最短的时间。 分析由题意我们可以很快想到贪心，执行任务所需时间最长的最先交待，那么我们要按照$J$从大到小的顺序依次排序，然后依次交待。现在我们用反证法来证明贪心的正确性。 证明假设我们交换相邻的两个任务$X$和$Y$（交换前$X$在$Y$之前，那么交换后$X$在$Y$之后），我们发现其他任务完成的时间没有影响，但是对于这两个交换的任务我们有如下两种情况。情况一，如图一所示。交换前任务$Y$比$X$先结束。交换后$X$结束时间延后，$Y$的结束时间提前了，但是这样交换对于我们最终的结果非但没有好处反而花费的时间更长了。情况二，如图二所示。交换前$X$比$Y$先结束，如果交换后情况没有变好，那么一定满足：交换后$X$的结束时间不比交换前$Y$的结束时间早，也就是说，交换后$Y$的结束时间肯定变早了。所以如图二所示的情况将满足不等式$B[Y] + B[X] + J[X] \\geq B[X] + B[Y] + J[Y]$，化简后得$J[X] \\geq J[Y]$，这就是我们贪心的依据。这里提一下，关于排序的小技巧。(๑•̀ㅂ•́)و✧ 贪心的时候我们经常要用到排序，如果是单个数组排序的话直接$sort$就可以了。但是如果出现一对数呢？为了避免排序的时候一对数被打散，这时候我们就要用到结构体，因为我们要对结构体中的元素进行排序，我们把要进行排序的元素在结构体中进行重载，然后把结构体作为$vector$容器中的变量，然后就可以哒。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int n;struct Node&#123; int b, j; bool operator &lt; (const Node&amp; rhs) const &#123; return j &gt; rhs.j; &#125;&#125;;vector&lt;Node&gt; vec;inline int ReadInt()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123; if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123; x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif int kase = 1; while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n)&#123; vec.clear();// int b, j; for(int i = 0; i &lt; n; i++)&#123; b = ReadInt(); j = ReadInt(); vec.push_back((Node)&#123;b, j&#125;); &#125; sort(vec.begin(), vec.end()); int s = 0, ans = 0; for(int i = 0; i &lt; n; i++)&#123; s += vec[i].b; ans = max(ans, s + vec[i].j); &#125; printf(\"Case %d: %d\\n\", kase++, ans); &#125; return 0;&#125; 开始学习《训练指南》了，加油φ(≧ω≦*)♪","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"}]},{"title":"UVa 1659 - Help Little Laura(最小费用循环流)","slug":"UVa-1659-Help-Little-Laura-最小费用循环流","date":"2017-05-23T16:37:06.000Z","updated":"2017-05-28T04:31:37.058Z","comments":true,"path":"2017/05/24/UVa-1659-Help-Little-Laura-最小费用循环流/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-1659-Help-Little-Laura-最小费用循环流/","excerpt":"题目地址 描述平面上有$m$条有向线段连接了$n$个点。你从某一个点出发顺着有向线段行走，给沿途经过的每条线段涂一种不同的颜色，最后回到起点。你可以多次行走，给多个回路涂色。可以重复经过一个点，但是不能重复经过一条有向线段。如图所示是一种涂色方法(虚线表示未涂色)。","text":"题目地址 描述平面上有$m$条有向线段连接了$n$个点。你从某一个点出发顺着有向线段行走，给沿途经过的每条线段涂一种不同的颜色，最后回到起点。你可以多次行走，给多个回路涂色。可以重复经过一个点，但是不能重复经过一条有向线段。如图所示是一种涂色方法(虚线表示未涂色)。每涂一个单位长度将得到$x$分，但每使用一种颜料将扣$y$分。假定颜料有无限多种，如何涂色才能使得分最大？输入保证若存在有向线段$u\\rightarrow v$，则不会出现有向线段$v\\rightarrow u$。$n\\leq 100，m\\leq 500，1\\leq x, y\\leq 1000$。 分析首先我们先简化这道题目，尝试建模：给出一幅有向图，从中选取权和最大的边集，组成若干个有向圈。这里的边权等于$dx - y$，其中$d$为边的两个端点之间的欧几里德距离。提炼出模型后我们再来处理细节，题目中说由于每一个点并不一定只属于一个有向圈，因此“匹配后继”在这里并不适用。但是我们还是可以依据题目建立一个费用流的模型：在原图的基础上设每一条边的容量为$1$，边权就是费用。我们要找一个流使得对于每一给结点都满足流量守恒的条件，且总流量乘以费用总和最大。但是这样的模型是没有源点和汇点的，又因为每一个结点满足流量守恒，所以不存在最大流，而我们大这称为循环流。因此，换句话说我们这道题目实际上是要求解最大费用循环流问题。对于最大循环流我们如何解决呢？ 方法一：对于最大费用流问题，我们通常会将边权取负，然后计算最小费用流。对于最大费用循环流我们也是一样解决的：把每条边的边权由$dx - y$改为$-dx + y$，那么问题就转化为了求解最小费用循环流。我们每一次寻找整个图的负费用增广圈，沿着付费用增广圈增广后，每一个点的流量平衡并不会因此而被破坏，而整个循环流的总费用是变小了。因为找负费用增广圈相当于在残量网络中寻找负圈，所以我们可以适当套用最小费用最大流的算法，用$Bellman-Ford$来判负圈。 方法二：其实，我们还有另外一种不用涉及负圈的算法，不过比较巧妙很难想到。其实也很常规，就是新增附加源$s$和附加汇点$t$，对于原图中的每一条负圈边$u\\rightarrow v$拆分成为三条边$s\\rightarrow v，v\\rightarrow u和u\\rightarrow t$，容量均为$1$，但是$v\\rightarrow u$的费用为原来的相反数，其它两条边的费用均为$0$。原图中的正权边$u\\rightarrow v$保持不变：容量为$1$，费用为权值。这样处理过后，途中所有都变为了正权边，但是网络中会出现很多重边，要处理一下：对于任意点$u$，假设$s\\rightarrow u$的弧有$a$条，$u\\rightarrow t$的弧有$b$条。则当$a &gt; b$时保留一条弧$s\\rightarrow u$，容量为$a - b$，删除所有$u\\rightarrow t$的弧。 当$a &lt; b$时保留一条弧$u\\rightarrow t$，容量为$b - a$，删除所有$s\\rightarrow u$的弧。那么只需要求一次$s-t$的最小费用最大流，求出的最小费用加上原图的所有负权之和就为循环流的最小费用值。 其实大多数网络流的题目都是这样的，提炼出题目的模型，然后用我们学过最基本的算法，最大流，最小费用最大流，为二分图匹配之类的算法往上套，为了用已知的算法处理这道题目，我们还要进行大量的预处理。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int MAX = 100 + 3;int n, a, b;int x[MAX], y[MAX], c1[MAX], c2[MAX];vector&lt;int&gt; G[MAX];inline int ReadInt()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123; if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123; x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;struct Edge&#123; int from, to, cap, flow; double cost; Edge(int from, int to, int cap, int flow, double cost) : from(from), to(to), cap(cap), flow(flow), cost(cost)&#123;&#125;&#125;;struct MCMF&#123; int n, m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[MAX]; int a[MAX]; int p[MAX]; double d[MAX]; int inq[MAX]; void init(int n)&#123; this-&gt;n = n; for(int i = 0; i &lt; n; i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from, int to, int cap, double cost)&#123; edges.push_back(Edge(from, to, cap, 0, cost)); edges.push_back(Edge(to, from, 0, 0, -cost)); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool Bellman_Ford(int s, int t, int&amp; flow, double&amp; cost)&#123; for(int i = 0; i &lt; n; i++) d[i] = INF; memset(inq, 0, sizeof(inq)); d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = INF; queue&lt;int&gt; q; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(int i = 0; i &lt; G[u].size(); i++)&#123; Edge&amp; e = edges[G[u][i]]; if(e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost)&#123; d[e.to] = d[u] + e.cost; p[e.to] = G[u][i]; a[e.to] = min(a[u], e.cap - e.flow); if(!inq[e.to])&#123; q.push(e.to); inq[e.to] = 1; &#125; &#125; &#125; &#125; if(d[t] == INF) return false; flow += a[t]; cost += d[t] * a[t]; for(int u = t; u != s; u = edges[p[u]].from)&#123; edges[p[u]].flow += a[t]; edges[p[u]^1].flow -= a[t]; &#125; return true; &#125; int MincostMaxflow(int s, int t, double&amp; cost)&#123; int flow = 0; cost = 0; while(Bellman_Ford(s, t, flow, cost)); return flow; &#125;&#125;mcmf;int main()&#123;#ifndef DEUBG //freopen(\"test.in\",\"r\",stdin);#endif int kase = 0, v; while(scanf(\"%d%d%d\", &amp;n, &amp;a, &amp;b) == 3 &amp;&amp; n)&#123; mcmf.init(n + 2); for(int u = 0; u &lt; n; u++)&#123; x[u] = ReadInt(); y[u] = ReadInt(); G[u].clear(); while(1)&#123; v = ReadInt(); if(v == 0) break; G[u].push_back(v - 1); &#125; &#125; memset(c1, 0, sizeof(c1)); memset(c2, 0, sizeof(c2)); double sum = 0; for(int u = 0; u &lt; n; u++)&#123; for(int i = 0; i &lt; G[u].size(); i++)&#123; int v = G[u][i]; double d = sqrt((x[u] - x[v])*(x[u] - x[v]) + (y[u] - y[v])*(y[u] - y[v])); double edge_cost = -d*a+b; // minimize sum&#123;edge_cost&#125; if(edge_cost &gt;= 0) mcmf.AddEdge(u, v, 1, edge_cost); else&#123; mcmf.AddEdge(v, u, 1, -edge_cost);// c1[v]++; c2[u]++; sum += -edge_cost; &#125; &#125; &#125; for(int u = 0; u &lt; n; u++)&#123; if(c1[u] &gt; c2[u]) mcmf.AddEdge(n, u, c1[u] - c2[u], 0); if(c2[u] &gt; c1[u]) mcmf.AddEdge(u, n + 1, c2[u] - c1[u], 0); &#125; double cost; int flow = mcmf.MincostMaxflow(n, n + 1, cost); double ans = sum - cost; if(ans &lt; 0) ans = 0; printf(\"Case %d: %.2lf\\n\", ++kase, ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"最小费用循环流","slug":"最小费用循环流","permalink":"http://yoursite.com/tags/最小费用循环流/"}]},{"title":"UVa 10735 - Euler Circuit(混合图的欧拉回路)","slug":"UVa-10735-Euler-Circuit-混合图的欧拉回路","date":"2017-05-23T16:34:21.000Z","updated":"2017-05-28T04:31:46.884Z","comments":true,"path":"2017/05/24/UVa-10735-Euler-Circuit-混合图的欧拉回路/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-10735-Euler-Circuit-混合图的欧拉回路/","excerpt":"题目地址 描述给出$V$个点$E$条边($1\\leq V\\leq 100$， $1\\leq E\\leq 500$)的混合图(即有的边是有向边描述为$D$，有的边是无向边描述为$U$)，试求出它的一条欧拉回路，如果没有输出无解信息。 连通的无向图$G$存在欧拉回的充要条件是：$G$中每个顶点的度都是偶数。","text":"题目地址 描述给出$V$个点$E$条边($1\\leq V\\leq 100$， $1\\leq E\\leq 500$)的混合图(即有的边是有向边描述为$D$，有的边是无向边描述为$U$)，试求出它的一条欧拉回路，如果没有输出无解信息。 连通的无向图$G$存在欧拉回的充要条件是：$G$中每个顶点的度都是偶数。 分析其实很多混合图问题可以转化为有向图问题，方法是把无向边拆成两条方向相反的有向边。但是因为本题欧拉回路的限制，那就是说从任何一点出发都可以经过所有边恰好一次再回到自己，混合图中无向图定向后，有欧拉回路当且仅当所有点的入度都等于出度，所以这道题目并不可以用常规的办法解决。换一个思路想我们可以把图中的无向边定向，在从而解决这道题。 证明首先，我们将无向边任意定向，因为输入一定保证在忽略边的方向后图示连通的，所以在这里不用判断图是否连通。然后把定向后的有向边单独组成另一个图$G’$。初始时，使$G’$为空，对于$G$中的每一条无向边$u\\rightarrow v$，定向后在图$G’$中连一条边$u’\\rightarrow v’$。然后，我们计算每一个点出度与入度的差值$degree$。我们发现，如果所有点入度等于出度，则图中一定存在欧拉回路。当一个点出度$out(i)$与入度$in(i)$的差值为偶数的时候，可以把出度减少$\\frac{|out(i) - in(i)|}{2}$，把入度增加$\\frac{|out(i) - in(i)|}{2}$。但是，当一个点$degree$为奇数的时候，永远不可能使它的入度等于出度。接下来，思考如何给边进行定向，使得所有点的$degree$都为$0$，这里我们用网络流来解决。建立源点$S$和汇点$T$。对于$degree &gt; 0$的点$v$，我们连一条边$S\\rightarrow v$，容量为$\\frac{degree(v)}{2}$，只有$v$点出度减少$\\frac{degree(v)}{2}$入度才会等与出度，当$degree$为偶数的时候。对于$degree &lt; 0$的点$v$，我们连一条边$v\\rightarrow T$，容量为$\\frac{-degree(v)}{2}$，只有$v$点出度增加$\\frac{-degree(v)}{2}$入度才会等与出度，当$degree$为偶数的时候。然后，我们把所有是无向边的边加进来，把不是无向边的不添加进去。这不是废话吗┌(。Д。)┐、开始跑网络流，如果从出发的满流了说明所有的$degree &gt; 0$都被修改为$degree = 0$了，根据斜对称性可知，$degree &lt; 0$也等于$0$，因此我们可以通过给无向边进行定向从而使得$degree = 0$成立。然后我们把图$G’$打印出来，这时候里面的边已经都定向好了：对于流量为$1$的边，反向放入，否则方向不变。最后打印欧拉回路即可，注意有重边。（分析部分参考于） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 1000000000;const int max_n = 100 + 3;const int max_m = 500 + 3;int n, m;int u[max_m], v[max_m], directed[max_m], id[max_m], diff[max_n];struct Edge&#123; int from, to, cap, flow; Edge(int from, int to, int cap, int flow) : from(from), to(to), cap(cap), flow(flow)&#123;&#125;&#125;;struct EdmondsKarp&#123; int n, m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[max_n]; int a[max_n]; int p[max_n]; void init(int n)&#123; for(int i = 0; i &lt; n; i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from, int to, int cap)&#123; edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1); &#125; int Maxflow(int s, int t)&#123; int flow = 0; while(1)&#123; memset(a, 0, sizeof(a)); queue&lt;int&gt; q; q.push(s); a[s] = INF; while(!q.empty())&#123; int x = q.front(); q.pop(); for(int i = 0; i &lt; G[x].size(); i++)&#123; Edge&amp; e = edges[G[x][i]]; if(!a[e.to] &amp;&amp; e.cap &gt; e.flow)&#123; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow);// q.push(e.to); &#125; &#125; if(a[t]) break; &#125; if(!a[t]) break; for(int u = t; u != s; u = edges[p[u]].from)&#123; edges[p[u]].flow += a[t]; edges[p[u]^1].flow -= a[t]; &#125; flow += a[t]; &#125; return flow; &#125;&#125;EK;// for euler tour onlyvector&lt;int&gt; G[max_n];vector&lt;int&gt; vis[max_n];vector&lt;int&gt; path;void Euler(int u)&#123; for(int i = 0; i &lt; G[u].size(); i++)&#123; if(!vis[u][i])&#123; vis[u][i] = 1; Euler(G[u][i]); path.push_back(G[u][i] + 1); &#125; &#125;&#125;void print_path()&#123; // build the new graph for(int i = 0; i &lt; n; i++)&#123; G[i].clear(); vis[i].clear(); &#125; for(int i = 0; i &lt; m; i++)&#123; bool rev = false; if(!directed[i] &amp;&amp; EK.edges[id[i]].flow &gt; 0) rev = true; if(!rev)&#123; G[u[i]].push_back(v[i]); vis[v[i]].push_back(0); &#125; else&#123; G[v[i]].push_back(u[i]); vis[u[i]].push_back(0); &#125; &#125; path.clear(); Euler(0); printf(\"1\"); for(int i = path.size() - 1; i &gt;= 0; i--) printf(\" %d\", path[i]); printf(\"\\n\");&#125;int main()&#123;#ifndef DBEUG //freopen(\"test.in\",\"r\",stdin);#endif int T; scanf(\"%d\", &amp;T); while(T--)&#123; scanf(\"%d%d\", &amp;n, &amp;m); EK.init(n + 2);//包含源点与汇点 memset(diff, 0, sizeof(diff));//出度与入度的差值 for(int i = 0; i &lt; m; i++)&#123; char dir[9]; scanf(\"%d%d%s\", &amp;u[i], &amp;v[i], dir); u[i]--; v[i]--; directed[i] = (dir[0] == 'D' ? 1 : 0); diff[u[i]]++; diff[v[i]]--; if(!directed[i])&#123; id[i] = EK.edges.size(); EK.AddEdge(u[i], v[i], 1); &#125; &#125; bool ok = true; for(int i = 0; i &lt; n; i++)&#123; if(diff[i] % 2 != 0)&#123; ok = false; //出度与入度差值为奇数，不存在欧拉回路 break; &#125; &#125; int s = n, t = n + 1; if(ok)&#123; int sum = 0; for(int i = 0; i &lt; n; i++)&#123; if(diff[i] &gt; 0)&#123;//建图 EK.AddEdge(s, i, diff[i]/2); sum += diff[i]/2; &#125; if(diff[i] &lt; 0)&#123; EK.AddEdge(i, t, -diff[i]/2); &#125; &#125; if(EK.Maxflow(s, t) != sum) ok = false;// &#125; if(!ok) printf(\"No euler circuit exist\\n\"); else print_path(); if(T) printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"欧拉回路","slug":"欧拉回路","permalink":"http://yoursite.com/tags/欧拉回路/"}]},{"title":"UVa 1639 - Candy","slug":"UVa-1639-Candy","date":"2017-05-23T16:20:44.000Z","updated":"2017-05-28T04:31:26.016Z","comments":true,"path":"2017/05/24/UVa-1639-Candy/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-1639-Candy/","excerpt":"题目地址 描述有两个盒子各有$n(n \\leq 2 \\times 10^{5})$个糖，每天随机选一个盒子并打开它（概率分别为$p$，$1 - p$），如果里面有糖，他会吃掉其中一个；否则他会打开另一个盒子，然后吃一颗糖。他已经每天吃一颗糖吃了几天了，有一天，他打开盒子一看，没糖啦（；´д｀）ゞ！打开另一个盒子之前，他希望你帮他算一下另一个盒子里剩余糖的个数的数学期望。有多组测试数据，对每一组测试数据包含每一个盒子中糖的个数$n(n \\leq 2 \\times 10^{5})$以及实数$p(0\\leq p\\leq 1，小数点后6位)$，以$EOF$终止。对于每组测试数据，以$”Case X：Y”$形式输出，其中$X$是测试数据的编号(从$1$开始)，$Y$是另一个盒子里剩余糖的个数的数学期望，任何答案绝对误差必须$\\leq 10^{-4}$。","text":"题目地址 描述有两个盒子各有$n(n \\leq 2 \\times 10^{5})$个糖，每天随机选一个盒子并打开它（概率分别为$p$，$1 - p$），如果里面有糖，他会吃掉其中一个；否则他会打开另一个盒子，然后吃一颗糖。他已经每天吃一颗糖吃了几天了，有一天，他打开盒子一看，没糖啦（；´д｀）ゞ！打开另一个盒子之前，他希望你帮他算一下另一个盒子里剩余糖的个数的数学期望。有多组测试数据，对每一组测试数据包含每一个盒子中糖的个数$n(n \\leq 2 \\times 10^{5})$以及实数$p(0\\leq p\\leq 1，小数点后6位)$，以$EOF$终止。对于每组测试数据，以$”Case X：Y”$形式输出，其中$X$是测试数据的编号(从$1$开始)，$Y$是另一个盒子里剩余糖的个数的数学期望，任何答案绝对误差必须$\\leq 10^{-4}$。 分析根据期望的定义，我们设最后打开第$1$个盒子，发现没有糖，此时第$2$个盒子里还剩下$i$颗糖，因为每次打开一个盒子取一颗糖，所以我们已经打开了$n$次第$1$个盒子和$n - i$次第$2$个盒子，一共打开了$n + (n - i) = 2n - i$次盒子。因为其满足二项分布，所以“最后打开的是第$1$个盒子”的概率为$\\binom{n}{2n + i}p^{n + 1}(1-p)^{n - i}$。因为$n \\leq 2 \\times 10^{5}$，所以n会非常大；又因为$p$为实数且$0\\leq p\\leq 1$，所以$p^{i + 1}， (1-p)^{n - i}$会非常接近于$0$。如果分别计算这三项再把它们乘起来，那么我们就不能控制精度$0\\leq p\\leq 1$，所以这里我们用对数来处理。$\\therefore设V_{1}(i) = ln(\\binom{n}{\\ 2n + i\\ }p^{i + 1}(1-p)^{n - i})$$= ln (\\binom{n}{\\ 2n + i\\ }) + ln(p^{n + 1})+ln (1-p)^{n - i}$$= ln (\\binom{n}{\\ 2n + i\\ })+(n + 1)ln(p) + (n - i)ln(1-p)$处理以后最后打开的是第$1$个盒子”的概率为$e^{V_{1}(i)}$。注意$p$的指数是$n + 1$，因为除了之前打开了$n$次盒子$1$后，最后又打开了$1$次。$log$之间一定是相加。同理，如果最后打开的是第$2$个盒子，此时第$1$个盒子中还剩下$i$颗糖。则，“最后打开的是第$2$个盒子”的概率为$\\binom{n}{2n + i}(1-p)^{n + 1}p^{n - i}$。$\\therefore设 V_{2}(i) = ln(\\binom{n}{\\ 2n + i\\ }\\ (1-p)^{n + 1}p^{n - i})$$= ln(\\binom{n}{\\ 2n + i\\ }) + ln((1-p)^{n + 1})+ln(p^{n - i})$$= ln(\\binom{n}{\\ 2n + i\\ })+(n + 1)ln(1-p) + (n - i)ln(p)$处理以后最后打开的是第$2$个盒子”的概率为$e^{V_{2}(i)}$。因为二项分布的期望值为$E(X) = np$,所以另一个盒子里糖的个数的数学期望为。 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 200000 + 3;long double logF[MAX * 2 + 1];int n;double p;long double logC(int n, int m)&#123; return logF[n] - logF[m] - logF[n - m];&#125;double solve(int n, double p)&#123; double ans = 0; for(int i = 0; i &lt;= n; i++)&#123; long double c = logC(n * 2 - i, n); long double v1 = c + (n + 1) * log(p) + (n - i) * log(1 - p); long double v2 = c + (n + 1) * log(1-p) + (n - i) * log(p); ans += i * (exp(v1) + exp(v2)); &#125; return ans;&#125;int main()&#123;#ifndef DEUBG //freopen(\"test.in\",\"r\",stdin);#endif logF[0] = 0; for(int i = 1; i &lt;= MAX; i++) logF[i] = logF[i - 1] + log(i); int kase = 0; while(scanf(\"%d%lf\", &amp;n, &amp;p) == 2) printf(\"Case %d: %.6lf\\n\", ++kase, solve(n, p)); return 0;&#125; 第一次接触用对数处理精度的人可能会问，为什么用取对数的方法可以让答案更加精确呢(＠_＠;)？在这道题目里你可以看出，它们都是连乘，组合数会越乘越大，而$p$也就是$0 \\leq p \\leq 1$的实数会越乘越小。但是你取对数就不会呀，取$log$只会计算一次呀！所以，当然是很精确的。一定要记住取完$log$后要用$C++$函数库里的$exp$函数还原！计算机中的$log$函数是以自然对数$e$为底，而$exp$函数是以自然对数$e$为底的幂。关于二项分布和二项分布的期望和方差我这里就不花时间写了( ﾟдﾟ)つBye！","categories":[],"tags":[{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"精度处理","slug":"精度处理","permalink":"http://yoursite.com/tags/精度处理/"},{"name":"期望 & 概率","slug":"期望-概率","permalink":"http://yoursite.com/tags/期望-概率/"}]},{"title":"[模板]最短路问题","slug":"模板-最短路问题","date":"2017-05-23T16:16:52.000Z","updated":"2017-05-23T16:33:29.800Z","comments":true,"path":"2017/05/24/模板-最短路问题/","link":"","permalink":"http://yoursite.com/2017/05/24/模板-最短路问题/","excerpt":"$Dijkstra$$Dijkstra$算法适用于边权为正的情况，可以解决正权图上单源最短路问题，即从单个原点出发，到所有结点的最短路，算法适用于有向图与无向图。这里我就不花费篇幅证明算法的正确性了，直接上代码吧(✿◡‿◡)。","text":"$Dijkstra$$Dijkstra$算法适用于边权为正的情况，可以解决正权图上单源最短路问题，即从单个原点出发，到所有结点的最短路，算法适用于有向图与无向图。这里我就不花费篇幅证明算法的正确性了，直接上代码吧(✿◡‿◡)。 代码模板1：如果你只需要输入顶点数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;//first is shortest distance , second is pointconst int MAX = 1000 + 7;const int INF = 0x3f3f3f3f;int n, m; int d[MAX];//the shortest pathint pre[MAX];//最短路上前趋结点struct Edge&#123; int to, cost; Edge(int to = 0, int cost = 0) : to(to), cost(cost)&#123;&#125;&#125;;vector&lt;Edge&gt; G[MAX];void dijkstra(int s)&#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; fill(pre, pre + n, -1); fill(d, d + n, INF); d[s] = 0; q.push(P(0, s)); while(!q.empty())&#123; P p = q.top(); q.pop(); int v = p.second; if(d[v] &lt; p.first) continue; for(unsigned i = 0; i &lt; G[v].size(); i++)&#123; Edge e = G[v][i]; if(d[e.to] &gt; d[v] + e.cost)&#123; d[e.to] = d[v] + e.cost; pre[e.to] = v; q.push(P(d[e.to], e.to)); &#125; &#125; &#125;&#125;vector&lt;int&gt; getpath(int t)&#123; vector&lt;int&gt; path;//路径还原 for(; t != - 1; t = pre[t])//不断沿着prev[t]走直到t = s path.push_back(t); reverse(path.begin(), path.end()); return path;&#125;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif scanf(\"%d\", &amp;n); int x, y, z; while(scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z) == 3)&#123; if(x == 0 &amp;&amp; y == 0 &amp;&amp; z == 0) break; G[x].push_back(Edge(y, z)); //G[y].push_back(Edge(x, z));//无向图 &#125; dijkstra(0); vector&lt;int&gt; path; path = getpath(n - 1); for(unsigned int i = 0; i &lt; path.size(); i++) cout&lt;&lt;path[i]&lt;&lt;\" \";//顶点0 ~ n - 1的最短路径 printf(\"\\n\"); printf(\"%d\\n\", d[n - 1]); for(int i = 0; i &lt; n; i++) printf(\"%d \", d[i]);//顶点0到(0 ~ n)中每一个顶点的最短路 return 0;&#125; 模板2：如果你既要输入顶点数又要输入边数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; P;//first is shortest distance , second is pointconst int MAX = 1000 + 7;const int INF = 0x3f3f3f3f;int n, m; int d[MAX];//the shortest pathint pre[MAX];//最短路上前趋结点struct Edge&#123; int to, cost; Edge(int to = 0, int cost = 0) : to(to), cost(cost)&#123;&#125;&#125;;vector&lt;Edge&gt; G[MAX];void dijkstra(int s)&#123; priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q; fill(pre, pre + n, -1); fill(d, d + n, INF); d[s] = 0; q.push(P(0, s)); while(!q.empty())&#123; P p = q.top(); q.pop(); int v = p.second; if(d[v] &lt; p.first) continue; for(unsigned i = 0; i &lt; G[v].size(); i++)&#123; Edge e = G[v][i]; if(d[e.to] &gt; d[v] + e.cost)&#123; d[e.to] = d[v] + e.cost; pre[e.to] = v; q.push(P(d[e.to], e.to)); &#125; &#125; &#125;&#125;vector&lt;int&gt; getpath(int t)&#123; vector&lt;int&gt; path;//路径还原 for(; t != - 1; t = pre[t]) path.push_back(t); reverse(path.begin(), path.end()); return path;&#125;int main()&#123;#ifndef DEBUG //freopen(\"test1.in\",\"r\",stdin);#endif scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++)&#123; int x, y, z; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z); G[x].push_back(Edge(y, z)); G[y].push_back(Edge(x, z));//无向图 &#125; dijkstra(0); vector&lt;int&gt; path; path = getpath(n - 1); for(unsigned int i = 0; i &lt; path.size(); i++) cout&lt;&lt;path[i]&lt;&lt;\" \";//顶点0 ~ n - 1的最短路径 printf(\"\\n\"); printf(\"%d\\n\", d[n - 1]); for(int i = 0; i &lt; n; i++) printf(\"%d \", d[i]);//顶点0到(0 ~ n)中每一个顶点的最短路 return 0;&#125; 数据1234567891011121314151617181920212223242526272829303132模板1： 输入： 5 0 1 10 0 4 100 0 3 30 3 4 60 2 4 10 3 2 20 1 2 50 0 0 0 输出： 0 3 2 4 60 0 10 50 30 60模板2： 输入： 7 10 0 1 5 0 2 2 1 2 4 1 3 2 2 3 6 2 4 10 3 5 1 4 5 3 4 6 5 5 6 9 输出： 0 1 3 5 4 6 16 0 5 2 7 11 8 16 一道关于$Dijkstra$以及路径输出的题：题目地址 $Bellman-Ford$如果最短路存在，一定存在一个不含环的最短路。为什么呢(⊙ˍ⊙)？在边权可正可负的图中，有三种环：零环，正环和负环。如果包含正环或者零环，去掉以后路径不会变长；如果包含负环，则意味着不存在最短路。而$Bellman-Ford$算法是可以在松弛的过程中判断是否存在负环的算法，在用队列优化后就是$SPFA$算法。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 1000 + 3;int n, m;int d[MAX];struct Edge&#123; int from, to, dist;&#125;es[MAX];//边//求解顶点s出发到所有顶点的最短距离void bellman_ford(int s)&#123; for(int i = 0; i &lt; n; i++) d[i] = INF; d[s] = 0; while(true)&#123; bool update = false; for(int i = 0; i &lt; m; i++)&#123; Edge e = es[i];// if(d[e.from] != INF &amp;&amp; d[e.to] &gt; d[e.from] + e.dist)&#123; d[e.to] = d[e.from] + e.dist; update = true; &#125; &#125; if(!update) break; &#125; for(int i = 0; i &lt; n; i++) printf(\"%d \", d[i]); printf(\"\\n\");&#125;//如果返回true则存在负圈bool find_negative_loop()&#123; memset(d, 0, sizeof(d)); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; Edge e = es[j];// if(d[e.to] &gt; d[e.from] + e.dist)&#123; d[e.to] = d[e.from] + e.dist; if(i == n - 1) return true;//第n次更新仍存在负圈 &#125; &#125; &#125; return false;&#125;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif scanf(\"%d%d\", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++)&#123; scanf(\"%d%d%d\", &amp;es[i].from, &amp;es[i].to, &amp;es[i].dist); &#125; bellman_ford(0); if(find_negative_loop()) printf(\"Exist\\n\"); else printf(\"Do not Exsit\\n\"); return 0;&#125; $Floyd$如果需要求出每两点之间的最短距离，不必调用$n$次$Dijkstra$(边权均为正)或者$Bellman-Ford$(有负权)。用$Floyd-Warahall$算法就好了(/ω＼)。注意初始化，以及根据题目中的边的长度上限来设定$INF$不要太小也不要太大。 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 100 + 3;int d[MAX][MAX];//d[u][v]表示e = (u, v)的权值int n;//顶点数int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == j) d[i][j] = 0; else d[i][j] = INF; &#125; &#125; int u, v, w; while(scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w) == 3)&#123; if(u == 0 &amp;&amp; v == 0 &amp;&amp; w == 0) break; d[u][v] = w; &#125; for(int k = 0; k &lt; n; k++)&#123; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; d[i][j] = min(d[i][j], d[i][k] + d[k][j]); &#125; &#125; &#125; for(int i = 0; i &lt; n; i++) printf(\"%d \", d[0][i]); return 0;&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://yoursite.com/tags/Dijkstra/"},{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/最短路/"},{"name":"Bellman-Ford","slug":"Bellman-Ford","permalink":"http://yoursite.com/tags/Bellman-Ford/"},{"name":"Floyd","slug":"Floyd","permalink":"http://yoursite.com/tags/Floyd/"}]},{"title":"同余与模运算","slug":"同余与模运算","date":"2017-05-23T15:22:58.000Z","updated":"2017-08-08T07:46:47.209Z","comments":true,"path":"2017/05/23/同余与模运算/","link":"","permalink":"http://yoursite.com/2017/05/23/同余与模运算/","excerpt":"好啦，要开始学习模运算啦，只是紫书上一点微小的部分，还是先膜一下为敬0w0。。。无关紧要的话：我觉得作为一个合格的Oler应该对于每一个基础的知识点都有一个符合自己代码风格和习惯的模板，最好是能深刻理解这个算法之后写的模板，这样我们才不会在考场上出现低级的错误哒！比如有的人取区间喜欢左闭右开，有人喜欢让左右都是闭区间；有的人循环喜欢从1开始，有人喜欢从0开始；当然，各有各的好处，只是要做到在考场上部分因为低级错误而丢分甚至于调试很长的时间就可以啦。 定义如果存在 $a\\pmod n\\equiv b\\pmod n$，即a,b除以m所得的余数相等,那么我们记作$a\\equiv \\ b \\pmod n$。 基本性质和其他的运算一样，模运算也有自己的运算法则。如果存在$a\\equiv \\ b\\pmod n$，且有$c\\equiv \\ d pmod n$，那么下面的运算率成立。 $a + c\\equiv \\ b + d \\pmod n$ $a - c\\equiv \\ b - d \\pmod n$ $a \\times c\\equiv \\ b \\times d \\pmod n$我们经常利用这三个性质对输出答案较大的程序取模，一般是模完再加，加减乘均满足的这个性质，不过除法是不满足的。","text":"好啦，要开始学习模运算啦，只是紫书上一点微小的部分，还是先膜一下为敬0w0。。。无关紧要的话：我觉得作为一个合格的Oler应该对于每一个基础的知识点都有一个符合自己代码风格和习惯的模板，最好是能深刻理解这个算法之后写的模板，这样我们才不会在考场上出现低级的错误哒！比如有的人取区间喜欢左闭右开，有人喜欢让左右都是闭区间；有的人循环喜欢从1开始，有人喜欢从0开始；当然，各有各的好处，只是要做到在考场上部分因为低级错误而丢分甚至于调试很长的时间就可以啦。 定义如果存在 $a\\pmod n\\equiv b\\pmod n$，即a,b除以m所得的余数相等,那么我们记作$a\\equiv \\ b \\pmod n$。 基本性质和其他的运算一样，模运算也有自己的运算法则。如果存在$a\\equiv \\ b\\pmod n$，且有$c\\equiv \\ d pmod n$，那么下面的运算率成立。 $a + c\\equiv \\ b + d \\pmod n$ $a - c\\equiv \\ b - d \\pmod n$ $a \\times c\\equiv \\ b \\times d \\pmod n$我们经常利用这三个性质对输出答案较大的程序取模，一般是模完再加，加减乘均满足的这个性质，不过除法是不满足的。 大整数取模输入正整数$n$和$m$，输出$n \\pmod m$的值。$n \\leqslant 10^{100}$，$m \\leqslant 10^{9}$。这里我们需要把大整数写成自左向右的形式，那么什么叫自左向右的形式呢？这里我们举一个栗子(～￣▽￣)～，如$1234 = ((1 \\times 10 + 2) \\times 10 + 3) \\times 10 + 4$。然后应用前面的运算法则每一步取模。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 100 + 3;char n[MAX];int m;LL ans;int main()&#123; scanf(\"%s%d\", n, &amp;m); int len = strlen(n); for(int i = 0; i &lt; len; i++) ans = (int)(((LL)ans * 10 + n[i] - '0') % m); printf(\"%d\\n\", (int)ans); return 0;&#125; 幂取模输入正整数$a$，$n$，$m$，输出$a^{n} \\pmod m$的。$a, n, m \\leq 10^{9}$。实际上就是快速幂啦，这里我们用分治法高效地实现。 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a, n, m;int pow_mod(int a, int n, int m)&#123; ll res = 1ll; while (n) &#123; if (n &amp; 1) (res *= a) %= m; (a *= a) %= m; n &gt;&gt;= 1; &#125; return a;&#125;int main()&#123; scanf(\"%d%d%d\", &amp;a, &amp;n, &amp;m); printf(\"%d\\n\", pow_mod(a, n, m)); return 0;&#125; 逆元在$mod \\ n$的意义下存在$a \\times b = 1$，我们就说$a, b$互为乘法下的逆，记作$a = b^{-1}, b = a^{-1}$。我们还可以用逆元的定义来实现模意义下的除法。如，我们可以利用$a \\times b = 1$，令$a \\div b = a \\times b^{-1} \\pmod n)$。我们现在有$ax \\equiv b \\pmod n$，我们又知道模方程存在一个特殊的情况，$b = 1$时，$ax \\equiv 1 \\pmod n$的解称为$a$关于模$n$的逆。扩展欧几里德（EXGCD）算法可以在 $O(\\log \\max(a, b))$的时间内求出关于$x, y$的方程$ax + by = gcd(a, b)$的一组整数解。 模线性方程组（线性同余方程组）好吧，我现在只会求模线性方程，暂且还不会求方程组（；´д｀）ゞ。对于$ax \\equiv b \\pmod n$。因为同余，所以$ax - b = yn$，即$ax - ny = b$，当且仅当$gcd(a, n) \\mid b$时，方程有解。我们令$g = gcd(a,n)$，形如$ax - ny$的每一个数时$g$的倍数；因此如果$g$不整除$b$，则$ax - ny = b$没有解，从而$ax \\equiv b \\pmod n$没有解。假设$g$确实整除$b$，我们可推知：$ax+ny = g$总有解，通过扩展欧几里得算法求得$x = x’, y = y’$。由于假设$g$整除$b$，所以$a\\frac{bx’}{g} + n\\frac{by’}{g} = b$。这说明，$x\\equiv \\frac{bx’}{g} \\pmod n$是同余式$ax \\equiv b \\pmod n$的解。既然不定方程有多组解，难道这个方程只有以一组解吗，模方程还有其他解吗？假设$x_{1}$是同余式$ax \\equiv b \\pmod n$的其他解，则$ax_{1} \\equiv ax_{0} \\pmod n$。所以$m$整除$ax_{1} - ax_{0}$，$\\frac{n}{g}$整除$\\frac{a(x_{1} - x{0})}{g}$。我们已知$\\frac{n}{g}$与$\\frac{a}{g}$没有公因数，从而$\\frac{n}{g}$必整除$x_{1} - x_{0}$。所以存在整数$k$使得 $x_{1} = x_{0}+k\\cdot \\frac{n}{g} \\pmod n$,$k = 0, 1, 2, \\cdots , g-1$。线性同余定理 如果$g \\nmid b$，则同余式$ax \\equiv b \\pmod n$无解。 如果$g \\mid b$，则同余式$ax \\equiv b \\pmod n$恰好有$g$个不同解。 代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int a, b, n;int d, x, y;int exgcd(int a, int b, int&amp; x, int&amp; y)&#123; int d = a; if(!b)&#123; x = 1; y = 0;&#125; else&#123; d = exgcd(b, a % b, y, x); y -= (a / b) * x; &#125; return d;&#125;int modular_linear_equation_solver(int a, int b, int n)&#123; int d = exgcd(a, n, x, y); if(b % d == 0)&#123; int x0 = x * (b / d) % n;//special answer for(int i = 0; i &lt; d; i++) printf(\"%d\\n\", (x0 + i * (n / d)) % n);//all the possible answers &#125; else printf(\"No solutions\\n\");&#125;int main()&#123; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;n); modular_linear_equation_solver(a, b, n); return 0;&#125; 中国剩余定理定义中国剩余定理是数论中的一个关于一元线性同余方程组的定理，说明了一元线性同余方程组有解的准则以及求解方法，其实是一种构造解的思想。形如同余方程组中国剩余定理说明：假设任意$n$互素，对于任意整数$a$，恰有一解$0\\leq x\\leq n_{1}n_{2}\\cdots n_{k}$1.令$N = \\prod_{i=1}^{k}n_{i}$， $N_{i} = \\frac{N}{n_{i}}$， $(i \\in (1, 2, 3, \\cdots , k))$。2.令$t_{i} = N_{i}^{-1}$，则$t_{i}N_{i} \\equiv 1 \\pmod n_{i}$，$(i \\in (1, 2, 3, \\cdots , k))$。3.方程组的通解形式为$S = a_{1}t_{1}N_{1}+a_{2}t_{2}N_{2}+\\cdots +a_{k}t_{k}N_{k} + pN = pN + \\sum_{i=1}^{k}a_{i}t_{i}N_{i}$，$(p\\in \\mathbb{Z})$。在$\\pmod n$的的意义下方程有且仅有一解$x = \\sum_{i=1}^{k}a_{i}t_{i}N_{i}$ 。 证明有我们假设的知道$gcd(n_{i},N_{i}) = 1$，所以说明存在整数$t$使得$t_{i}N_{i} \\equiv 1\\pmod n_{i}$成立。$\\because a_{i}t_{i}N_{i} \\equiv a_{i}\\cdot 1\\equiv a_{i}\\ (mod \\ n_{i})$又$\\because j \\in (1,2,\\cdots, n), \\ j\\neq i, \\ a_{i}t_{i}N_{i}\\equiv 0 \\ (mod \\ n_{j})$$\\therefore x = a_{1}t_{1}N_{1}+a_{2}t_{2}N_{2}+\\cdots +a_{k}t_{k}N_{k}$满足：$i\\in (1, 2, \\cdots , k), \\ x = a_{i}t_{i}N_{i}+ \\sum_{j\\neq i} a_{j}t_{j}N_{j}\\equiv a_{i}+\\sum_{j\\neq i}0\\equiv a_{i}\\ (mod \\ n_{i})$。若$x_{1},x_{2}$均为模方程组的解，同理可证。综上所述，模方程的解集为$(pN + \\sum_{i=1}^{k}a_{i}t_{i}N_{i},p \\in \\mathbb{Z})$。 上面比较抽象，现在我们举一个实际一点的栗子=￣ω￣=。今有物，不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？根据上面的证明可知，$n_{1} = 3, n_{2} = 5,n_{3} = 7$，$N_{1} = 35,N_{2} = 21,N_{3} = 15$，$t_{1} = 2, t_{2} = 1,t_{3} = 1$。带入可得：$\\therefore x = 233 + p \\times 105(p\\in \\mathbb{Z})$，当$p = -2$时，$x$有最小正正解$23$。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1000 + 3;int a[MAX], m[MAX];int n;void exgcd(LL a, LL b, LL&amp; x, LL&amp; y)&#123; if(!b)&#123; x = 1; y = 0;&#125; else&#123; exgcd(b, a % b, y, x); y -= (a / b) * x; &#125;&#125;LL china(int n, int* a, int *m)&#123; LL M = 1, d, y, x = 0; for(int i = 0; i &lt; n; i++) M *= m[i]; for(int i = 0; i &lt; n; i++)&#123; LL w = M / m[i]; exgcd(m[i], w, d, y); x = (x + y * w * a[i]) % M; &#125; return (x + M) % M;&#125;int main()&#123; scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) scanf(\"%d%d\", &amp;a[i], &amp;m[i]); printf(\"%lld\\n\", china(n, a, m)); return 0;&#125; 费马小定理在$n$是素数的情况下，对任意整数$x$都有$x^{n}\\equiv x\\pmod n$这个定理被称作费马小定理。其中如果$x$无法被$n$整除，那么$x^{n - 1}\\equiv 1\\pmod n$。我们可以用费马小定理求$a$得逆元，求素数。上面式子变形之后得到$a^{-1}\\equiv a^{n-2}\\pmod n$，因此我们可以用快速幂求得$a$的逆元。费马小定理可由欧拉公式证得，这里我就不多赘述啦╮(╯▽╰)╭。 欧拉公式与欧拉函数定义费马小定理在一定程度上与欧拉公式$a^{\\phi (n)}\\equiv 1\\pmod n$具有相似性。欧拉函数可用于求小于$n$且与$n$互素的整数个数。给出正整数$n$的唯一分解式$n = p_{1}^{a^{1}}p_{2}^{a_{2}}p_{3}^{a_{3}}\\cdots p_{k}^{a_{k}}$，求$1, 2, 3,\\cdots ,n$中与$n$互素的数的个数。 证明我们通过正整数$n$的唯一分解因式可以得到$n$的正因数的个数$\\prod_{i=1}^{k}(a_{i}+1)=(a_{1}+1)(a_{2}+1)\\cdots (a_{k}+1)$，而这里并不是这么简单。 我们现在已经证得了欧拉公式，但是因为其中含有$\\phi (n)$所以我们必须找到计算$\\phi (n)$的有效方法，让我们可以完整的应用这个公式。显然可以看出，当$n = p$是素数的时候容易计算$\\phi (n)$，应为每一个整数$1\\leq a\\leq p-1$与$n$互素。因此$\\phi (p) = p-1$。当$n = p^{k}$是素数次幂的时候，我们可以推出$\\phi (p^{k})$的公式。 我们有满足$1 \\leq a\\leq p^{k}$开始没然后丢弃与$p^{k}$不互素的整数，用公式表示是$\\phi (p^{k}) = p^{k} - (a:1\\leq a\\leq p^{k},p\\mid a)$。 数$a$什么时候和$p^{k}$不互素呢=￣ω￣=？因为$p^{k}$仅有的因数是$p$的幂次，所以当$a$被$p$的整除的时候$a$与$p^{k}$不互素。那么有哪些$p$的倍数呢？$p, 2p, 3p, 4p, \\cdots , (p^{k-1} -2)p, (p^{k-1} -1)p,p^{k}$一共有$p^{k-1}$个。所以$\\phi (n) = p^{k}-p^{k-1}$。 更详细的证明可以看这里欧拉函数 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10000 + 3;int n;int phi[MAX];//求与第n个数互素的数的个数int euler_phi(int n) &#123; int m = (int)sqrt(n + 0.5); LL ans = n; for (int i = 2; i &lt;= m; i++) &#123; if (n % i == 0)&#123; ans = ans / i * (i - 1); while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) ans = ans / n * (n - 1); return ans;&#125;//1~n中所有数的欧拉phi函数值 O(nloglogn)void phi_table(int n)&#123; for(int i = 2; i &lt;= n; i++) phi[i] = 0; phi[1] = 1; for(int i = 2; i &lt;= n; i++)&#123; if(!phi[i])&#123; for(int j = i; j &lt;= n; j += i)&#123; if(!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); &#125; &#125; &#125;&#125;int main()&#123; scanf(\"%d\", &amp;n); printf(\"phi(%d) = %d\\n\", n, euler_phi(n)); for(int i = 1; i &lt;= n; i++)&#123; phi_table(i); printf(\"phi[%d] = %d\\n\", i, phi[i]); &#125; return 0;&#125;/*phi(n) 表示的含义是,不超过x且和x互素的整数个数.*/ 好啦，到此为止紫书上所有关于同余与模运算的东西都写完了，终于把坑填好啦&lt;(￣ˇ￣)/。上面大部分重要的内容我都写了详细的证明，也给出了解题的模板。那就这样啦，马上就要学蓝书啦，蓝书上面也只有一个离散对数和指数循环节啦，等我把这两节学完之后再把这个部分完结吧(～o￣3￣)～！","categories":[],"tags":[{"name":"快速幂&快速幂取模","slug":"快速幂-快速幂取模","permalink":"http://yoursite.com/tags/快速幂-快速幂取模/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://yoursite.com/tags/欧拉函数/"},{"name":"逆元","slug":"逆元","permalink":"http://yoursite.com/tags/逆元/"},{"name":"模运算","slug":"模运算","permalink":"http://yoursite.com/tags/模运算/"},{"name":"费马小定理","slug":"费马小定理","permalink":"http://yoursite.com/tags/费马小定理/"},{"name":"中国剩余定理","slug":"中国剩余定理","permalink":"http://yoursite.com/tags/中国剩余定理/"},{"name":"模线性方程","slug":"模线性方程","permalink":"http://yoursite.com/tags/模线性方程/"}]},{"title":"埃及分数问题","slug":"埃及分数问题","date":"2017-05-23T15:14:46.000Z","updated":"2017-05-23T15:18:26.068Z","comments":true,"path":"2017/05/23/埃及分数问题/","link":"","permalink":"http://yoursite.com/2017/05/23/埃及分数问题/","excerpt":"这篇Blog意在通过埃及分数问题学习和理解迭代加深搜索。 定义迭代加深搜索通常是从小到大枚举不超过$Maxd$或是不小于$Mind$的结点，每次执行的时候只考虑在结点深度不超过$Maxd$或是不小于$Mind$的结点。这样只要解的深度有限那么有限时间内就可有搜索完。简而言之，就是对深度优先搜索进行了一定改进，对搜索树的深度进行控制，即有界深度优先搜索。","text":"这篇Blog意在通过埃及分数问题学习和理解迭代加深搜索。 定义迭代加深搜索通常是从小到大枚举不超过$Maxd$或是不小于$Mind$的结点，每次执行的时候只考虑在结点深度不超过$Maxd$或是不小于$Mind$的结点。这样只要解的深度有限那么有限时间内就可有搜索完。简而言之，就是对深度优先搜索进行了一定改进，对搜索树的深度进行控制，即有界深度优先搜索。 应用埃及分数问题描述在古埃及，人们使用单位分数的和（即$\\frac{1}{a}，a$是自然数）表示一切有理数。例如$\\frac{2}{3}=\\frac{1}{2}+\\frac{1}{6}$，但不允许$\\frac{2}{3}=\\frac{1}{3}+\\frac{1}{3}$。因为在加数中不允许有相同的。对于一个分数$\\frac{a}{b}$，表示方法有很多种，其中加数少的比加数多的好，如果加数个数相同，则最小的分数越大越好。举一个栗子，$\\frac{19}{45}= \\frac{1}{5}+\\frac{1}{6}+\\frac{1}{8}$时最优方案。 分析这道题目理论上是可以用回溯法来实现，但是解答树不仅深度是没有明显的上界的，而且加数的选择在理论上也是无限的。那么深度优先搜索就是连一层都扩展不完。这时候引入迭代加深搜索，如其名字，我们每一次枚举深度上限$Maxd$，每次执行的时候只考虑深度不超过$Maxd$的结点。同时迭代加深搜索另一重要方法就是剪枝，通过题目中推出来的结论进行剪枝，如怎样丢都达不到要求，或是已求出最优解不会存在比这更优的解。例如埃及分数中，我们按照字母递增顺序进行扩展，如果扩展到$i$层时，前$i$个分数之和为$\\frac{c}{d}$，而第i个分数是1/e，则接下来至少还需要$\\frac{(\\frac{a}{b}-\\frac{c}{d})}{\\frac{1}{e}}$个分数总和才能到$\\frac{a}{b}$。比如有$\\frac{19}{45}$,当前搜索到$\\frac{1}{5}+\\frac{1}{100}+\\cdots$ ，则后面的分数每个最大为$\\frac{1}{101}$，至少需要$\\frac{(\\frac{19}{45}-\\frac{1}{5})}{\\frac{1}{101}}= 23$项才能达到$\\frac{19}{45}$，那么前面$22$次迭代是不会考虑到这棵子树的。所以跌倒加深搜索的关键可以估计至少还要多少步才能出解。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;int a, b, maxd;typedef long long LL;LL gcd(LL a, LL b) &#123; return b == 0 ? a : gcd(b, a%b);&#125;inline int get_first(LL a, LL b) &#123; return b/a +1;&#125;const int maxn = 100 + 5;LL v[maxn], ans[maxn];bool better(int d) &#123; for(int i = d; i &gt;= 0; i--)&#123; if(v[i] != ans[i]) &#123; return ans[i] == -1 || v[i] &lt; ans[i]; &#125; &#125; return false;&#125;bool dfs(int d, int from, LL a, LL b) &#123; if(d == maxd) &#123; if(b % a) return false; v[d] = b/a; if(better(d)) memcpy(ans, v, sizeof(LL) * (d+1)); return true; &#125; bool judge = false; from = max(from, get_first(a, b)); for(int i = from; ; i++) &#123; if(b * (maxd+1-d) &lt;= i * a) break; v[d] = i; LL b2 = b*i; LL a2 = a*i - b; LL g = gcd(a2, b2); if(dfs(d+1, i+1, a2/g, b2/g)) judge = true; &#125; return judge;&#125;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif int testcases = 0; while(scanf(\"%d%d\", &amp;a, &amp;b) == 2)&#123; int judge = 0; for(maxd = 1; maxd &lt;= 100; maxd++) &#123; memset(ans, -1, sizeof(ans)); if(dfs(0, get_first(a, b), a, b)) &#123; judge = 1; break; &#125; &#125; cout &lt;&lt; \"Case \" &lt;&lt; ++testcases &lt;&lt; \": \"; if(judge) &#123; cout &lt;&lt; a &lt;&lt; \"/\" &lt;&lt; b &lt;&lt; \"=\"; for(int i = 0; i &lt; maxd; i++) cout &lt;&lt; \"1/\" &lt;&lt; ans[i] &lt;&lt; \"+\"; cout &lt;&lt; \"1/\" &lt;&lt; ans[maxd] &lt;&lt; \"\\n\"; &#125; else cout &lt;&lt; \"No solution.\\n\"; &#125; return 0;&#125; 总结及拓展通常情况下我们需要设一个乐观估价函数，比如，设深度上限为$Maxd$，当前结点$n$的深度为$g(n)$，乐观估价函数为$h(n)$，则当$g(n) + h(n) &gt; Maxd$时需要进行剪枝。如果可以设计一个乐观估价函数，并预测出当前结点至少还需要扩展几层结点才可能有解，这时候迭代加深搜索与A算法结合变成了**IDA算法**。迭代加深搜索通常用于那种搜索树又深又宽、但是解并不是很深的情况，这时广度优先搜索会超空间，而深度优先搜索会超时。这时迭代加深搜索很有用，可是说是在用递归方法在实现广度优先搜索。","categories":[],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"迭代加深搜索","slug":"迭代加深搜索","permalink":"http://yoursite.com/tags/迭代加深搜索/"}]},{"title":"最优配对问题","slug":"最优配对问题","date":"2017-05-23T14:39:06.000Z","updated":"2017-05-23T15:54:37.614Z","comments":true,"path":"2017/05/23/最优配对问题/","link":"","permalink":"http://yoursite.com/2017/05/23/最优配对问题/","excerpt":"第一次学状态压缩DP，在学长的指导下（雾）终于弄明白了。现在就要用算法竞赛入门经典上的一道题来了解状压DP吧，希望这次学过状压DP之后可以不看题解自己做出NOIP Day2T3。感觉自己自己学新的知识学得好慢。 最优配对问题空间里有n个点$P_{0}, P_{1}, P_{2}，···，P_{n - 1}$，你的任务是把它们配成$\\frac{n}{2}$对（n是偶数），使得每一个点恰好在一个点对中。所有点对中两点的距离之和应尽量小。$n \\leq 20 ,\\ |x_{i}|, |y_{i}|, |z_{i}| \\leq 10000$。","text":"第一次学状态压缩DP，在学长的指导下（雾）终于弄明白了。现在就要用算法竞赛入门经典上的一道题来了解状压DP吧，希望这次学过状压DP之后可以不看题解自己做出NOIP Day2T3。感觉自己自己学新的知识学得好慢。 最优配对问题空间里有n个点$P_{0}, P_{1}, P_{2}，···，P_{n - 1}$，你的任务是把它们配成$\\frac{n}{2}$对（n是偶数），使得每一个点恰好在一个点对中。所有点对中两点的距离之和应尽量小。$n \\leq 20 ,\\ |x_{i}|, |y_{i}|, |z_{i}| \\leq 10000$。 符合动态规划的条件 既然每一个点都要配对，那么我们显然可以看出这是一个多阶段决策问题：首先配对P0，接下来是P1，然后配对P2, ···，最后是Pn-1。 我们可以用反证法来证明其满足最优子结构，无后效性以及重叠子问题的特性。 推导状态转移方程 我一看到这个题，就把它的状态定为$d(i)$ 表示把前$i$个点两两配对的最小距离之和。那么接下来我们思考第i个点和谁配对，此时我们假设它和第j个点两两配对的距离之和最小（$j &lt; i$）。那么为了从$d(i)$转移到$d(i + 1)$我们要先计算出“把前i个点中除j之外的其他点两两配对”，显然，我们无法表示“除点j之外”这个状态，所以这样定义状态不能转移。 因为我们不能转移这个状态，所以我们考虑增加维度来解决这个问题。我们用$d(i, S)$表示前$i$个点中属于集合S的点两两配对得到的最小距离。我们根据前面的思路可以得出这样的状态转移方程：怎么来理解这个状态转移方程呢？我们要求得第i个点配对后的最小距离这个状态，是依赖于前$i - 1$个点中属于集合$S - {i} - {j}$的最小距离加上点i和点j的距离之和这个状态的。其中集合$S$表示集合${1,2,3，······，n}$所有的子集，这里我们用二进制来生成子集，因为二进制生成子集的效率最高代码量也相对于较少。 从一般到优化在实现了用二维描述状态转移方程后我们思考，是否能够降低维度。我们在手推了二维的状态转移方程后，发现其实我们每次都在枚举$i$和$j$，我们考虑一个二进制的序列。既然第一个1早晚需要与后面的$1$来配对，那么我们为什么不固定这个i的位置来枚举j呢？刘汝佳先生是这么解释的：“状态可以进行压缩，$i$的值其实隐藏在S中，S中最高位为$1$的即为$i$，所以需要一次查找,从$n-1$到$0$进行一次历编即可，整个运算下来，平均查找次数仅为$2$。”这句话你手推意会一下就可以了。那么我们尝试求出二进制序列中的第一个$i$，或最后一个i从而来每次枚举j的位置。这样一来状态转移方程可以简化为一维： 代码先回顾下第七章用二进制枚举子集的方法吧！123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int n;void print_subset(int n, int s)&#123; printf(\"%d %d\\n\", n, s); for(int i = 0; i &lt; n; i++)&#123; if(s &amp; (1&lt;&lt;i)) printf(\"%d \", i); &#125; printf(\"\\n\");&#125;int main()&#123;#ifndef DEBUG //freopen(\"test1.in\",\"r\",stdin);#endif scanf(\"%d\", &amp;n); for(int i = 0; i &lt; (1&lt;&lt;n); i++)&#123;// i = 0 ~ 2的n次方 - 1 print_subset(n, i); &#125; return 0;&#125; 方法一：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAX = 20 + 3;const double INF = 1e9;int n, S;struct Node&#123; int x, y, z;&#125;node[MAX];double dp[MAX][1 &lt;&lt; MAX];double dis(Node &amp;a, Node &amp;b)&#123; return sqrt((double)(a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y) + (a.z - b.z)*(a.z - b.z));&#125;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) scanf(\"%d%d%d\", &amp;node[i].x, &amp;node[i].y, &amp;node[i].z); for(int i = 0; i &lt; n; i++)&#123; for(int s = 0; s &lt; (1 &lt;&lt; (i + 1)); s++)&#123; if(s == 0) dp[i][s] = 0; else dp[i][s] = INF; if((s &amp; (1 &lt;&lt; i)))&#123; for(int j = i - 1; j &gt;= 0; j--) if((s &amp; (1 &lt;&lt; j))) dp[i][s] = min(dp[i][s], dis(node[i], node[j]) + dp[i - 1][s^(1 &lt;&lt; i)^(1 &lt;&lt; j)]); &#125; else if(i != 0)&#123; dp[i][s] = dp[i - 1][s]; &#125; &#125; &#125; printf(\"%.3lf\\n\", dp[n - 1][(1 &lt;&lt; n) - 1]); return 0;&#125; 方法二：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int MAX = 20 + 3;const double INF = 1e9;int n, S;struct Node&#123; int x, y, z;&#125;node[MAX];double dp[1 &lt;&lt; MAX];double dis(Node &amp;a, Node &amp;b)&#123; return sqrt((double)(a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y) + (a.z - b.z)*(a.z - b.z));&#125;int main()&#123;#ifndef DEBUG //freopen(\"test1.in\",\"r\",stdin);#endif scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) scanf(\"%d%d%d\", &amp;node[i].x, &amp;node[i].y, &amp;node[i].z); dp[0] = 0; for(int S = 1; S &lt; (1 &lt;&lt; n); S++)&#123; int i, j; dp[S] = INF; for(i = 0; i &lt; n; i++) if(S &amp; (1 &lt;&lt; i)) break; for(j = i + 1; j &lt; n; j++) if(S &amp; (1 &lt;&lt; j)) dp[S] = min(dp[S], dis(node[i], node[j]) + dp[S^(1 &lt;&lt; i)^(1 &lt;&lt; j)]); &#125; printf(\"%.3lf\\n\", dp[1 &lt;&lt; n - 1]);//注意运算优先级 return 0;&#125; 总结好啦，到此为止最优配对问题就做出来了。那么现在你明白了状压DP是什么了吗？其实我们从这道状压的基本题就可以看出状压DP实际上是将平面上离散的点压进二进制表示的集合中，有时候题目中不一定明确的说明它是离散的点，有时候可能是图的顶点，数轴上的坐标。那么我们怎样通过一道题目的描述知道这道题目的知识点是考状压DP的呢？最显著的一个特点是题目中的n通常很小，通常小于23，这时候你可能会问为什么？首先我们明白状压DP是把离散的点压成二进制表示的集合，我们假设我们可以用一维数组来表示状态，通常情况下空间有32M，换算成int类的字节就是8388608字节，等于2的23次方。所以呀n不能太大，不然空间会爆掉的0w0！","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"状压DP","slug":"状压DP","permalink":"http://yoursite.com/tags/状压DP/"}]},{"title":"Uva 816 - Abbott's Revenge","slug":"Uva-816-Abbott-s-Revenge","date":"2017-05-23T14:33:38.000Z","updated":"2017-05-28T04:30:38.350Z","comments":true,"path":"2017/05/23/Uva-816-Abbott-s-Revenge/","link":"","permalink":"http://yoursite.com/2017/05/23/Uva-816-Abbott-s-Revenge/","excerpt":"表示蒟蒻搜索弱爆了，还是做题太少了。 题目地址 描述有一个最多包含$9\\cdot 9$个交叉点的迷宫。输入起点， 离开起点时的朝向和终点，求一条最短路（多解时任意输出一个即可）。","text":"表示蒟蒻搜索弱爆了，还是做题太少了。 题目地址 描述有一个最多包含$9\\cdot 9$个交叉点的迷宫。输入起点， 离开起点时的朝向和终点，求一条最短路（多解时任意输出一个即可）。 分析这道迷宫类型的题和以往有些不一样，这次又增添了许多细节和限制条件。如，进入一个交叉点的方向（用$NEWS$这四个字母分别表示北东四南）不同，允许出去的方向也不同（$FLR$这三个字母分别是直行左转和右转）。到这里为止，通过已有的题意描述，很自然你会想到第三章节《数组和字符串》中对于常量数组的应用。接着往下继续，去掉以上这些细节的牵制，这道题目本质上和其它的迷宫题是一样的，但是对于这道题朝向是起到了至关重要的作用，所#E以这里我们用一个三元组$(r,c,dir)$来描述位于$(r,c)$面朝$dir$的状态。对于我们设置的这个状态，我们假设入口位置的坐标是$(r, c)$，朝向$dir$，但是实际上初始状态并不是$(r,c,dir)$，而是$(r’,c’,dir’)$沿方向$dir$走一步之后的坐标。然后用$d[r][c][dir]$表示初始状态到$(r, c, dir)$的最短路的长度， 并且用$p[r][c][dir]$ 来保存状态$(r, c, dir)$在$BFS$树中的父节点（一遍后来打印路径可以应用$vector$保存结点，用循环避免递归时溢出，并且更加灵活）。 对于很多迷宫问题都可以转化为最短路问题通过$BFS$和$DFS$来求解。但是在套用框架之前，我们一定要明白这两种搜索方式的适用范围，和图中结点所包含的内容。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const double Pi = 4 * atan(1);const int MAX = 200 + 3;int dr[] = &#123;-1, 0, 1, 0&#125;;int dc[] = &#123;0, 1, 0, -1&#125;;struct Node&#123; int r, c, dir; Node(int rr, int cc, int dd)&#123; r = rr; c = cc; dir = dd; &#125; Node()&#123;&#125;&#125;;const char * dirs = \"NESW\";const char * turns = \"FLR\";bool Edge[10][10][4][4];int d[10][10][4];int r1,c1,dir;int r0,c0;int r2,c2;bool flag;Node p[10][10][4];int dir_id(char C) &#123; return strchr(dirs, C) - dirs; &#125;int turn_id(char C) &#123; return strchr(turns, C) - turns; &#125;Node Walk(const Node&amp; u, int turn)&#123; int dir = u.dir; if(turn == 1) dir = (dir + 3) % 4; if(turn == 2) dir = (dir + 1) % 4; return Node(u.r + dr[dir], u.c + dc[dir], dir);&#125;bool inside(int r, int c)&#123; if(r &gt; 0 &amp;&amp; r &lt; 10 &amp;&amp; c &gt; 0 &amp;&amp; c &lt; 10) return true; return false;&#125;void print_ans(Node u)&#123; vector&lt;Node&gt; vec; while(1)&#123; vec.push_back(u); if(d[u.r][u.c][u.dir] == 0) break; u = p[u.r][u.c][u.dir]; &#125; vec.push_back(Node(r0, c0, dir)); int cnt = 0; for(int i = vec.size() - 1; i &gt;= 0; i --)&#123; if(cnt % 10 == 0) printf(\" \"); printf(\" (%d,%d)\", vec[i].r, vec[i].c); if(++ cnt % 10 == 0) printf(\"\\n\"); &#125; if(vec.size() % 10 != 0) printf(\"\\n\");&#125;void Bfs()&#123; queue&lt;Node&gt; q; memset(d, -1, sizeof(d)); memset(p, 0, sizeof(p)); Node u(r1, c1, dir); d[u.r][u.c][u.dir] = 0; q.push(u); while(!q.empty())&#123; Node u = q.front(); q.pop(); if(u.r == r2 &amp;&amp; u.c == c2)&#123; flag = 0; print_ans(u); return; &#125; for(int i = 0; i &lt; 3; i ++)&#123; Node v = Walk(u, i); if(Edge[u.r][u.c][u.dir][i] &amp;&amp; inside(v.r, v.c) &amp;&amp; d[v.r][v.c][v.dir] &lt; 0)&#123; d[v.r][v.c][v.dir] = d[u.r][u.c][u.dir] + 1; p[v.r][v.c][v.dir] = u; q.push(v); &#125; &#125; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE //freopen(\"test.in\",\"r\",stdin);#endif char str[30]; while(~scanf(\"%s\",str) &amp;&amp; strcmp(str,\"END\"))&#123; printf(\"%s\\n\",str); flag = 1; memset(Edge,0,sizeof(Edge)); char ch; cin &gt;&gt; r0 &gt;&gt; c0 &gt;&gt; ch &gt;&gt; r2 &gt;&gt; c2; dir = dir_id(ch); r1 = r0 + dr[dir]; c1 = c0 + dc[dir]; int r,c; char str2[30]; while(cin &gt;&gt; r)&#123; if(r == 0)&#123; break; &#125; cin &gt;&gt; c; while(cin &gt;&gt; str2)&#123; if(str2[0] == '*') break; int dirID = dir_id(str2[0]); int len = strlen(str2); for(int i = 1;i &lt; len;i++)&#123; int turnID = turn_id(str2[i]); Edge[r][c][dirID][turnID] = 1; &#125; &#125; &#125; Bfs(); if(flag)&#123; cout &lt;&lt; \" No Solution Possible\" &lt;&lt; endl; &#125; getchar(); &#125; return 0;&#125; $update$: 无权图上的最短路可用BFS求解","categories":[],"tags":[{"name":"DFS及BFS","slug":"DFS及BFS","permalink":"http://yoursite.com/tags/DFS及BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"暴力","slug":"暴力","permalink":"http://yoursite.com/tags/暴力/"}]},{"title":"UVa 10976 - Fractions Again?!","slug":"UVa-10976-Fractions-Again","date":"2017-05-23T14:19:51.000Z","updated":"2017-05-28T04:32:09.055Z","comments":true,"path":"2017/05/23/UVa-10976-Fractions-Again/","link":"","permalink":"http://yoursite.com/2017/05/23/UVa-10976-Fractions-Again/","excerpt":"题目描述 描述输入正整数K，找出所有得正整数 $x\\geq y$，使得$\\frac{1}{k}=\\frac{1}{x}+\\frac{1}{y}$。","text":"题目描述 描述输入正整数K，找出所有得正整数 $x\\geq y$，使得$\\frac{1}{k}=\\frac{1}{x}+\\frac{1}{y}$。 分析首先想到的是枚举出所有的正整数$x，y$使之成立。那么枚举的范围如何确定呢？有样例我们可以看出x，y之间的大小差别可大可小。再反过来观察题目中所给出的条件正整数$x，y$，$x\\geq y$ ,由此可知必然有 $\\frac{1}{x}\\leq \\frac{1}{y}$。那么 $\\frac{1}{k}=\\frac{1}{x}+\\frac{1}{y}$就可以转换成为 $\\frac{1}{k}-\\frac{1}{y}\\leq \\frac{1}{y}$，即$y\\leq 2k$。至此我们就求出了枚举的范围了，接下来只用在$2k$的范围内枚举$y$，然后根据尝试计算出$x$即可。 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;utility&gt;//pair#include &lt;algorithm&gt;using namespace std;int k;vector&lt; pair&lt;int, int&gt; &gt; vec;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif while(scanf(\"%d\\n\", &amp;k) == 1)&#123; int sum = 0; vec.clear(); for(int i = k + 1; i &lt;= 2 * k; i ++)&#123; if((i * k) % (i - k) == 0)&#123; sum ++; vec.push_back(make_pair((i * k) / (i - k), i)); &#125; &#125; printf(\"%d\\n\", sum); for(unsigned int i = 0; i &lt; vec.size(); i ++) printf(\"1/%d = 1/%d + 1/%d\\n\", k, vec[i].first, vec[i].second); &#125; return 0;&#125; 这里灵活的应用了pair 和 make_pair。同时还要注意到循环的边界。","categories":[],"tags":[{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"暴力","slug":"暴力","permalink":"http://yoursite.com/tags/暴力/"}]},{"title":"UVa 839 - Not so Mobile","slug":"UVa-839-Not-so-Mobile","date":"2017-05-23T14:10:51.000Z","updated":"2017-05-28T04:30:51.340Z","comments":true,"path":"2017/05/23/UVa-839-Not-so-Mobile/","link":"","permalink":"http://yoursite.com/2017/05/23/UVa-839-Not-so-Mobile/","excerpt":"题目地址 描述输入一个树状天平，根据力矩相等原则判断是否平衡（$W_{l}\\cdot D_{l} = W_{r}\\cdot D_{r}$）。采用先序（递归）方式输入：每一个天平的格式为$W_{l},D_{l},W_{r},D_{r}$，当$W_{l}$ 或 $W_{r}$为$0$时，表示该砝码实际上是一个子天平，接下来会描述这个子天平。当$W_{l} = W_{r} = 0$时，会先描述左子天平，然后是右子天平。","text":"题目地址 描述输入一个树状天平，根据力矩相等原则判断是否平衡（$W_{l}\\cdot D_{l} = W_{r}\\cdot D_{r}$）。采用先序（递归）方式输入：每一个天平的格式为$W_{l},D_{l},W_{r},D_{r}$，当$W_{l}$ 或 $W_{r}$为$0$时，表示该砝码实际上是一个子天平，接下来会描述这个子天平。当$W_{l} = W_{r} = 0$时，会先描述左子天平，然后是右子天平。 分析如图首先根据所给出的样例来理解题意。理解题意之后再来仔细看这道题，因为这道题目的输入是递归输入，所以我们就顺着题意走，用递归来建树。写一个bool solve，在建树的过程中同时完成判断（使用引用传值），输入一个子天平，返回子天平是否平衡，将参数W修改为子天平的总重量，这样由最下层的子天平逐渐递归到树状天平的根。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int T,W;bool solve(int&amp; W)&#123; int W1, D1, W2, D2; bool b1 = true; bool b2 = true; cin &gt;&gt; W1 &gt;&gt; D1 &gt;&gt; W2 &gt;&gt; D2; if(!W1) b1 = solve(W1); if(!W2) b2 = solve(W2); W = W1 + W2; return b1 &amp;&amp; b2 &amp;&amp; (W1 * D1 == W2 * D2);&#125;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif scanf(\"%d\", &amp;T); while(T --)&#123; if(solve(W)) printf(\"YES\\n\"); else printf(\"NO\\n\"); if(T) printf(\"\\n\"); &#125; return 0;&#125; 每次在写递归的时候一定要多问自己几次递归的定义，递归的步骤，递归结束的条件是什么。一个类似的题目。UVa 699最后推荐一篇关于递归入门的好文章。递归算法详解把前面丢失的博客找回来了，(^o^)/","categories":[],"tags":[{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"二叉树的递归遍历","slug":"二叉树的递归遍历","permalink":"http://yoursite.com/tags/二叉树的递归遍历/"}]},{"title":"路径寻找问题及哈希表","slug":"路径寻找问题及哈希表","date":"2017-05-23T13:59:51.000Z","updated":"2017-05-23T15:18:46.858Z","comments":true,"path":"2017/05/23/路径寻找问题及哈希表/","link":"","permalink":"http://yoursite.com/2017/05/23/路径寻找问题及哈希表/","excerpt":"这一篇Blog着重写的应该是Hash吧，路径寻找问题在应用中会稍微提到一点。 定义 若关键字为k，则其值存放在f(k) 的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系 f为散列函数，按这个思想建立的表为散列表。 对不同的关键字可能得到同一散列地址，即k1 ≠ k2 ，而 f(k1) = f(k2)，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数 f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。 若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数，这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。","text":"这一篇Blog着重写的应该是Hash吧，路径寻找问题在应用中会稍微提到一点。 定义 若关键字为k，则其值存放在f(k) 的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系 f为散列函数，按这个思想建立的表为散列表。 对不同的关键字可能得到同一散列地址，即k1 ≠ k2 ，而 f(k1) = f(k2)，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数 f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。 若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数，这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。 应用八数码问题描述编号为1~8的8个正方形滑块被摆成3行3列（有一个格子留空），如图7-14所示。每次可以把与空格相邻的滑块（有公共边才算相邻）移到空格中，而它原来的位置就成为了新的空格。给定初始局面和目标局面（用0表示空格），你的任务是计算出最少的移动步数，如果无法到达目标局面，则输出-1。 图7 - 14 分析看完题目之后，我们不难想到将八数码问题归结为图上的最短路问题，图中的结点就是9个格子里的滑块编号（从上到下，从左到右把它们放在一个包含9个元素的数组中）。而且这副图上的权都为1，所以不难想到用BFS来求解。而且，只要用到BFS一定要进行判重，为避免同一个结点访问很多次，提高空间和时间复杂度（树的BFS不用判重，而图的BFS要进行判重，想一想为什么？）。对于判重而言，就有很多种方式了。 第一种方法是：把排列变为整数，然后开一个一维数组。也就是设计一套排列的编码和解码函数，然后一一对应起来。 第二种方法是用STL里的set集合，先把状态转换为9为十进制整数，然后用set进行判重。但这两种办法对于需要判重的数很多的时候，不仅不会降低复杂度反而还会提升。 第三种做法哈希表。简而言之就是把结点变为整数，但不一定是要一一对应的，只需要设计一个哈希函数，然后将任意结点映射到某一个指定范围[0，M - 1]内，其中M是由我们自己定的，要根据要开的数组大小来选择（也就是我们说得HashSize）。而HushSize有是有目前的数的个数（结点的个数）来确定的，通常在估算完结点个数后，取比结点个数大20%~50%的质数作为HushSize。每次用数模HushSize，然后取其余数，把这个数接到余数所对应的链表后。举一个栗子，如图我们有数7, 12，29，38，57，98。这里我们取HushSize为11，7mod11余7（所以把7放在链表从上往下数0,1,2,3,4,5,6,7，第七个位置后接起来），对于mod之后余数相同的数，我们的做法不同图上所显示的方法，而是要充分的利用链表的特性把大的数放在前面（相同的每次用vector来push_back把大的数放在后面，但是由于每用STL时都要动态的分配空间，同样会使时间复杂度升高），所以这里我们采用刘汝佳的方法，用数组模拟链表来做。1234567891011121314151617181920212223const int hashsize = 1000003;int head[hashsize], next[MaxState];void init_lookup_table()&#123;memset(head, 0, sizeof(head));&#125;int hash(State&amp; s)&#123; int v = 0; for(int i = 0; i &lt; 9; i++) v = v * 10 + s[i];//把九个数字组合成九位数（对于八数码而言） return v % hashsize;//确保Hash函数的值是不超过Huah表的大小的非负整数&#125;int try_to_insert(int s)&#123; int h = hash(st[s]);//调用Hush int u = head[h];//从表头开始查找链表 while(u)&#123; if(memcmp(st[u], st[s], sizeof(st[s])) == 0) return 0;//找到了重复的，所以插入失败 u = next[u];//顺着链表继续找 &#125; next[s] = head[h];//插入链表中 head[h] = s; return 1;&#125; 想一想为什么最后才将数插入链表，顺序为什么是这样子的？在看完Hush算法后，我们再回来理一理这道题目的思路。首先，把这道题目归结为路径寻找问题，想到用BFS来求解（套用BFS框架）；因为BFS要判重所以我们引入Hush。最后提一下这道题目中一个重要的技巧，也就是使用Hush的一个前提之一，将3*3的格子中的每行或三列的三个数由字符转为一个三位数。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;typedef int State[9];const int MaxState = 1000000;State st[MaxState], goal;int dist[MaxState];const int dx[] = &#123; -1, 1, 0, 0&#125;;const int dy[] = &#123; 0, 0, -1, 1&#125;;const int hashsize = 1000003;int head[hashsize], next[MaxState];void init_lookup_table()&#123;memset(head, 0, sizeof(head));&#125;int hash(State&amp; s)&#123; int v = 0; for(int i = 0; i &lt; 9; i++) v = v * 10 + s[i]; return v % hashsize;&#125;int try_to_insert(int s)&#123; int h = hash(st[s]); int u = head[h]; while(u)&#123; if(memcmp(st[u], st[s], sizeof(st[s])) == 0) return 0; u = next[u]; &#125; next[s] = head[h]; head[h] = s; return 1;&#125;int bfs()&#123; init_lookup_table(); int front = 1, rear = 2; while(front &lt; rear)&#123; State&amp; s = st[front]; if(memcmp(goal, s, sizeof(s)) == 0) return front; int z; for(z = 0; z &lt; 9; z++) if(!s[z]) break; int x = z / 3, y = z % 3; for(int d = 0; d &lt; 4; d++)&#123; int NewX = x + dx[d]; int NewY = y + dy[d]; int NewZ = NewX * 3 + NewY; if(NewX &gt;= 0 &amp;&amp; NewX &lt; 3 &amp;&amp; NewY &gt;= 0 &amp;&amp; NewY &lt; 3)&#123; State&amp; t = st[rear]; memcpy(&amp;t, &amp;s, sizeof(s)); t[NewZ] = s[z]; t[z] = s[NewZ]; dist[rear] = dist[front] + 1; if(try_to_insert(rear)) rear++; &#125; &#125; front++; &#125; return 0;&#125;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif for(int i = 0; i &lt; 9; i++) scanf(\"%d\", &amp;st[1][i]); for(int i = 0; i &lt; 9; i++) scanf(\"%d\", &amp;goal[i]); int ans = bfs(); if(ans &gt; 0) printf(\"%d\\n\", dist[ans]); else printf(\"-1\\n\"); return 0;&#125; 拓展很多问题都可以和归结为图的遍历，但这些问题中图不是是事先给出的，从程序读入的，而是有程序动态生成的，称为隐式图。回溯法（关于回溯法的总结我就先不写啦，有时间再来填坑吧！^-^）一般是要找一个（或所有）满足约束状态的解（或者是某种意义状态下的最优解），而状态空间搜索一般是要寻找一个从初始状态到终止状态的路径，所以把路径寻找问题归结为隐式图的遍历。隐式图的遍历需要一个结点查找表来判重，一般可以先用STL中的set来写（代码量最小，最简单，但时间效率很低），后面有时间在将其用Hush的方式来写一遍，避免出错，如果你对Hush表很熟练，那么就可以直接写哒！","categories":[],"tags":[{"name":"DFS及BFS","slug":"DFS及BFS","permalink":"http://yoursite.com/tags/DFS及BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]}]}