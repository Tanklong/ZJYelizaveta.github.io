{"meta":{"title":"ZJYelizaveta's Blog","subtitle":"有幸在那一天，遇到你，最了不起的你。","description":"有幸在那一天，遇到你，最了不起的你。","author":"ZJYelizaveta","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2017-10-21T15:28:32.000Z","updated":"2017-10-21T15:29:51.397Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"I’m an OIer.来自武汉二中，现役高二 QAQ颜控，沉迷于羽生结弦在初中同桌的安利下喜欢上了《空中浩劫》，尤其喜欢在坐飞机之前看嗯，然后没有了想和学长学姐一起去THU 我一直相信一句话：“无论你遇见谁，他都是你生命里该出现的人，绝非偶然，他一定会教会你一些什么。”所以我也相信：“无论我走到哪里，那都是我该去的地方，经历一些我该经历的事，遇见我该遇见的人。” 联系方式：ZJYelizaveta@outlook.comQQ：贰肆叁玖伍玖玖柒陆零(2439599760)很希望认识你们！"},{"title":"Links","date":"2017-10-21T15:19:30.000Z","updated":"2017-10-21T15:21:18.552Z","comments":true,"path":"Links/index.html","permalink":"http://yoursite.com/Links/index.html","excerpt":"","text":"chrt’s Bloghamsterwk’s BlogSengxian’s BlogBarrin’s Blog"},{"title":"Categories","date":"2017-10-22T02:27:29.000Z","updated":"2017-10-23T14:49:21.042Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"过段时间再写吧，太懒了qwq"}],"posts":[{"title":"无题","slug":"无题","date":"2017-11-21T03:11:11.000Z","updated":"2017-11-23T21:54:59.421Z","comments":true,"path":"2017/11/21/无题/","link":"","permalink":"http://yoursite.com/2017/11/21/无题/","excerpt":"不畏将来，不念过往","text":"不畏将来，不念过往 2017 年 11 月 20 号，从我开始学 OI 到现在已经一年零三个月了，感觉现在的我和去年的我相比并没有什么本质上的进步，大概就是基础算法掌握的更加熟练以及学了其他一些高级的算法和数据结构。可是其他呢？写不出正解的题目能把暴力分都拿满吗，能独立 A 一道题目吗，达到了我的预期目标吗？这些问题的答案似乎都是不能和没有。 我从 2017 年 1 月开始写博客，最初开始写博客的初衷是记录一下我对于一些题目的感悟，从而达到做一道题目就把一道题目做好的目的；以及想成为和学长一样对别人有帮助的人，希望看到我的博客的人可以少走一些我曾今走过的弯路。 现在看来，这两个初衷我都没有达到或者是从未达到。 现在看以前写的题解，所有的题目几乎都还是停留在理解上面，仅仅是理解了这道题目怎样做，那么把题目变一下我还会做吗？答案是不确定的。那么做这道题目于我而言除了 AC 题目的数量增加以外，还有什么呢？为了追求做题的数量以及我认为的质量，刷题——写博客——刷题…… 似乎在之前的一段时间内成为了我每天的常态，而这些对于代码能力和思维水平的提高毫无意义。 以上说了这么多，大概都是为了这句话：“从今天开始，博客无期限停更。当我能在写不出来正解的时候把暴力分拿满，能独立 A 一些有质量的题目，能真正理解并运用我所学过的知识，能写出对自己和他人都有帮助的学习笔记或者解题报告的时候，我会重新回来。” 这么悲伤消极的文风好像不太适合我，盼早日归来的 qwq 所以，亲爱的你们。 当你遭遇背叛，不要伤心，最好的永远会在下一个拐角处； 当你遭遇人生低谷，不要难过，巅峰之前的上坡路，总是艰难又充满坎坷； 当你面对失败的选择，不要懊恼，你永远不知道上帝发给你的下一张牌是什么； 当你碰到不公正的对待，不要愤怒，天平倾斜的背后，是筹码的加压； 当你身处最黑暗的死胡同，不要气馁不要绝望。人生最明亮的一束光，往往就在这个时候出现。 你所失去的，终将会以另外一种方式，回到你身边。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"WHEZOJ Easy Round 4 简要题解","slug":"WHEZOJ-Easy-Round-4-简要题解","date":"2017-11-09T06:41:50.000Z","updated":"2017-11-09T06:45:32.764Z","comments":true,"path":"2017/11/09/WHEZOJ-Easy-Round-4-简要题解/","link":"","permalink":"http://yoursite.com/2017/11/09/WHEZOJ-Easy-Round-4-简要题解/","excerpt":"简单描述大道至简，这就是出题人没有写题目背景的原因。 给出 $2n$ 个数字，skipher 打算将它们划分成 $n$ 组，每组的得分为这一组中两个数字的较小值，求最大得分。 对于 $100\\%$ 的数据，$n\\le 100000,1\\le a_i\\le 10^9$。","text":"简单描述大道至简，这就是出题人没有写题目背景的原因。 给出 $2n$ 个数字，skipher 打算将它们划分成 $n$ 组，每组的得分为这一组中两个数字的较小值，求最大得分。 对于 $100\\%$ 的数据，$n\\le 100000,1\\le a_i\\le 10^9$。 分析一道比较简单的贪心题目，考试的时候因为不会证明贪心的正确性，写了一个暴力的部分分 qwq 将原序列排序，每次取第 $i$ 个数放到第一个序列中，取第 $i + 1$ 个数放到第二个序列中，然后 $\\Theta(n)$ 扫一遍，去两个序列中的最小值即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// Created by ZJYelizaveta on Tuesday, November 07, 2017 PM01:11:36 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100000 + 3;const int INF = 0x3f3f3f3f;int n, m;ll a[MAX_N &lt;&lt; 1];namespace subtaskOne &#123; int vis[MAX_N &lt;&lt; 1]; ll ans; inline int count(int x) &#123; return __builtin_popcount(x); &#125; ll s1[MAX_N], s2[MAX_N]; inline ll calculate() &#123;// for (int i = 0; i &lt; m; ++i) printf(\"%d \", vis[i]); printf(\"\\n\"); int cnt1 = 0, cnt2 = 0; for (int i = 0; i &lt; m; ++i) &#123; if (vis[i]) s1[cnt1++] = a[i]; else s2[cnt2++] = a[i]; &#125; sort(s1, s1 + cnt1); sort(s2, s2 + cnt2); ll res = 0; for (int i = 0; i &lt; cnt1; ++i) res = res + min(s1[i], s2[i]); return res; &#125; inline void solve(int sum) &#123; ans = 0; for (int S = 0; S &lt; sum; ++S) if (count(S) == n) &#123; memset(vis, 0, sizeof vis); for (int i = 0; i &lt; m; ++i) if (S &amp; (1 &lt;&lt; i)) &#123; vis[i] = 1; &#125; ans = max(ans, calculate()); &#125; printf(\"%lld\\n\", ans); &#125;&#125;namespace subtaskTwo &#123; ll s1[MAX_N], s2[MAX_N], ans; inline void solve() &#123; sort(a, a + m); int cnt = 0; for (int i = 0; i &lt; m; i += 2) &#123; s1[cnt] = a[i]; s2[cnt] = a[i + 1]; ++cnt; &#125; ans = 0; for (int i = 0; i &lt; cnt; ++i) ans += min(s1[i], s2[i]); printf(\"%lld\\n\", ans); &#125;&#125;int main()&#123; freopen(\"simple.in\", \"r\", stdin); freopen(\"simple.out\", \"w\", stdout); n = readIn&lt;int&gt;(); m = 2 * n; for (int i = 0; i &lt; m; ++i) a[i] = readIn&lt;ll&gt;(); if (n &lt;= 8) subtaskOne::solve((1 &lt;&lt; m) - 1); else subtaskTwo::solve(); return 0;&#125; 刷题描述现在 $n$ 张卷子，第 $i$ 张卷子的难度是 $d_i$。 现在 skipher 要从第 $1$ 张卷子刷到第 $n$ 张卷子。 如果他做完了第 $i$ 张卷子，那么他可以选择做第 $i+1,i+2,\\ldots,i+k$ 张卷子（dalao 做题总是有选择性的）。 如果 skipher 选择做一张难度值不小于当前卷子难度的卷子，那么他的劳累值会 $+1$，否则不会。 为了保证足够的刷题量，同时保留足够的精力使得期中考试 AK，skipher 打算最小化劳累值。你可以认为一开始 skipher 已经刷掉了第一张卷子且劳累值为 $0$，且你必须保证 skipher 做完了第 $n$ 张卷子——压轴卷。 有 $Q$ 组询问，每组询问中 $k$ 值不同。 对于 $100\\%$ 的数据，$n\\le 10^6,Q \\le 5, d_i \\le {10}^9$。 分析没有看出来是单调队列优化 dp，用贪心水了 80 分 qwq 令 $dp[i]$ 为做到第 $i$ 张卷子最小的劳累值。 那么有一个 $\\Theta(n^{2})$ 的 dp 方程： dp[i] = \\underset{min(0, i - k) \\leq j < i}{min}\\left\\{\\begin{matrix} dp[j] + 1 & (d[j] \\leq d[i])\\\\ dp[j] & (d[j] > d[i]) \\end{matrix}\\right.对于两个位置 $j, k (j &lt; k)$ ，如果有 $dp[j] &lt; dp[k]$ ，那么 $j$ 一定优于 $k$ ，因为就算 $d[j] \\leq d[i] &lt; d[k]$ ，那么顶多是由 $dp[j] \\rightarrow dp[i]$ 和从 $dp[k] \\rightarrow dp[i]$ 的 $dp[i]$ 值是相等的。 所以维护一个第一关键字是 $dp$ 值，第二关键字是劳累值的单调队列，单调队列中保存的是位置。 如果存在 $dp[j] = dp[k]$ ，那么比较两个位置上的劳累值，劳累值更大的更优。 这样可以用单调队列 $\\Theta(n)$ 的来求啦，具体细节看代码，总时间复杂度 $\\Theta(nq)$ 。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Created by ZJYelizaveta on Thursday, November 09, 2017 AM11:52:31 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000000 + 3;const int INF = 0x3f3f3f3f;int n;int h[MAX_N];int dp[MAX_N];int q[MAX_N];inline void solve(int k) &#123; int head = 1, tail = 1; q[tail++] = 1; for (int i = 2; i &lt;= n; ++i) &#123; while (head &lt; tail &amp;&amp; q[head] + k &lt; i) ++head; dp[i] = dp[q[head]] + (h[q[head]] &lt;= h[i] ? 1 : 0); while (head &lt; tail &amp;&amp; (dp[i] &lt; dp[q[tail - 1]] || dp[i] == dp[q[tail - 1]] &amp;&amp; h[q[tail - 1]] &lt;= h[i])) --tail; q[tail++] = i; &#125; printf(\"%d\\n\", dp[n]);&#125;int main()&#123; n = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) h[i] = readIn&lt;int&gt;(); int q = readIn&lt;int&gt;(); while (q--) &#123; int k = readIn&lt;int&gt;(); solve(k); &#125; return 0;&#125; 礼物描述skipher 想给他的妹子买圣诞礼物。 现在有 $n$ 件物品，skipher 想制作一个订单。对于每件物品 $i$，它的原价是 $v_i$, 每个物品 $i$ 有一张优惠劵，可以再原价的基础上便宜 $m_i$，但使用优惠劵是有限制的，如果要使用 $i$ 物品的优惠劵，则还需要使用另一给定物品 $p_i$ 的优惠劵。换句话说如果 skipher 的订单中同时包含物品 $p_i(1\\le p_i&lt; i)$，并且使用了 $p_i$ 的优惠劵，则购买物品 $i$ 的时候可以在原价的基础上便宜 $m_i$，每件物品仅可购买一次， 并且第一个物品没有限制，也就是说第一个物品的价格就是 $v_1 - m_1$。 现在 skipher 有 $S$ 元，请问他最多可以购买多少物品呢？ 对于 $60\\%$ 的数据，满足 $n\\le 500$； 对于 $100\\%$ 的数据，满足 $n\\le 5000, S\\le 10^9, 1\\le m_i &lt; v _i\\le 10^9$。 分析看出来了是一个有依赖的树形 dp 呢，但是由于是无智商选手所以有些细节没想清楚，连 $\\Theta(n^{3})$ 的 dp 都没有写出来呢， 所以最后就只交了一个 $\\Theta(2^{n}n)$ 的暴力 qwq 根据题目中的依赖关系来连边，然后连完边之后发现这是一个有根树，因为点 $1$ 没有依赖关系所以 $1$ 为根，同时 $p_{i} &lt; i$ 保证了这个依赖关系中不存在环。在点 $i$ 处使用优惠券意味着可以折扣购买点 $i$ ，同事也意味着必须选择结点 $p_{i}$ ；当然也可以选择原价购买点 $i$ 处的商品。 这样一来我们就有一个 dp 转移方程。 令 $f[i][j]$ 为在购买了商品 $i$ （使用了 $i$ 的优惠券）在 $i$ 的子树中购买了 $j$ 个商品（可以使用优惠券）的最小花费。 $g[i][j]$ 为在 $i$ 的字数中购买了 $j$ 个商品且不使用优惠券的最小花费。 很明显，对于所有的叶子结点初始化为： f[i][0] = \\textrm{INF}, f[i][1] = v_{i} - m_{i} , g[i][1] = v_{i}有转移方程： f[i][j + k] = min(f[i][j + k], f[i][j] + min(f[son(i)][k], g[son(i)][k])); \\\\ g[i][j + k] = min(g[i][j + k], g[i][j] + g[son(i)][k])我们可以证明这个转移方程实现的时候的时间复杂度是 $\\Theta(n^{2})$ 而不是 $\\Theta(n^{3})$ 的，这里没时间进行详细的证明，等有时间再来填吧！感性的理解一下，一个是更新所有的子树，再对当前节点进行更新；而将 size[u] += size[v] 放在最后，则相当于我们每次只对一个子树进行统计和转移，完成后将此子树“合并”到当前节点，也就是它的父亲中。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Created by ZJYelizaveta on 2017年11月09日 星期四 19时15分07秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 5000 + 3;const int INF = 0x3f3f3f3f;int n; ll S;ll v[MAX_N], m[MAX_N];vector&lt;int&gt; G[MAX_N &lt;&lt; 1];ll f[MAX_N][MAX_N], g[MAX_N][MAX_N];int size[MAX_N];ll tmpf[MAX_N], tmpg[MAX_N];inline void dfs(int u) &#123; size[u] = 1; f[u][0] = INF, f[u][1] = v[u] - m[u], g[u][1] = v[u]; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; int v = G[u][i]; dfs(v); memset(tmpf, INF, sizeof tmpf); memset(tmpg, INF, sizeof tmpg); // size[u] += size[v] 时间复杂度 $\\Theta(n^&#123;3&#125;)$ for (int j = 0; j &lt;= size[u]; ++j) &#123; for (int k = 0; k &lt;= size[v]; ++k) &#123; tmpf[j + k] = min(tmpf[j + k], f[u][j] + min(f[v][k], g[v][k])); tmpg[j + k] = min(tmpg[j + k], g[u][j] + g[v][k]); &#125; &#125; memcpy(f[u], tmpf, sizeof tmpf); memcpy(g[u], tmpg, sizeof tmpg); size[u] += size[v]; &#125;&#125;int main()&#123; n = readIn&lt;int&gt;(), S = readIn&lt;ll&gt;(); for (int i = 0; i &lt; n; ++i) &#123; v[i] = readIn&lt;ll&gt;(), m[i] = readIn&lt;ll&gt;(); if (i) &#123; int u = readIn&lt;int&gt;() - 1; G[u].push_back(i); &#125; &#125; dfs(0); int mx = -INF; for (int i = 0; i &lt;= n; ++i) if (min(f[0][i], g[0][i]) &lt;= S) &#123; mx = max(mx, i); &#125; printf(\"%d\\n\", mx); return 0;&#125;","categories":[],"tags":[{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/单调队列/"},{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"},{"name":"树形 dp","slug":"树形-dp","permalink":"http://yoursite.com/tags/树形-dp/"}]},{"title":"BZOJ 1036: [ZJOI2008]树的统计Count","slug":"BZOJ-1036-ZJOI2008-树的统计Count","date":"2017-11-09T06:33:45.000Z","updated":"2017-11-09T06:38:14.528Z","comments":true,"path":"2017/11/09/BZOJ-1036-ZJOI2008-树的统计Count/","link":"","permalink":"http://yoursite.com/2017/11/09/BZOJ-1036-ZJOI2008-树的统计Count/","excerpt":"描述一棵树上有 $n$个 节点，编号分别为 $1$ 到 $n$ ，每个节点都有一个权值 $w$ 。我们将以下面的形式来要求你对这棵树完成一些操作：","text":"描述一棵树上有 $n$个 节点，编号分别为 $1$ 到 $n$ ，每个节点都有一个权值 $w$ 。我们将以下面的形式来要求你对这棵树完成一些操作： $\\textrm{CHANGE} \\ u \\ t$ : 把结点 $u$ 的权值改为 $t$ $\\textrm{QMAX} \\ u \\ v$ ：询问从点 $u$ 到点 $v$ 的路径上的节点的最大权值 $\\textrm{QSUM} \\ u \\ v$ ：询问从点 $u$ 到点 $v$ 的路径上的节点的权值和 注意：从点 $u$ 到点 $v$ 的路径上的节点包括 $u$ 和 $v$ 本身。 $1 \\leq n \\leq 30000, 0 \\leq q \\leq 200000, -30000 \\leq w \\leq 30000$ 分析马上 NOIP 2017 了，就当顺便复习一下树链剖分和线段树吧 qwq 树链剖分树链剖分用一句话概括就是：把一棵树剖分为若干条链，然后利用数据结构（树状数组，Splay，线段树等等）去维护每一条链，复杂度为 $\\Theta(logn)$ 。 这里所说的树链剖分是轻重链剖分，不是长链剖分，表示蒟蒻不会长链剖分，轻重链剖分由两次 dfs 组成。 令 $size[u]$ 为以 $u$ 为根的子树的结点数，$depth[u]$ 为结点 $u$ 的深度，$fa[u]$ 为结点 $u$ 的父亲。 首先无根树转有根树，以 $1$ 为根，记录每个节点的子节点总数（包括自己） $size[u]$ ，每个节点的父亲 $fa[u]$ ，每个节点到父亲的边权 $f[u]$ ，深度 $depth[u]$ 。这是第一次 dfs。 然后就是第二次 dfs ，一这道题目为栗子，用线段树来维护将树剖分之后的线性结构，线段树每一个结点的值对应结点到其父亲的边权。 令 $bel[i]$ 为 $i$ 结点所属的链的链头，$id[i]$ 为结点 $i$ 的 dfs 序标号。 首先维护一个时间戳 $\\textrm{timestamp}$ ，然后 dfs2(int u, int num) 表示从结点 $u$ 开市构建链，结点 $u$ 属于的链编号为 $num$ 。每次 dfs 的时候结点 $id[u] = ++\\textrm{timestamp}$ ，dfs 序保证了同一条链中结点的 $id[]$ 是连续的，所以只需要维护一棵线段树就可以了。 然后找结点 $u$ 的儿子中 $size[]$ 最大的结点 $v$ （若不存在，递归到叶子，则返回），然后仍然执行 dfs2(v, num) 使得这一条链尽可能长。其余的儿子节点构成新链，而他们自身则为新链的链头，执行 dfs2(v, v) 。 然后，构建线段树，因为在一条链上的点的编号是连续的，所以可以在一颗线段树上进行修改或者询问操作。将所有的重链首尾相连放入线段树中，$id[u]$ 为结点 $u$ 在线段树中的编号。 单点修改，很容易，直接在线段树上修改即可。 修区间修改，修改点 $u$ 到点 $v$ 之间路径上的权值，分两种情况讨论： 结点 $u$ 和结点 $v$ 在同一条链上，那么直接在线段树上修改 $id[u]$ 到 $id[v]$ 之间的点的权值。 若结点 $u$ 与结点 $v$ 不在一条链上，那么以便修改，一边将 $u$ 和 $v$ 向同一条重链上靠，直到变成在一条链上的情况。 至于查询操作和修改操作的思想是一样的，这里还是详细的写一下： 单点查询同单点修改。 区间询问： 在同一条链上，直接询问 不在同一条链上，先交换，保证 $u$ 的链头深度大于 $v$ 的链头深度。然后将 $u$ 移动到 $fa[bel[u]]$ 即上一条链，一边移动一边更新询问的答案，直到 $bel[u] = bel[v]$ ，然后同情况一。 单次操作的时间复杂度为 $\\Theta(log^{2}n)$ 。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183// Created by ZJYelizaveta on Tuesday, November 07, 2017 AM09:01:56 CST//// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 30000 + 3;const int INF = 0x3f3f3f3f;const int MAXNODE = MAX_N * 4;int n, q;vector&lt;int&gt; G[MAX_N &lt;&lt; 1];int w[MAX_N];inline void addEdge(int from, int to) &#123; G[from].push_back(to); G[to].push_back(from);&#125;namespace segmentTree&#123; #define mid (((l) + (r)) &gt;&gt; 1) #define lc ((o) &lt;&lt; 1) #define rc (((o) &lt;&lt; 1) + 1) struct Node&#123; int l, r, sum, maxVal; &#125;node[MAXNODE]; void build(int o, int l, int r) &#123; node[o].l = l, node[o].r = r; if (r == l) return; build(lc, l, mid); build(rc, mid + 1, r); &#125; inline void pushUp(int o) &#123; node[o].sum = node[lc].sum + node[rc].sum; node[o].maxVal = max(node[lc].maxVal, node[rc].maxVal); &#125; inline void modify(int o, int pos, int val) &#123; //change the single point on the segemnt tree; int l = node[o].l, r = node[o].r; if (l == r) &#123; node[o].sum = node[o].maxVal = val; return; &#125; if (pos &lt;= mid) modify(lc, pos, val); else modify(rc, pos, val); pushUp(o); &#125; int querySum(int o, int L, int R) &#123; int l = node[o].l, r = node[o].r; if (l == L &amp;&amp; r == R) return node[o].sum; if (R &lt;= mid) return querySum(lc, L, R); else if (L &gt; mid) return querySum(rc, L, R); else return querySum(lc, L, mid) + querySum(rc, mid + 1, R); &#125; int queryMax(int o, int L, int R) &#123; int l = node[o].l, r = node[o].r; if (l == L &amp;&amp; R == r) return node[o].maxVal;// if (R &lt;= mid) return queryMax(lc, L, R); else if (L &gt; mid) return queryMax(rc, L, R); else return max(queryMax(lc, L, mid), queryMax(rc, mid + 1, R)); &#125;&#125;using namespace segmentTree;namespace heavyLightDecomposition &#123; int size[MAX_N], depth[MAX_N], fa[MAX_N]; inline void dfs1(int u, int f) &#123; size[u] = 1; depth[u] = f == 0 ? 0 : depth[f] + 1; fa[u] = f; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; int v = G[u][i]; if (v == f) continue; dfs1(v, u); size[u] += size[v]; &#125; &#125; int bel[MAX_N], id[MAX_N], timeStamp = 0; inline void dfs2(int u, int num) &#123; bel[u] = num, id[u] = ++timeStamp; int Max = 0, idx = 0; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; int v = G[u][i]; if (v != fa[u] &amp;&amp; size[v] &gt; Max) &#123; Max = size[v]; idx = v; &#125; &#125; if (Max == 0) return; dfs2(idx, num); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; int v = G[u][i]; if (v != fa[u] &amp;&amp; v != idx) dfs2(v, v); &#125; &#125;&#125;using namespace heavyLightDecomposition;namespace solve &#123; inline int solveSum(int a, int b) &#123; int sum = 0; while (bel[a] != bel[b]) &#123; if (depth[bel[a]] &lt; depth[bel[b]]) swap(a, b); sum += querySum(1, id[bel[a]], id[a]); a = fa[bel[a]]; &#125; if (depth[a] &gt; depth[b]) swap(a, b); sum += querySum(1, id[a], id[b]); return sum; &#125; inline int solveMax(int a, int b) &#123; int maxVal = -INF; while (bel[a] != bel[b]) &#123; if (depth[bel[a]] &lt; depth[bel[b]]) swap(a, b); maxVal = max(maxVal, queryMax(1, id[bel[a]], id[a])); a = fa[bel[a]]; &#125; if (depth[a] &gt; depth[b]) swap(a, b); maxVal = max(maxVal, queryMax(1, id[a], id[b])); return maxVal; &#125;&#125;using namespace solve;char opt[10];int main()&#123; n = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n - 1; ++i) &#123; int u = readIn&lt;int&gt;(), v = readIn&lt;int&gt;(); addEdge(u, v); &#125; for (int i = 1; i &lt;= n; ++i) w[i] = readIn&lt;int&gt;(); fa[1] = 0; dfs1(1, 0); dfs2(1, 1);// for (int i = 1; i &lt;= n; ++i) printf(\"%d %d\\n\", i, bel[i]); build(1, 1, n); for (int i = 1; i &lt;= n; ++i) modify(1, id[i], w[i]); q = readIn&lt;int&gt;(); // printf(\"%d\\n\", q); while (q--) &#123; scanf(\"%s\", opt);// printf(\"%s\\n\", opt); if (opt[0] == 'C') &#123; int u = readIn&lt;int&gt;(), val = readIn&lt;int&gt;(); w[u] = val; modify(1, id[u], val); &#125; else &#123; int u = readIn&lt;int&gt;(), v = readIn&lt;int&gt;(); if (opt[1] == 'M') printf(\"%d\\n\", solveMax(u, v)); else printf(\"%d\\n\", solveSum(u, v)); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://yoursite.com/tags/树链剖分/"}]},{"title":"NOIP 2016 整理","slug":"NOIP-2016-整理","date":"2017-11-09T06:12:37.000Z","updated":"2017-11-09T06:45:15.060Z","comments":true,"path":"2017/11/09/NOIP-2016-整理/","link":"","permalink":"http://yoursite.com/2017/11/09/NOIP-2016-整理/","excerpt":"Day 1玩具谜题描述小南有一套可爱的玩具小人，它们各有不同的职业。 有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。如下图：","text":"Day 1玩具谜题描述小南有一套可爱的玩具小人，它们各有不同的职业。 有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。如下图： 这时 singer 告诉小南一个谜题：“眼镜藏在我左数第 $3$ 个玩具小人的右数第 $1$ 个玩具小人的左数第 $2$ 个玩具小人那里。” 小南发现，这个谜题中玩具小人的朝向非常关键，因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。 小南一边艰难地辨认着玩具小人，一边数着： “singer 朝内，左数第 $3$ 个是 archer。“archer 朝外，右数第 $1$ 个是 thinker。“thinker 朝外，左数第 $2$ 个是 writer。“所以眼镜藏在 writer 这里！” 虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜题具体可以描述为： 有 $n$ 个玩具小人围成一圈，已知它们的职业和朝向。现在第 $1$ 个玩具小人告诉小南一个包含 $m$ 条指令的谜题，其中第i条指令形如“左数/右数第 $S_{i}$ 个玩具小人”。你需要输出依次数完这些指令后，到达的玩具小人的职业。 $n \\leq 10^{5}, m \\leq 10^{5}$ 分析其实我至今都没有想明白，去年在考场上我在想什么东西，以至于第一题都 WA 了。然后把考试的代码找出来改了一下，然后 A 了，debug 的时候找出来一堆奇奇怪怪的错误，我去年在干什么呀 qwq 大概思路就是 $\\Theta(m)$ 模拟转圈的过程即可，注意细节。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 100000 + 7;int n, m;struct Node &#123; int num; char name[11];&#125;a[MAX];int d[MAX], s[MAX];int main()&#123;// freopen(\"toy.in\",\"r\",stdin); freopen(\"toy.out\",\"w\",stdout); n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 0; i &lt; n; i++) a[i].num = readIn&lt;int&gt;(), scanf(\"%s\", a[i].name);// for (int i = 0; i &lt; n; ++i) printf(\"%d %d %s\\n\", i, a[i].num, a[i].name); for (int i = 0; i &lt; m; i++) d[i] = readIn&lt;int&gt;(), s[i] = readIn&lt;int&gt;(); int q = 0; for (int i = 0; i &lt; m; ++i) &#123;// printf(\"%d %d\\n\", d[i], s[i]); if (d[i] == 0 &amp;&amp; a[q].num== 0) &#123; q -= s[i]; if (q &lt; 0) &#123;// q = n - s[i] + 1; q = q + n; &#125; &#125; else if (d[i] == 0 &amp;&amp; a[q].num== 1) &#123; q += s[i]; if (q &gt; n - 1) &#123;// q = q - n + 1; q = q - n; &#125; &#125; else if (d[i] == 1 &amp;&amp; a[q].num == 0) &#123; q += s[i]; if (q &gt; n - 1) &#123;// q = q - n + 1; q = q - n; &#125; &#125; else if (d[i] == 1 &amp;&amp; a[q].num == 1) &#123; q -= s[i]; if (q &lt; 0) &#123;// q = n - s[i] + 1; q = q + n; &#125; &#125;// printf(\"%s\\n\", a[q].name); &#125; printf(\"%s\\n\", a[q].name); return 0;&#125; 天天爱跑步描述小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。 这个游戏的地图可以看作一棵包含 $n$ 个结点和 $n−1$ 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 $1$ 到 $n$ 的连续正整数。 现在有 $m$ 个玩家，第 $i$ 个玩家的起点为 $S_{i}$，终点为 $T_{i}$。每天打卡任务开始时，所有玩家在第 $0$ 秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的） 小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 $j$ 的观察员会选择在第 $W_{j}$ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 $W_{j}$ 秒也正好到达了结点 $j$。小 C 想知道每个观察员会观察到多少人？ 注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一段时间后再被观察员观察到。即对于把结点 $j$ 作为终点的玩家：若他在第 $W_{j}$ 秒前到达终点，则在结点 $j$ 的观察员不能观察到该玩家；若他正好在第 $W_{j}$ 秒到达终点，则在结点 $j$ 的观察员可以观察到这个玩家。 $n \\leq 299998, m \\leq 299998$ 分析我去年大概是一个 zz，所以我连暴力都没有写出来qwq 然后今年作为模拟题来做的时候又用 25 分的暴力思想去做 40 分，然后 T 飞啦qwq（时间复杂度 $\\Theta(n^{2})$） 好了现在进入正题，25 分的暴力分还是比较好拿到的，这里不详述。 这里考虑链的情况。因为是一条链所以每一条路劲都是唯一确定的，又因为链上的点依次为 $1, 2, 3, \\cdots, n$ ，所以可以确定 $s \\rightarrow t$ 是从编号小的点走向编号大的点还是编号大的点走向编号小的点。这里分开讨论： 若 $(u, v) (u \\leq v)$ ，那么点 $i$ 的观察员活跃度可以 $+1$ 当且仅当存在 $w_{i} = i - u$ ，$u \\leq 0$ 的时候仍然成立。 若 $(u, v)(u \\geq v)$ ，那么点 $i$ 的观察员活跃度可以 $+1$ 当且仅当存在 $w_{i} = u - i$ ，$u &gt; n$ 的时候也成立。 那么这里对于链的暴力，可以每次在 $u$ （开始的时候 $+1$），在 $v$ （结束时在开始处 $-1$），在路径结束之前，统计一下链上每一个点上等于 $i - w_{i} (u \\leq v)$ 和 $w_{i} + i(u &gt; v)$ 的数量。 对于 $s_{i} = 1$ 的部分分可以在每一个 $t_{i}$ 那里标记一下，然后 $\\Theta(n)$ 一边遍历一边回溯累计一下答案即可。 那么到此为止，暴力分有 60 分了，如果有思路可以考虑 $t_{i} = 1$ 的情况。 至于剩下的正解部分呀，我决定暂且先不写，有时间来填坑。我并不觉得现在自己对这道题目的领悟比学长去年写的更深刻，所以呀，推荐你们去看学长的博客吧 qwq 链接戳我 qwq 代码暴力 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168// Created by ZJYelizaveta on 2017年11月08日 星期三 21时16分06秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 300000 + 3;const int INF = 0x3f3f3f3f;int n, m;vector&lt;int&gt; G[MAX_N &lt;&lt; 1];int w[MAX_N];int s[MAX_N], t[MAX_N];inline void addEdge(int from, int to) &#123; G[from].push_back(to); G[to].push_back(from);&#125;namespace subtaskOne &#123; int cnt[1000]; inline void solve() &#123; memset(cnt, 0, sizeof cnt); for (int i = 1; i &lt;= n; ++i) if (w[s[i]] == 0) ++cnt[s[i]]; for (int i = 1; i &lt;= n; ++i) printf(\"%d%c\", cnt[i], i == n ? '\\n' : ' '); exit(0); &#125;&#125;namespace subtaskTwo &#123; int cnt[1000]; inline void solve() &#123; memset(cnt, 0, sizeof cnt); for (int i = 1; i &lt;= n; ++i) if (s[i]) ++cnt[s[i]]; for (int i = 1; i &lt;= n; ++i) printf(\"%d%c\", cnt[i], i == n ? '\\n' : ' '); exit(0); &#125;&#125;namespace subtaskThree &#123; int cnt[1000]; inline bool dfs(int u, int fa, int t, int timeStamp) &#123; bool flag = false; if (u == t) flag = true; else &#123; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; int v = G[u][i]; if (v == fa) continue; flag = flag || dfs(v, u, t, timeStamp + 1); &#125; &#125; if (flag &amp;&amp; w[u] == timeStamp) ++cnt[u]; return flag; &#125; inline void solve() &#123; for (int i = 1; i &lt;= m; ++i) &#123; dfs(s[i], 0, t[i], 0); &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%d%c\", cnt[i], i == n ? '\\n' : ' '); exit(0); &#125;&#125;namespace subtaskFour &#123; struct Events &#123; int s, t; Events (int s, int t) : s(s), t(t)&#123;&#125; &#125;; vector&lt;Events&gt; pre[100000], suf[100000]; int cnt[100000], ans[100000]; inline void calculate() &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; (int)pre[i].size(); ++j) &#123; if (pre[i][j].s == i) ++cnt[i]; &#125; if (i - w[i] &gt;= 1) ans[i] += cnt[i - w[i]]; for (int j = 0; j &lt; (int)pre[i].size(); ++j) &#123; if (pre[i][j].t == i) --cnt[pre[i][j].s]; &#125; &#125; memset(cnt, 0, sizeof cnt); for (int i = n; i &gt;= 1; --i) &#123; for (int j = 0; j &lt; (int)suf[i].size(); ++j) &#123; if (suf[i][j].s == i) ++cnt[i]; &#125; if (i + w[i] &lt;= n) ans[i] += cnt[i + w[i]]; for (int j = 0; j &lt; (int)suf[i].size(); ++j) &#123; if (suf[i][j].t == i) --cnt[suf[i][j].s]; &#125; &#125; &#125; inline void solve() &#123; for (int i = 1; i &lt;= m; ++i) &#123; if (s[i] &lt;= t[i]) &#123; pre[s[i]].push_back(Events(s[i], t[i])); pre[t[i]].push_back(Events(s[i], t[i])); &#125; else &#123; suf[s[i]].push_back(Events(s[i], t[i])); suf[t[i]].push_back(Events(s[i], t[i])); &#125; &#125; calculate(); for (int i = 1; i &lt;= n; ++i) printf(\"%d%c\", ans[i], i == n ? '\\n' : ' '); exit(0); &#125;&#125;namespace subtaskFive &#123; int depth[MAX_N], cnt[MAX_N]; inline void dfs(int u, int fa) &#123; depth[u] = fa == 0 ? 0 : depth[fa] + 1; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; if (G[u][i] == fa) continue; dfs(G[u][i], u); cnt[u] += cnt[G[u][i]];// printf(\"%d %d\\n\", u, G[u][i]); &#125; &#125; inline void solve() &#123; for (int i = 1; i &lt;= m; ++i) ++cnt[t[i]]; dfs(1, 0); for (int i = 1; i &lt;= n; ++i) printf(\"%d%c\", depth[i] == w[i] ? cnt[i] : 0, i == n ? '\\n' : ' '); exit(0); &#125;&#125;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n - 1; ++i) &#123; int u = readIn&lt;int&gt;(), v = readIn&lt;int&gt;(); addEdge(u, v); &#125; for (int i = 1; i &lt;= n; ++i) w[i] = readIn&lt;int&gt;(); for (int i = 1; i &lt;= m; ++i) s[i] = readIn&lt;int&gt;(), t[i] = readIn&lt;int&gt;(); if (n % 10 == 1 &amp;&amp; m % 10 == 1) subtaskOne::solve(); if (n % 10 == 2 &amp;&amp; m % 10 == 2) subtaskTwo::solve(); if (n % 10 == 3 &amp;&amp; m % 10 == 3) subtaskThree::solve(); if (n % 10 == 4 &amp;&amp; m % 10 == 4) subtaskFour::solve(); if (n % 10 == 5 &amp;&amp; m % 10 == 5) subtaskFive::solve(); return 0;&#125; $100 \\%$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 300000 + 3;const int MAX_M = 300000 + 3;const int INF = 0x3f3f3f3f;int n, m;int fa[MAX_N], rank[MAX_N], anc[MAX_N], w[MAX_N ], depth[MAX_N], cnt[2][MAX_N &lt;&lt; 1];int ans[MAX_N ];bool vis[MAX_N];vector&lt;int&gt; G[MAX_N &lt;&lt; 1], start[2][MAX_N], end[2][MAX_N];vector&lt; pair&lt;int, int&gt; &gt; q[MAX_N + 1];int find(int x) &#123; return fa[x] ? fa[x] = find(fa[x]) : x;&#125;inline void merge(int x, int y) &#123; int lx = find(x), ly = find(y); if (rank[ly] &gt; rank[lx]) swap(lx, ly); fa[ly] = lx; rank[lx] += rank[lx] == rank[ly];&#125;inline void lca(int u, int p) &#123; anc[u] = u; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; int v = G[u][i]; if (v == p) continue; depth[v] = depth[u] + 1; lca(v, u); merge(u, v); anc[find(u)] = u; &#125; vis[u] = true; for (int i = 0; i &lt; (int)q[u].size(); ++i) &#123; pair&lt;int, int&gt; p = q[u][i]; int v = p.first == u ? p.second : p.first; if (vis[v]) &#123; int a = anc[find(v)], len = depth[u] + depth[v] - 2 * depth[a]; int s = depth[p.first], t = depth[p.second] - len + n; start[0][p.first].push_back(s); start[1][p.second].push_back(t); end[0][a].push_back(s); end[1][a].push_back(t); &#125; &#125;&#125;inline void dfs(int u, int p) &#123; ans[u] -= cnt[0][depth[u] + w[u]] + cnt[1][depth[u] - w[u] + n]; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; int v = G[u][i]; if (v == p) continue; dfs(v, u); &#125; for (int i = 0; i &lt;= 1; ++i) &#123; for (int j = 0; j &lt; (int)start[i][u].size(); ++j) ++cnt[i][start[i][u][j]]; &#125; for (int j = 0; j &lt; (int)end[1][u].size(); ++j) --cnt[1][end[1][u][j]]; ans[u] += cnt[0][depth[u] + w[u]] + cnt[1][depth[u] - w[u] + n]; for (int j = 0; j &lt; (int)end[0][u].size(); ++j) --cnt[0][end[0][u][j]];&#125;int main()&#123;// freopen(\"test.in\", \"r\", stdin); n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 0; i &lt; n - 1; ++i) &#123; int u = readIn&lt;int&gt;(), v = readIn&lt;int&gt;(); G[u].push_back(v); G[v].push_back(u); &#125; for (int i = 1; i &lt;= n; ++i) w[i] = readIn&lt;int&gt;(); for (int i = 0; i &lt; m; ++i) &#123; pair&lt;int, int&gt; p; p.first = readIn&lt;int&gt;(), p.second = readIn&lt;int&gt;(); q[p.first].push_back(p); if (p.first != p.second) q[p.second].push_back(p); &#125; lca(1, 0); dfs(1, 0); for (int i = 1; i &lt;= n; ++i) printf(\"%d%c\", ans[i], i == n ? '\\n' : ' '); return 0;&#125; 换教室描述对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。 在可以选择的课程中，有 $2n$ 节课程安排在 $n$ 个时间段上。在第 $i (1 \\leq i \\leq n)$ 个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 $c_{i}$ 上课，而另一节课程在教室 $d_{i}$ 进行。 在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的 $n$ 节安排好的课程。如果学生想更换第 $i$ 节课程的教室，则需要提出申请。若申请通过，学生就可以在第 $i$ 个时间段去教室 $d_{i}$ 上课，否则仍然在教室 $c_{i}$上课。 由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 $i$ 节课程的教室时，申请被通过的概率是一个已知的实数 $k_{i}$，并且对于不同课程的申请，被通过的概率是互相独立的。 学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 $m$ 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请自己最希望更换教室的 $m$ 门课程，也可以 不用完 这 $m$ 个申请的机会，甚至可以一门课程都不申请。 因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。 牛牛所在的大学有 $v$ 个 教室，有 $e$ 条道路。每条道路连接两间教室，并且是可以 双向通行 的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。当第 $i (1\\leq i \\leq n-1)$ 节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的 路径 前往下一节课的教室。 现在牛牛想知道，申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的 期望值 最小，请你帮他求出这个最小值。 $1 \\leq n \\leq 2000，0 \\leq m \\leq 2000， 1 \\leq v \\leq 300， 0 \\leq e \\leq 90000。$ 分析去年呀，不懂数学期望，然后 GG 。 先预习一下定义：数学期望（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和。 这里要求“因在教室间移动耗费的体力值的总和的 期望值 最小”，那么可以先用 floyd 预处理出点与点之间的最短路。然后根据期望的线性性，可以将其线性向后递推，故使用动规来求。 令 $dp[i][j][k]$ 为到了第 $i$ 节课，已经换了 $j$ 次教室之后的耗费体力之和的期望值最小（其中 $k$ 表示第 $i$ 节课是否换教室）。 那么此时有两种决策，其中不换教室则在 $c_{i}$ 上，换教室在 $d_{i}$ 上，第 $i$ 节课换教室的概率为 $p_{i}$ ，第 $i$ 点到 $j$ 的最短路为 $dis[i][j]$ ： 第 $i$ 节课不换教室，那么考虑第 $i - 1$ 节课是否换教室来计算这一次的期望（期望的线性性） dp[i][j][0] = min\\left\\{\\begin{matrix} dp[i - 1][j][0] + dis[c_{i - 1}][c_{i}]\\\\ dp[i - 1][j][1] + dis[d_{i - 1}][c_{i}] \\times p_{i - 1} + dis[c_{i - 1}][c_{i}] \\times (1 - p_{i - 1})& \\end{matrix}\\right. 第 $i$ 节课换教室，一样考虑第 $i - 1$ 次是否换教室，转移方程如下 dp[i][j][1] = min\\left\\{\\begin{matrix} dp[i - 1][j - 1][0] + dis[c_{i - 1}][d_{i}] \\times p_{i} + dis[c_{i - 1}][c_{i}] \\times (1 - p_{i}) \\\\ dis[i - 1][j - 1][1] + dis[d_{i - 1}][d_{i}] \\times p_{i - 1} \\cdot p_{i} + dis[c{i - 1}][d_{i}] \\times (1 - p_{i - 1}) \\cdot p_{i} + dis[d_{i - 1}][c_{i}] \\times p_{i - 1} \\cdot (1 - p_{i}) + dis[c{i - 1}][c_{i}] \\times (1 - p_{i - 1}) \\cdot (1 - p_{i}) \\end{matrix}\\right. 写转移方程的时候仔细一点就行了，然后没有了 qwq 记几个处理二进制位的内置函数： __builtin_popcount(x)：$x$ 中 1 的个数。 __builtin_ctz(x)：$x$ 末尾 0 的个数。$x=0$ 时结果未定义。 __builtin_clz(x)：$x$ 前导 0 的个数。$x=0$ 时结果未定义。 __builtin_ffs(x)：返回 $x$ 中最后一个为 1 的位是从后向前的第几位。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// Created by ZJYelizaveta on 2017年11月06日 星期一 11时20分48秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 2000 + 3;const int MAX_V = 300 + 3;const int INF = 0x3f3f3f3f;const double inf = 1e16;int n, m, v, e; // vertex, edgeint c[MAX_N], d[MAX_N]; // classroom, another classroomdouble p[MAX_N]; // 概率int dis[MAX_V][MAX_V];double dp[MAX_N][MAX_N][2];inline void floyd() &#123; for (int k = 1; k &lt;= v; ++k) &#123; for (int i = 1; i &lt;= v; ++i) &#123; for (int j = 1; j &lt;= v; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125;/* printf(\"\\n\"); for (int i = 1; i &lt;= v; ++i) &#123; for (int j = 1; j &lt;= v; ++j) printf(\"%d \", dis[i][j]); printf(\"\\n\"); &#125;*/&#125;inline void solve() &#123; for (int i = 0; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= m; ++j) dp[i][j][0] = dp[i][j][1] = inf; &#125; dp[1][0][0] = dp[1][1][1] = 0.0; for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 0; j &lt;= min(i, m); ++j) &#123; dp[i][j][0] = dp[i - 1][j][0] + dis[c[i - 1]][c[i]]; dp[i][j][0] = min(dp[i][j][0], dp[i - 1][j][1] + dis[d[i - 1]][c[i]] * p[i - 1] + dis[c[i - 1]][c[i]] * (1.0 - p[i - 1])); if (j &gt;= 1) &#123; dp[i][j][1] = dp[i - 1][j - 1][0] + dis[c[i - 1]][d[i]] * p[i] + dis[c[i - 1]][c[i]] * (1.0 - p[i]); // dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j - 1][1] + dis[d[i - 1]][d[i]] * p[i - 1] * p[i] + dis[c[i - 1]][d[i]] * (1.0 - p[i - 1]) * p[i] + dis[d[i - 1]][c[i]] * p[i - 1] * (1.0 - p[i]) + dis[c[i - 1]][c[i]] * (1.0 - p[i - 1]) * (1.0 - p[i])); &#125; &#125; &#125; double ans = inf; for (int i = 1; i &lt;= min(n, m); ++i) &#123; ans = min(ans, min(dp[n][i][0], dp[n][i][1])); &#125; ans = min(ans, dp[n][0][0]); printf(\"%.2f\\n\", ans);&#125;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(), v = readIn&lt;int&gt;(), e = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) c[i] = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) d[i] = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) scanf(\"%lf\", &amp;p[i]); memset(dis, INF, sizeof dis); for (int i = 0; i &lt;= v; ++i) dis[i][i] = 0; // for (int i = 1; i &lt;= e; ++i) &#123; int u = readIn&lt;int&gt;(), v = readIn&lt;int&gt;(), w = readIn&lt;int&gt;(); dis[u][v] = dis[v][u] = min(min(dis[u][v], dis[v][u]), w); &#125; floyd(); solve(); return 0;&#125; Day 2组合数问题描述组合数 $C_{n}^{m}$ 表示的是从 $n$ 个物品中选出 $m$ 个物品的方案数。举个例子，从 $(1, 2, 3)$ 三个物品中选择两个物品可以有 $(1, 2), (1, 3), (2, 3)$ 这三种选择方法。根据组合数的定义，我们可以给出计算组合数的一般公式： C_{n}^{m} = \\frac{n!}{m!(n - m)!}其中 $n! = 1 \\times 2 \\times \\cdots \\times n$。 小葱想知道如果给定 $n, m$ 和 $k$ ，对于所有的 $0 \\leq i \\leq n, 0 \\leq j &lt;= min(i, m)$ 有多少对 $(i, j)$ 满足 $C_{i}^{j}$ 是 $k$ 的倍数。 $n \\leq 2000, m \\leq 2000, k = 21, t \\leq 10^{4}$ 分析$\\Theta(n^{2})$ 预处理 + $\\Theta(nm)$ 计算有 70 分。 考虑正解，$t$ 组询问每次 $\\Theta(nm)$ 的时间复杂度回答询问肯定是不行的，考虑优化。 这里依然是一个套路，用二维前缀和优化，这样回答的时间复杂度降为 $\\Theta(1)$ 。 首先 $\\Theta(n^{2})$ 根据杨辉三角的递推式计算 $C_{n}^{m}$ ： C_{n}^{m} = C_{n - 1}^{m - 1} + C_{n - 1}^{m}令 $sum[i][j]$ 为 $n = i, m = j$ 时 $C[a][b] \\pmod k = 0(a \\leq i, b \\leq min(i, j))$ 的个数，那么 ： sum[i][j] = [j \\leq i , C[i][j] \\pmod k = 0] + sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1]这样，$ans = sum[n][m]$ ；总时间复杂度为 $\\Theta(n^{2} + nm + t)$ 。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Created by ZJYelizaveta on Friday, November 03, 2017 AM08:44:04 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 2000 + 3;const int INF = 0x3f3f3f3f;int testCase;int K, n, m;int C[MAX_N][MAX_N], sum[MAX_N][MAX_N];int ans;inline void prepare() &#123; memset(C, 0, sizeof C); memset(sum, 0, sizeof sum); C[0][0] = 1; for (int i = 1; i &lt; MAX_N; ++i) &#123; C[i][0] = 1, C[i][i] = 1; for (int j = 1; j &lt; i; ++j) &#123; C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % K; &#125; &#125; for (int i = 1; i &lt; MAX_N; ++i) &#123; for (int j = 1; j &lt; MAX_N; ++j) &#123; sum[i][j] = (j &lt;= i &amp;&amp; C[i][j] == 0) + sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1]; &#125; &#125;&#125;int main()&#123; testCase = readIn&lt;int&gt;(), K = readIn&lt;int&gt;(); prepare(); while (testCase--) &#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); printf(\"%d\\n\", sum[n][m]); &#125; return 0;&#125; 蚯蚓描述本题中，我们将用符号 $\\left \\lfloor c \\right \\rfloor$ 表示对 $c$ 向下取整，例如：$\\left \\lfloor 3.0 \\right \\rfloor = \\left \\lfloor 3.1 \\right \\rfloor= \\left \\lfloor 3.9 \\right \\rfloor = 3$。 蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。 蛐蛐国里现在共有 $n$ 只蚯蚓（$n$ 为正整数）。每只蚯蚓拥有长度，我们设第 $i$ 只蚯蚓的长度为 $a_{i}(i=1, 2, \\cdots, n)$，并保证所有的长度都是非负整数（即：可能存在长度为 $0$ 的蚯蚓）。 每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 $p$ （是满足 $0&lt;p&lt;l$ 的有理数）决定，设这只蚯蚓长度为 $x$ ，神刀手会将其切成两只长度分别为 $\\left \\lfloor px \\right \\rfloor$ 和 $x - \\left \\lfloor px \\right \\rfloor$ 的蚯蚓。特殊地，如果这两个数的其中一个等于 $0$ ，则这个长度为 $0$ 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 $q$ （是一个非负整常数）。 蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 $m$ 秒才能到来…… （$m$ 为非负整数） 蛐蛐国王希望知道这 $m$ 秒内的战况。具体来说，他希望知道： $m$秒内，每一秒被切断的蚯蚓被切断前的长度（有 $m$ 个数） $m$ 秒后，所有蚯蚓的长度（有 $n + m$ 个数）。 蛐蛐国王当然知道怎么做啦！但是他想考考你…… $n = 10^{5}, m \\leq 7 \\times 10^{6}, t = 71, a_{i} \\leq 10^{8}, v \\leq 10^{9}, q \\leq 200$ 分析直接用优先队列模拟题意大概有 20 分，加一点小 trick 就可以拿到 85 分qwq 具体来说是这样的：用优先队列来模拟的话，每次都要将除队首之外队列中的元素 $+q$ ，这样每次操作的时间复杂度为 $\\Theta(2log(n + m))$ ，但是实际上我们不是每一次操作必须马上将队列中的元素 $+q$ 。我们只需要让每次操作之后所有蚯蚓的相对长度与将蚯蚓 $+ q$ 之后的蚯蚓的相对的长度保持一样，$m$ 次操作之后将每条蚯蚓的长度 $+mq$ 就行了。 这样一来时间复杂度为 $\\Theta(m2log(n + m))$ ，可以拿到 85 分，但是在 $m$ 较大的时候一样会 TLE。 考虑正解。 考虑 $q = 0$ 的情况，那么每次取出的蚯蚓的长度一定单调不增。我们维护三个单调不降的队列，第一个队列是原序列，第二个队列值左半部分蚯蚓的序列，第三个队列是右半部分蚯蚓的序列。每次取出要被砍的蚯蚓是三个序列的队首最大值，然后将蚯蚓砍成左右两部分分别加入左半部分蚯蚓序列和右半部分蚯蚓序列的末尾即可。 那么对于 $q \\neq 0$ 的情况呢？每次只有两只新蚯蚓不增加长度，那么我们可以将每只蚯蚓都 $+q$ ，然后将两只新蚯蚓 $-q$ ，这样蚯蚓的相对长度没有增加，依然满足单调性，沿用 $q = 0$ 的时候的算法。 其实这样的思路和 85 分的优先队列的思想是一样的，但是由于 STL 常数比较大，这里用三个队列模拟优先队列的过程，时间复杂度 $\\Theta(n \\ logn + m)$ 。 代码$85 \\%$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Created by ZJYelizaveta on Friday, November 03, 2017 AM11:51:23 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100000 + 3;const int MAX_M = 7000000 + 3;const int MAX_T = 71 + 3;const int INF = 0x3f3f3f3f;int n, m, inc;int u, v, t;double p;int len[MAX_N + MAX_M], add;vector&lt;int&gt; ans;priority_queue&lt;int&gt; q;inline void solve() &#123; ans.clear(); add = 0; memset(len, 0, sizeof len); for (int i = 1; i &lt;= m; ++i) &#123; int x = q.top(); q.pop(); x += add; if (i % t == 0) ans.push_back(x); add += inc; int temp1 = (int)(floor(p * x) - add), temp2 = (int)(x - floor(p * x) - add); q.push(temp1), q.push(temp2); &#125; for (int i = 1; i &lt;= n + m; ++i) &#123; int x = q.top(); q.pop(); len[i] = x + add; &#125; for (int i = 0; i &lt; (int)ans.size(); ++i) printf(\"%d \", ans[i]); printf(\"\\n\"); for (int i = 1; i &lt;= n + m; i++) if (i % t == 0) printf(\"%d \", len[i]); printf(\"\\n\");&#125;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(), inc = readIn&lt;int&gt;(); u = readIn&lt;int&gt;(), v = readIn&lt;int&gt;(), t = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) &#123; int x = readIn&lt;int&gt;(); q.push(x); &#125; p = (double)u / (double)v; solve(); return 0;&#125; $100 \\%$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// Created by ZJYelizaveta on Friday, November 03, 2017 PM03:27:28 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100000 + 3;const int MAX_M = 7000000 + 3;const int INF = 0x3f3f3f3f;int n, m, inc;int u, v, t;double p;int a[MAX_N];int seq[3][MAX_M], l[3], r[3];inline int findMax() &#123; int cur = INT_MIN, id = 0; for (int i = 0; i &lt; 3; ++i) &#123; if (r[i] - l[i] &gt;= 1 &amp;&amp; seq[i][l[i]] &gt; cur) &#123; cur = seq[i][l[i]]; id = i; &#125; &#125; return id;&#125;vector&lt;int&gt; ans, res;void solve() &#123; sort(a, a + n); reverse(a, a + n); memcpy(seq[0], a, sizeof a); memset(l, 0, sizeof l); memset(r, 0, sizeof r);// for (int i = 0; i &lt; n; ++i) printf(\"%d \", seq[0][i]); printf(\"\\n\"); ans.clear(); r[0] = n; for (int i = 0; i &lt; m; ++i) &#123; int id = findMax(), cur = seq[id][l[id]++];// printf(\"%d %d\\n\", id, cur); int add = i * inc; if ((i + 1) % t == 0) ans.push_back(cur + add); int lft = (ll)(cur + add) * u / v, rht = (cur + add) - lft; lft -= add, rht -= add; seq[1][r[1]++] = lft - inc, seq[2][r[2]++] = rht - inc; &#125; for (int i = 0; i &lt; (int)ans.size(); ++i) printf(\"%d \", ans[i]); printf(\"\\n\"); res.clear(); int add = m * inc; for (int i = 0; i &lt; n + m; ++i) &#123; int id = findMax(), cur = seq[id][l[id]++]; if ((i + 1) % t == 0) res.push_back(cur + add); &#125; for (int i = 0; i &lt; (int)res.size(); ++i) printf(\"%d \", res[i]); printf(\"\\n\");&#125;int main()&#123;// freopen(\"earthworm.in\", \"r\", stdin);// freopen(\"earthworm.out\", \"w\", stdout); n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(), inc = readIn&lt;int&gt;(); u = readIn&lt;int&gt;(), v = readIn&lt;int&gt;(), t = readIn&lt;int&gt;(); for (int i = 0; i &lt; n; ++i) a[i] = readIn&lt;int&gt;(); p = (double)u / (double)v; solve(); return 0;&#125; 愤怒的小鸟描述Kiana 最近沉迷于一款神奇的游戏无法自拔。 简单来说，这款游戏是在一个平面上进行的。 有一架弹弓位于 $(0, 0)$ 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 $y = ax^{2}+ bx$ 的曲线，其中 $a, b$ 是Kiana指定的参数，且必须满足$a &lt; 0$。 当小鸟落回地面（即 $x$ 轴）时，它就会瞬间消失。 在游戏的某个关卡里，平面的第一象限中有 $n$ 只绿色的小猪，其中第 $i$ 只小猪所在的坐标为 $(x_{i}, y_{i})$ 。 如果某只小鸟的飞行轨迹经过了 $(x_{i}, y_{i})$ ，那么第 $i$ 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行； 如果一只小鸟的飞行轨迹没有经过 $(x_{i}, y_{i})$ ，那么这只小鸟飞行的全过程就不会对第 $i$ 只小猪产生任何影响。 例如，若两只小猪分别位于 $(1,3)$ 和 $(3,3)$ ，Kiana 可以选择发射一只飞行轨迹为 $y = -x^{2} + 4x$ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。 而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。 这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。 假设这款游戏一共有 $T$ 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。 $n \\leq 18, m = 2, T \\leq 5$ 分析$n \\leq 18$ ，很明显是状压dp的暗示。 令 $dp[S]$ 为打掉集合 $S$ 中所有的猪所需最少的次数。 每次发射一只鸟，要么打死一头猪，要么打死两头猪 $i$ 和 $j$ 。 $\\Theta(2^{n}n^{2})$ 的时间复杂度枚举 $i$ 和 $j$ 然后判断一下： $i = j$ ，那么包含 $i, j$ 的子集为 $S \\otimes (1 &lt;&lt; i)$ 若方程无解（$a = 0$）或抛物线不符合条件（$a &gt; 0$），那么此时只能打一只猪，此时集合仍为 $S \\otimes (1 &lt;&lt; i)$ 否则，$\\Theta(n)$ 的时间在集合 $S$ 中剔除这一次发射能够打掉的点。 这样一来时间复杂度为 $\\Theta(2^{n}n^{3})$ 。 考虑优化。听说位运算优化掉一个 $n$ 之后，可以以 $\\Theta(2^{n}n^{2})$ 的时间复杂度卡过去？ 优化还是比较套路，首先我们还是预处理，预处理出 $sub_{i, j}$ 为打出一条经过猪 $i$ 和 $j$ 的抛物线，不能打掉的点的集合。 考虑集合中横坐标最小的点，在最优解中这个点早晚都会被打掉，那么可以固定 $i$ ，然后枚举 $j$ 即可。这样复杂度又可以优化一个 $n$ ，现在总时间复杂度为 $\\Theta(2^{n}n)$ 。 从头到尾，都没有明白 $m$ 在这道题目里面是起什么作用的 qwq 然后对于暴力的部分，其实时间复杂度满打满算应该是 $\\Theta(2^{n}n^{3})$ ，在 Luogu 上有 75，在 UOJ 上有 85 分，不明嚼栗 qwq 代码暴力 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// Created by ZJYelizaveta on 2017年11月05日 星期日 15时35分32秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAXNODE = (1 &lt;&lt; 18) + 3;const int MAX_N = 18 + 3;const int INF = 0x3f3f3f3f;const double eps = 1e-6;int testCase;int n, m;double x[MAX_N], y[MAX_N];int dp[MAXNODE];inline bool calculate(double x1, double y1, double x2, double y2, double &amp;a, double &amp;b) &#123; double temp = (x1 * x1 * x2 - x2 * x2 * x1); if (fabs(temp) &lt; eps) return false; a = (y1 * x2 - y2 * x1) / temp; b = (y2 * x1 * x1 - y1 * x2 * x2) / temp; return true;&#125;inline int solve(int S, int i, int j) &#123; if (i == j) return (S ^ (1 &lt;&lt; i)); // double a, b; if (!calculate(x[i], y[i], x[j], y[j], a, b) || a &gt;= 0) return (S ^ (1 &lt;&lt; i)); S = S ^ (1 &lt;&lt; i) ^ (1 &lt;&lt; j); for (int k = 0; k &lt; n; ++k) if (S &amp; (1 &lt;&lt; k)) &#123; // double sum = a * x[k] * x[k] + b * x[k]; if (fabs(sum - y[k]) &lt; eps) S ^= (1 &lt;&lt; k); &#125; return S;&#125;inline int count(int S) &#123; return __builtin_popcount(S);&#125;inline int dfs(int S) &#123; if (S == 0) return 0; if (count(S) == 1) return 1; if (dp[S] &lt; INF) return dp[S]; for (int i = 0; i &lt; n; ++i) if (S &amp; (1 &lt;&lt; i)) &#123; for (int j = 0; j &lt; n; ++j) if (S &amp; (1 &lt;&lt; j)) &#123; int sub = solve(S, i, j); dp[S] = min(dp[S], dfs(sub) + 1); &#125; &#125; return dp[S];&#125;int main()&#123; testCase = readIn&lt;int&gt;(); while (testCase--) &#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 0; i &lt; n; ++i) scanf(\"%lf%lf\", &amp;x[i], &amp;y[i]); memset(dp, INF, sizeof dp); int ans = dfs((1 &lt;&lt; n) - 1); printf(\"%d\\n\", ans); &#125; return 0;&#125; $100 \\%$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// Created by ZJYelizaveta on 2017年11月06日 星期一 09时17分10秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAXNODE = (1 &lt;&lt; 18) + 3;const int MAX_N = 18 + 3;const int INF = 0x3f3f3f3f;const double eps = 1e-10;int testCase;int n, m;double x[MAX_N], y[MAX_N];int dp[MAXNODE], sub[MAX_N][MAX_N];inline bool calculate(double x1, double y1, double x2, double y2, double &amp;a, double &amp;b) &#123; double temp = (x1 * x1 * x2 - x2 * x2 * x1); if (fabs(temp) &lt; eps) return true; a = (y1 * x2 - y2 * x1) / temp; b = (y2 * x1 * x1 - y1 * x2 * x2) / temp; if (a &gt;= -eps) return true; // 注意精度 return false;&#125;inline void prepare() &#123; double a, b; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; if (calculate(x[i], y[i], x[j], y[j], a, b)) &#123; sub[i][j] = (1 &lt;&lt; n) - 1; continue; &#125; sub[i][j] = 0; for (int k = 0; k &lt; n; ++k) &#123; double temp = a * x[k] * x[k] + b * x[k]; if (fabs(temp - y[k]) &gt; eps) sub[i][j] ^= (1 &lt;&lt; k); &#125; &#125; &#125;/* for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) printf(\"%d \", sub[i][j]); printf(\"\\n\"); &#125;*/&#125;inline int count(int x) &#123; return __builtin_popcount(x);&#125;inline int findPos(int x) &#123; return __builtin_ctz(x);&#125;inline int dfs(int S) &#123; if (S == 0) return 0; if (count(S) == 1) return 1; if (dp[S] &lt; INF) return dp[S]; int i = findPos(S); dp[S] = min(dp[S], dfs(S ^ (1 &lt;&lt; i)) + 1); for (int j = i + 1; j &lt; n; ++j) if (S &amp; (1 &lt;&lt; j)) &#123; dp[S] = min(dp[S], dfs(S &amp; sub[i][j]) + 1); &#125; return dp[S];&#125;int main()&#123;// freopen(\"test.in\", \"r\", stdin); testCase = readIn&lt;int&gt;(); while (testCase--) &#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 0; i &lt; n; ++i) scanf(\"%lf%lf\", &amp;x[i], &amp;y[i]); prepare(); memset(dp, INF, sizeof dp); int ans = dfs((1 &lt;&lt; n) - 1); printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/单调队列/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://yoursite.com/tags/树链剖分/"},{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"},{"name":"LCA","slug":"LCA","permalink":"http://yoursite.com/tags/LCA/"},{"name":"概率与期望","slug":"概率与期望","permalink":"http://yoursite.com/tags/概率与期望/"},{"name":"优先队列","slug":"优先队列","permalink":"http://yoursite.com/tags/优先队列/"},{"name":"状压 dp","slug":"状压-dp","permalink":"http://yoursite.com/tags/状压-dp/"}]},{"title":"NOIP 2015 整理","slug":"NOIP-2015-整理","date":"2017-11-02T08:05:35.000Z","updated":"2017-11-02T08:15:17.169Z","comments":true,"path":"2017/11/02/NOIP-2015-整理/","link":"","permalink":"http://yoursite.com/2017/11/02/NOIP-2015-整理/","excerpt":"Day 1神奇的幻方描述幻方是一种很神奇的 $N \\times N$ 矩阵：它由数字 $1,2,3, \\cdots , N \\times N$ 构成，且每行、每列及两条对角线上的数字之和都相同。","text":"Day 1神奇的幻方描述幻方是一种很神奇的 $N \\times N$ 矩阵：它由数字 $1,2,3, \\cdots , N \\times N$ 构成，且每行、每列及两条对角线上的数字之和都相同。 当 $N$ 为奇数时，我们可以通过以下方法构建一个幻方：首先将 $1$ 写在第一行的中间。之后,按如下方式从小到大依次填写每个数 $K(K = 2,3, \\cdots , N \\times N)$ ： 若 $(K − 1)$ 在第一行但不在最后一列，则将 $K$ 填在最后一行，$(K − 1)$ 所在列的右一列 若 $(K − 1)$ 在最后一列但不在第一行，则将 $K$ 填在第一列，$(K − 1)$ 所在行的上一行 若 $(K − 1)$ 在第一行最后一列，则将 $K$ 填在 $(K − 1)$ 的正下方 若 $(K − 1)$ 既不在第一行,也不在最后一列，如果 $(K − 1)$ 的右上方还未填数，则将 $K$ 填在 $(K − 1)$ 的右上方，否则将 $K$ 填在 $(K − 1)$ 的正下方。 现给定 $N$，请按上述方法构造 $N \\times N$ 的幻方。 $ 1 \\leq N \\leq 39$ 且 $N$ 为奇数。 分析记一下上一个数所在的位置 $(lastX, lastY)$ ，然后 $\\Theta(n^{2})$ 扫一遍，模拟一下。 具体细节见代码。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// Created by ZJYelizaveta on Thursday, October 19, 2017 AM09:07:14 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 39 + 3;const int INF = 0x3f3f3f3f;int n;int a[MAX_N][MAX_N];bool vis[MAX_N][MAX_N];int main()&#123; n = readIn&lt;int&gt;(); memset(vis, false, sizeof vis); a[1][(n + 1) / 2] = 1, vis[1][(n + 1) / 2] = true; int lastX = 1, lastY = (n + 1) / 2; // row, column// printf(\"%d %d\\n\", lastX, lastY); for (int i = 2; i &lt;= n * n; ++i) &#123; if (lastX == 1 &amp;&amp; lastY != n) &#123; lastX = n, lastY = lastY + 1; a[lastX][lastY] = i; vis[lastX][lastY] = true; &#125; else if (lastX != 1 &amp;&amp; lastY == n) &#123; lastX = lastX - 1, lastY = 1; a[lastX][lastY] = i; vis[lastX][lastY] = true; &#125; else if (lastX == 1 &amp;&amp; lastY == n) &#123; lastX = lastX + 1, lastY = lastY; a[lastX][lastY] = i; vis[lastX][lastY] = true; &#125; else &#123;// printf(\"%d\\n\", (int)vis[lastX - 1][lastY + 1]); if (vis[lastX - 1][lastY + 1] == true) &#123; lastX = lastX + 1, lastY = lastY; a[lastX][lastY] = i; vis[lastX][lastY] = true; &#125; else &#123; lastX = lastX - 1, lastY = lastY + 1; a[lastX][lastY] = i; vis[lastX][lastY] = true; &#125; &#125;// printf(\"%d %d\\n\", lastX, lastY); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) printf(\"%d%c\", a[i][j], j == n ? '\\n' : ' '); &#125; return 0;&#125; 信息传递描述有 $n$ 个同学（编号为 $1$ 到 $n$ ）正在玩一个信息传递的游戏。在游戏里每人都有一个固定的信息传递对象，其中，编号为 $i$ 的同学的信息传递对象是编号为 $T_{i}$ 的同学。游戏开始时，每人都只知道自己的生日。之后每一轮中，所有人会同时将自己当前所知的生日信息告诉各自的信息传递对象（注意：可能有人可以从若干人那里获取信息， 但是每人只会把信息告诉一个人，即自己的信息传递对象）。当有人从别人口中得知自 己的生日时，游戏结束。请问该游戏一共可以进行几轮？ $n \\leq 2 \\times 10^{5}$ 分析模拟了很久发现是找一个有向图的最小环。 说实话，真没想到拓扑排序上面。由于没有智商，所以强行 Tarjan，时间复杂度为 $\\Theta(n + m)$。 P.S. Blog 上面之前总结的 “ [关于图的连通性的三个Tarjan算法] “，有些地方有些小问题，找时间来改吧 ! 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// Created by ZJYelizaveta on Thursday, October 19, 2017 AM09:37:57 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 200000 + 3;const int INF = 0x3f3f3f3f;int n;int pre[MAX_N], lowlink[MAX_N], sccno[MAX_N], scc_cnt, timeStamp;vector&lt;int&gt; G[MAX_N];stack&lt;int&gt; S;int ans, size[MAX_N];namespace SCC &#123; inline void dfs(int u) &#123; pre[u] = lowlink[u] = ++timeStamp; S.push(u); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; int v = G[u][i]; if (!pre[v]) &#123; dfs(v); lowlink[u] = min(lowlink[u], lowlink[v]); &#125; else if (!sccno[v]) lowlink[u] = min(lowlink[u], pre[v]); &#125; if (lowlink[u] == pre[u]) &#123; ++scc_cnt; while (1) &#123; int x = S.top(); S.pop(); sccno[x] = scc_cnt; if (x == u) break; &#125; &#125; &#125; inline void findSCC() &#123; memset(pre, 0, sizeof pre); memset(lowlink, 0, sizeof lowlink); memset(sccno, 0, sizeof sccno); timeStamp = scc_cnt = 0; for (int i = 0; i &lt; n; ++i) if (!pre[i]) dfs(i); &#125;&#125;using namespace SCC;int main()&#123; n = readIn&lt;int&gt;(); for (int i = 0; i &lt;= n; ++i) G[i].clear(); for (int i = 1; i &lt;= n; ++i) &#123; int u = i, v = readIn&lt;int&gt;(); --u; --v; G[u].push_back(v); &#125; findSCC(); ans = INF; for (int i = 0; i &lt; n; ++i) ++size[sccno[i]]; for (int i = 1; i &lt;= scc_cnt; ++i) if (1 &lt; size[i]) ans = min(ans, size[i]); printf(\"%d\\n\", ans); return 0;&#125; 斗地主描述牛牛最近迷上了一种叫斗地主的扑克游戏。斗地主是一种使用黑桃、红心、梅花、方片的 $A$ 到 $K$ 加上大小王的共 $54$ 张牌来进行的扑克牌游戏。在斗地主中，牌的大小关 系根据牌的数码表示如下： 3&lt;4&lt;5&lt;6&lt;7&lt;8&lt;9&lt;10&lt;J&lt;Q&lt;K&lt;A&lt;2&lt;小王&lt;大王，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由 nn 张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。现在，牛牛只想知道，对于自己的若干组手牌，分别最少需要多少次出牌可以将它们打光。请你帮他解决这个问题。需要注意的是，本题中游戏者每次可以出手的牌型与一般的斗地主相似而略有不同。具体规则如下： $n \\leq 23, testCase \\leq 100$ 分析我练习的时候，还剩下 1.5h ，认真的思考了一下，好像并没有很清晰地思路，遂放弃刚正解。 于是我把特判的 30 分写了，然后还写挂了 $n = 4$ 的情况，我真是太菜啦qwq 思考正解。 一开始想到了搜索，但是并没有想到状压上面。那么这里就思考只用 dfs 怎么做吧！ 首先要确定 dfs 的可行性，考虑现在有 23 张牌，那么在最坏的情况下，需要出 13 次牌。情况是这样的：1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 大王, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12。也就是说如果加上最优性剪枝，那么搜索的层数不会超过 13 层。 这里搜索的时候根据贪心的思想优先出三种顺子 : 单顺子，双顺子，三顺子 ; 然后出三带一，三带二 …… 总之将单牌留在最后出。出顺子的时候枚举一下顺子的首和尾，出三带几的时候先确定主体的牌再枚举带的牌。 具体细节看代码吧，由于思路比较暴力，这个算法过不了 UOJ #151. 【NOIP2015】斗地主“加强”版 ，后面有时间再考虑怎么优化一下吧，正解应该还是 状压 + 搜索。 然后还要注意这里的四带二带的是不同的单牌或者是不同的一对牌。 时间复杂度 $\\Theta$ (玄学)，这个时间复杂度我不会算有没有大佬能教一下，谢谢！ 代码特判写的太丑了，就不放上来了qwq $100 \\%$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140// Created by ZJYelizaveta on 2017年10月31日 星期二 22时47分13秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 23 + 3;const int INF = 0x3f3f3f3f;int testCase, n;int cnt[MAX_N];int ans;inline void dfs(int depth) &#123; if (depth &gt;= ans) return; int res = depth; int h1, t1, h2, t2, h3, t3; h1 = t1 = 3, h2 = t2 = 3, h3 = t3 = 3; for (int i = 3; i &lt;= 15; ++i) &#123; if (cnt[i]) &#123; t1 = i; if (t1 - h1 &gt;= 4 &amp;&amp; i &lt; 15) &#123; // 单顺子 for (int j = h1; j &lt;= t1 - 4; ++j) &#123; // for (int k = j; k &lt;= t1; ++k) --cnt[k]; // dfs(depth + 1); for (int k = j; k &lt;= t1; ++k) ++cnt[k]; // &#125; &#125; &#125; else h1 = i + 1; if (cnt[i] &gt;= 2) &#123; t2 = i; if (t2 - h2 &gt;= 2 &amp;&amp; i &lt; 15) &#123; for (int j = h2; j &lt;= t2 - 2; ++j) &#123; for (int k = j; k &lt;= t2; ++k) cnt[k] -= 2; dfs(depth + 1); for (int k = j; k &lt;= t2; ++k) cnt[k] += 2; &#125; &#125; &#125; else h2 = i + 1; if (cnt[i] &gt;= 3) &#123; t3 = i; if (t3 - h3 &gt;= 1 &amp;&amp; i &lt; 15) &#123; // 三顺子 for (int j = h3; j &lt;= t3 - 1; ++j) &#123; for (int k = j; k &lt;= t3; ++k) cnt[k] -= 3; dfs(depth + 1); for (int k = j; k &lt;= t3; ++k) cnt[k] += 3; &#125; &#125; cnt[i] -= 3; for (int j = 3; j &lt;= 17; ++j) if (i != j &amp;&amp; cnt[j] &gt;= 1) &#123; // 三带一 --cnt[j]; dfs(depth + 1); ++cnt[j]; &#125; for (int j = 3; j &lt;= 15; ++j) if (i != j &amp;&amp; cnt[j] &gt;= 2) &#123; // 三带二 cnt[j] -= 2; dfs(depth + 1); cnt[j] += 2; &#125; cnt[i] += 3; &#125; else h3 = i + 1; if (cnt[i] &gt;= 4) &#123; cnt[i] -= 4; for (int j = 3; j &lt;= 17; ++j) if (i != j &amp;&amp; cnt[j] &gt;= 1) &#123; // 四带两张不同单牌 for (int k = 3; k &lt;= 17; ++k) if (i != k &amp;&amp; cnt[k] &gt;= 1) &#123; --cnt[j]; --cnt[k]; dfs(depth + 1); ++cnt[j]; ++cnt[k]; &#125; &#125; for (int j = 3; j &lt;= 15; ++j) if (i != j &amp;&amp; cnt[j] &gt;= 2) &#123; for (int k = 3; k &lt;= 15; ++k) if (i != k &amp;&amp; cnt[k] &gt;= 2) &#123; // 四带两对不同的单牌 cnt[j] -= 2; cnt[k] -= 2; dfs(depth + 1); cnt[j] += 2; cnt[k] += 2; &#125; &#125; cnt[i] += 4; &#125; &#125; if (cnt[16] &gt;= 1 &amp;&amp; cnt[17] &gt;= 1) &#123; --cnt[16]; --cnt[17]; dfs(depth + 1); ++cnt[16]; ++cnt[17]; &#125; for (int i = 3; i &lt;= 17; ++i) if (cnt[i]) ++res; // 单牌出完 ans = min(ans, res);&#125;int main()&#123; testCase = readIn&lt;int&gt;(); n = readIn&lt;int&gt;(); // while (testCase--) &#123; memset(cnt, 0, sizeof cnt); ans = 13; for (int i = 1; i &lt;= n; ++i) &#123; int a = readIn&lt;int&gt;(), b = readIn&lt;int&gt;(); if (a == 0) ++cnt[15 + b]; // king else if (a == 1 || a == 2) ++cnt[13 + a]; // A and 2 else ++cnt[a]; &#125; dfs(0); printf(\"%d\\n\", ans); &#125; return 0;&#125; Day 2跳石头描述一年一度的＂跳石头＂比赛又要开始了！这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。 $D \\leq M \\leq N \\leq 50000, 1 \\leq L \\leq 10^{9}$ 分析上一次做这道题目的时候还是去年的 10 月，当时太 Naive，怎么都想不明白为什么最大化最小值要二分qwq 好了，首先很明显这是一个最大化最小值问题，我们可以通过二分答案来做。 首先在读入起点和终点之间的石头距离起点的距离后，将起点和终点也加入进去（$d[0] = 0, d[N] = L$）。 令 $check(x)$ 为是否可以安排石头的位置使得相隔最近的两块石头之间的距离不小于 $x$。 那么我们需要求出最大的那个 $x$，我们用贪心的思想来判断，$pos$ 为上一个没有挪走的石块。 如果 $d[i] - d[pos] &lt;d$ ，那么我们需要将第 $i$ 块石头拿走。 否则，更新 $pos$ 即可。 时间复杂度 $\\Theta(nlogn)$ 。 这里提一下二分中的小技巧，如果是最大化最小值我们通常在左闭右开的区间中二分： 123456while (r - l &gt; 1) &#123; // [l, r) int mid = (l + r) &gt;&gt; 1; if (check(mid)) l = mid; else r = mid;&#125;ans = l; 反之，如果我们要最小化最大值，则通常在左开右闭的区间中二分： 123456while (r - l &gt; 1) &#123; // (l, r] int mid = (l + r) &gt;&gt; 1; if (check(mid)) r = mid; else l = mid;&#125;ans = r; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445// Created by ZJYelizaveta on Friday, October 20, 2017 AM08:54:05 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 50000 + 3;const int INF = 0x3f3f3f3f;int L, N, M;int d[MAX_N];inline bool check(int x) &#123; int cnt = M, pos = 0; for (int i = 1; i &lt; N + 2; ++i) &#123; if (d[i] - d[pos] &lt; x) --cnt; else pos = i; &#125; if (cnt &gt;= 0) return true; return false;&#125;int main()&#123; L = readIn&lt;int&gt;(), N = readIn&lt;int&gt;(), M = readIn&lt;int&gt;(); for (int i = 1; i &lt;= N; ++i) d[i] = readIn&lt;int&gt;(); d[N + 1] = L; d[0] = 0; int l = 1, r = L + 1; while (r - l &gt; 1) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) l = mid; else r = mid; &#125; printf(\"%d\\n\", l); return 0;&#125; 子串描述有两个仅包含小写英文字母的字符串 $A$ 和 $B$。现在要从字符串 $A$ 中取出 $k$ 个互不重叠的非空子串，然后把这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串，请问有多少种方案可以使得这个新串与字符串 $B$ 相等？ 注意：子串取出的位置不同也认为是不同的方案 。 $1 \\leq n \\leq 1000, 1 \\leq m \\leq 200, 1 \\leq k \\leq m$ 分析是一道思维难度很好的动态规划题目，动态规划一直都是我的弱项，要加强呀qwq 一开始看这道题目的时候很容易就想到动态规划，然后开始肝转移方程。 令 $dp[i][j][k]$ 为 A 串匹配到第 $i$ 个位置，B 串匹配到第 $j$ 个位置，已经用了 $k$ 个子串。 那么我们有转移方程： dp[i][j][k] = dp[i - 1][j - 1][k - 1] + dp[i - 1][j - 1] [k] (strA[i] == strB[j])好像很对的样子，恩，就是这样的。诶，好像有点点不对，如果我们不选择当前的字符怎么办，这个决策好像并没有被考虑进去。 上面的脑洞作废，重新开始，我们分情况来讨论。 我们令 $f[i][j][k]$ 为 A 串匹配到第 $i$ 个位置，B 串匹配到第 $j$ 个位置，已经用了 $k$ 个子串，一定会用 A 串的第 $i$ 个字符串方案数。 令 $g[i][j][k]$ 为 A 串匹配到第 $i$ 个位置，B 串匹配到第 $j$ 个位置，已经用了 $k$ 个子串的总方案数。 考虑转移方程先考虑 $f[i][j][k]$，当 $strA[i] = strB[j]$： 如果 A 串的第 $i$ 个字符自己成为一个子串那么 $f[i][j][k] = g[i - 1][j - 1][k - 1]$；如果 A 串的第 $i$ 个字符和前面的字符串成为一串，那么 $f[i][j][k] = f[i - 1][j - 1][k]$。 这样一来有转移方程 f[i][j][k] = g[i - 1][j - 1][k - 1] + f[i - 1][j - 1][k]​ 反之，若 $strA[i] \\neq strB[j]$，那么 f[i][j][k] = 0 考虑 $g[i][j][k]$，g[i][j][k] = g[i - 1][j][k] + f[i][j][k] 可以理解为，$g[i][j][k]$ 等于上一阶段不用 $strA[i - 1]$ 做为子串的方案数，加上使用 $strA[i - 1]$ 做为子串的方案数。 综上所述，我们有转移方程： f[i][j][k] = \\left\\{\\begin{matrix} g[i - 1][j - 1][k - 1] + f[i - 1][j - 1][k] & \\cdots &(strA[i - 1] = strB[j - 1])\\\\ 0 & \\cdots & (strA[i - 1] \\neq strB[j - 1]) \\end{matrix}\\right.g[i][j][k] = g[i - 1][j][k] + f[i][j][k]然后，如果我们转移方程开三维的话，会 MLE 所以考虑将第一维滚动一下。 代码$70 \\%$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Created by ZJYelizaveta on Friday, October 20, 2017 AM09:28:35 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int MAX_M = 100 + 3;const int MOD = 1e9 + 7;const int INF = 0x3f3f3f3f;int n, m, K;char strA[MAX_N], strB[MAX_M];int f[MAX_N][MAX_M][MAX_M], g[MAX_N][MAX_N][MAX_M];inline void solve() &#123; g[0][0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; g[i][0][0] = 1; for (int j = 1; j &lt;= m; ++j) &#123; if (strA[i] == strB[j]) &#123; for (int k = 1; k &lt;= min(j, K); ++k) &#123; f[i][j][k] = (g[i - 1][j - 1][k - 1] + f[i - 1][j - 1][k]) % MOD; g[i][j][k] = (g[i - 1][j][k] + f[i][j][k]) % MOD; &#125; &#125; else &#123; for (int k = 1; k &lt;= min(j, K); ++k) g[i][j][k] = g[i - 1][j][k]; &#125; &#125; &#125; printf(\"%d\\n\", (g[n][m][K] % MOD + MOD) % MOD);&#125;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(), K = readIn&lt;int&gt;(); scanf(\"%s\", strA + 1); scanf(\"%s\", strB + 1); solve(); return 0;&#125; $100 \\%$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Created by ZJYelizaveta on Friday, October 20, 2017 PM02:48:04 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int MAX_M = 200 + 3;const int MAX_K = 200 + 3;const int MOD = 1e9 + 7;const int INF = 0x3f3f3f3f;int n, m, K;char strA[MAX_N], strB[MAX_N];int f[MAX_N][MAX_K], g[MAX_N][MAX_K];inline void solve() &#123; g[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = m; j &gt;= 1; --j) &#123; if (strA[i] == strB[j]) &#123; for (int k = min(j, K); k &gt;= 1; --k) &#123; f[j][k] = (g[j - 1][k - 1] + f[j - 1][k]) % MOD; g[j][k] = (g[j][k] + f[j][k]) % MOD; &#125; &#125; else &#123; for (int k = min(j, K); k &gt;= 1; --k) f[j][k] = 0; &#125; &#125; &#125; printf(\"%d\\n\", (g[m][K] % MOD + MOD) % MOD);&#125;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(), K = readIn&lt;int&gt;(); scanf(\"%s\", strA + 1); scanf(\"%s\", strB + 1); solve(); return 0;&#125; 运输计划描述公元 2044 年，人类进入了宇宙纪元。​L 国有 $n$ 个星球，还有 $n - 1$ 条双向航道，每条航道建立在两个星球之间，这 $n - 1$ 条航道连通了 L 国的所有星球。小 P 掌管一家物流公司， 该公司有很多个运输计划，每个运输计划形如：有一艘物流飞船需要从 $u_{i}$ 号星球沿最快的宇航路径飞行到 $v_{i}$ 号星球去。显然，飞船驶过一条航道是需要时间的，对于航道 $j$，任意飞船驶过它所花费的时间为 $t_{j}$，并且任意两艘飞船之间不会产生任何干扰。为了鼓励科技创新，L 国国王同意小 P 的物流公司参与 L 国的航道建设，即允许小 P 把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。在虫洞的建设完成前小 P 的物流公司就预接了 $m$ 个运输计划。在虫洞建设完成后，这 $m$ 个运输计划会同时开始，所有飞船一起出发。当这 $m$ 个运输计划都完成时，小 P 的物流公司的阶段性工作就完成了。如果小 P 可以自由选择将哪一条航道改造成虫洞，试求出小 P 的物流公司完成阶段性工作所需要的最短时间是多少？ $n , m \\leq 300000$ 分析做这道题目的时候，我大概是一条没有梦想的咸鱼 qwq 部分分的话有 $\\Theta(n^{2})$ 的 50 分和 $m = 1$ 的 10 分，也就是暴力有 60 分，总体来说暴力分还是美滋滋的 qwq $\\Theta(n^{2})$ 的就是枚举那一条边改为虫洞，至于 $m = 1$ 的部分就 $\\Theta(n)$ 扫一遍即可。 考虑正解。 因为 “这 $m$ 个运输计划会同时开始，所有飞船一起出发” ，那么我们所求的其实就是最小化耗时最长的飞船的飞行时间，这是一个最小化最大值的问题，可以用二分来解决，那么每次二分一个时间 $mid$ 然后 check 一下。 还有一个套路就是在计算在 $u_{i}$ 和 $v_{i}$ 两点之间的耗费时间（距离）的时候，可以用 倍增 在 $\\Theta(logn)$ 的时间内计算。 现在要考虑一个问题如何在树上比较高效的 check 将一条边的时间变为 $0$ 后，$m$ 条路径的最大时间最小小于 $mid$ 。 我们先倍增预处理 $fa[i][j]$ 即 $i$ 的第 $2^{j}$ 级祖先，以及 $dis[i][j]$ 为从 $i$ 出发向上条 $2^{j}$ 级的路径长度。那么如果两点$u, v$ 之间的路径长度小于等于 $mid$ 则忽略，否则考虑在 $u, v$ 之间的路径中选择一条边，将这条边的权值变为 $0$ 。 那么问题就变为：check 求出两点之间距离大于 $mid$ 的路径的交集中的边权最大的边，看去掉这条边之后，是否满足 $m$ 条路径的最大时间最小小于 $mid$ 。 考虑求路径交集中的最长路径，我们有两种方法： 方法一路径 (a, c) ，(b, d) 之间的交集必定在 LCA(a, b)，LCA(a, c)，LCA(a, d)，LCA(b, c)，LCA(b, d)，LCA(c, d) 这六个点之间。暴力模拟一下求交集的过程，由于思想比较暴力，UOJ 上的 hack 数据会 TLE，但是对于官方数据还是可行的。 方法二我觉的方法二更妙一些 qwq 记 $total$ 为两点之间距离大于 $mid$ 的路径数量，而 $cnt_{i}$ 为这些路径中边 $e_{i}$ 被经过的次数。那么 $cnt_{i} = total$ 意味着边 $e_{i}$ 为这些路径的交集中的一条边。 每一轮二分都重新计算一次的时间复杂度为 $\\Theta(n^{2})$ ，这显然是不现实的。我们需要一个时间复杂度更优的方法，来维护每一条边被经过的次数。 这里就要用到树上前缀和了。 那么，如果要将一条边权变为 $0$ 怎么能较为高效的做到呢？这个和 NOIP 2012 借教室 一题中，我们用前缀和差分的思想差不多。在线性序列上，如果要将 $[l, r]$ 的区间 +k ，需要进行如下的操作： 那么令 $sum_{i}$ 为前 $i$ 位的前缀和，那么 $sum_{i}$ 可以表示为 $sum_{i} = \\sum_{j = 1}^{i}a_{i}$ ，如图所示： 那么如果在树上做前缀和呢？令 $sum[i]$ 为结点 $i$ 到 $i$ 的父亲这条边被经过的次数，$dis_{i}$ 为顶点 $i$ 到其父亲边上的权值。 树上两点 $u, v$ 之间的距离为 $dis[u] + dis[v] - dis[lca(u, v)]$ ，更新 $u, v$ 之间路径被经过的次数则进行操作 ++sum[u] , ++sum[v] , sum[lca(u, v)] - 2 ，树上前缀和则为 $sum_{i} = \\sum_{k \\in son(i)}sum_{k}$ 。 我们可以利用树的 dfs 序，在 $\\Theta(n)$ 的时间复杂度内计算出 $sum_{i}$ 的前缀和。 总时间复杂度 $\\Theta(nlogn + mlogn + 2logn(m + n))$ 。 代码$60 \\%$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// Created by ZJYelizaveta on Wednesday, November 01, 2017 AM09:10:39 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100000 + 3;const int MAX_M = 3000 + 3;const int INF = 0x3f3f3f3f;const int MAX_LOG_N = 15 + 3;int n, m;struct Edge &#123; int to; ll w; Edge(int to, ll w) : to(to), w(w) &#123;&#125;&#125;;vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1];int s[MAX_N], t[MAX_N]; // start , end;inline void addEdge(int from, int to, ll cost) &#123; G[from].push_back(Edge(to, cost)); G[to].push_back(Edge(from, cost));&#125;int depth[MAX_N], fa[MAX_N];ll val[MAX_N];inline void dfs(int u, int f) &#123; depth[u] = depth[f] + 1; fa[u] = f; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.to == f) continue; val[e.to] = e.w; dfs(e.to, u); &#125;&#125;inline void solve1(int u, int v) &#123; ll res = 0, mx = 0; if (depth[u] &lt; depth[v]) swap(u, v); while (depth[u] &gt; depth[v]) &#123; res += val[u]; mx = max(mx, val[u]); u = fa[u]; &#125; while (u != v) &#123; res += val[u]; res += val[v]; mx = max(mx, max(val[u], val[v])); u = fa[u], v = fa[v]; &#125; printf(\"%lld\\n\", res - mx);&#125;int road[MAX_M][MAX_M];inline ll calculate(int i, int u, int v) &#123; ll res = 0; if (depth[u] &lt; depth[v]) swap(u, v); while (depth[u] &gt; depth[v]) &#123; res += val[u]; road[u][i] = 1; u = fa[u]; &#125; while (u != v) &#123; res += val[u]; res += val[v]; road[u][i] = 1; road[v][i] = 1; u = fa[u]; v = fa[v]; &#125; return res;&#125;ll ans[MAX_N];inline void solve2() &#123; ll res = -1; memset(road, 0, sizeof road); for (int i = 1; i &lt;= m; ++i) &#123; ans[i] = calculate(i, s[i], t[i]); res = max(res, ans[i]); &#125; for (int i = 1; i &lt;= n; ++i) &#123; // ll temp = 0; for (int j = 1; j &lt;= m; ++j) &#123; temp = max(temp, (ll)ans[j] - val[i] * road[i][j]); // &#125; if (res == -1 || res &gt; temp) res = temp; &#125; printf(\"%lld\\n\", res);&#125;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n - 1; ++i) &#123; int u = readIn&lt;int&gt;(), v = readIn&lt;int&gt;(), w = readIn&lt;ll&gt;(); addEdge(u, v, w); &#125; for (int i = 1; i &lt;= m; ++i) s[i] = readIn&lt;int&gt;(), t[i] = readIn&lt;int&gt;(); dfs(1, 0); if (m == 1) solve1(s[1], t[1]); else solve2(); return 0;&#125; 方法一： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202// Created by ZJYelizaveta on Wednesday, November 01, 2017 PM02:10:47 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 300000 + 3;const int MAX_LOG_N = 15 + 3;const int INF = 0x3f3f3f3f;int n, m;struct Edge &#123; int to, next, w;&#125;edge[MAX_N &lt;&lt; 1];int head[MAX_N], cnt = 0;int s[MAX_N], t[MAX_N];int depth[MAX_N], fa[MAX_N][MAX_LOG_N], dis[MAX_N][MAX_LOG_N], maxVal[MAX_N][MAX_LOG_N];inline void addEdge(int from, int to, int w) &#123; edge[++cnt].to = to; edge[cnt].w = w; edge[cnt].next = head[from]; head[from] = cnt; edge[++cnt].to = from; edge[cnt].w = w; edge[cnt].next = head[to]; head[to] = cnt;&#125;inline void dfs(int u, int f) &#123; depth[u] = f == 0 ? 0 : depth[f] + 1; fa[u][0] = f; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (v == f) continue; dis[v][0] = edge[i].w; maxVal[v][0] = edge[i].w; dfs(v, u); &#125;&#125;int allCost, maxCost, lca;inline void query(int u, int v) &#123; allCost = 0, maxCost = 0, lca = 0; if (depth[u] &lt; depth[v]) swap(u, v); for (int i = MAX_LOG_N - 1; i &gt;= 0; --i) &#123; if (depth[u] - (1 &lt;&lt; i) &gt;= depth[v]) &#123; allCost += dis[u][i]; maxCost = max(maxCost, maxVal[u][i]);// printf(\"%d %d %d %d %d\\n\", u, i, fa[u][i], dis[u][i], maxVal[u][i]); u = fa[u][i]; &#125; &#125; if (u == v) &#123; lca = u; return; &#125; for (int i = MAX_LOG_N - 1; i &gt;= 0; --i) &#123; if (depth[u] - (1 &lt;&lt; i) &gt;= 0 &amp;&amp; fa[u][i] != fa[v][i]) &#123; allCost += dis[u][i]; allCost += dis[v][i]; maxCost = max(maxCost, max(maxVal[u][i], maxVal[v][i]));// printf(\"%d %d %d %d %d\\n\", u, i, fa[u][i], dis[u][i], maxVal[u][i]);// printf(\"%d %d %d %d %d\\n\", v, i, fa[v][i], dis[v][i], maxVal[v][i]); u = fa[u][i]; v = fa[v][i]; &#125; &#125; allCost = allCost + dis[u][0] + dis[v][0]; maxCost = max(maxCost, max(maxVal[u][0], maxVal[v][0])); lca = fa[u][0];&#125;int sum[MAX_N];inline void prepare() &#123; for (int j = 1; j &lt; MAX_LOG_N; ++j) &#123; for (int i = 1; i &lt;= n; ++i) &#123; fa[i][j] = fa[fa[i][j - 1]][j- 1]; dis[i][j] = dis[i][j - 1] + dis[fa[i][j - 1]][j - 1]; maxVal[i][j] = max(maxVal[i][j - 1], maxVal[fa[i][j - 1]][j - 1]); &#125; &#125;/* for (int j = 0; j &lt; MAX_LOG_N; ++j) &#123; for (int i = 1; i &lt;= n; ++i) &#123; printf(\"%d %d %d %d %d\\n\", i, j, fa[i][j], dis[i][j], maxVal[i][j]); &#125; printf(\"\\n\"); &#125;*/ for (int i = 1; i &lt;= m; ++i) &#123; query(s[i], t[i]); sum[i] = allCost; &#125;// for (int i = 1; i &lt;= m; ++i) printf(\"%d %d\\n\", i, sum[i]);&#125;inline int LCA(int u, int v) &#123; query(u, v); return lca;&#125;inline int length(int u, int v) &#123; query(u, v); return allCost;&#125;inline int maxLength(int u, int v) &#123; query(u, v); return maxCost;&#125;inline int inPath(int a, int b, int c, int d) &#123; int len1 = length(a, c), len2 = length(a, d), len3 = length(c, d); if (len2 &lt; len1) &#123; swap(c, d); len1 = len2; &#125; int len4 = length(b, d); return (len1 + len3 + len4 == length(a, b)) ? len3 : 0;&#125;inline int getIntersection(int &amp;a, int &amp;b, int c, int d) &#123; int u = -1, v = -1, nowLength = 0; vector&lt;int&gt; vec; // 为什么把 vector 放在外面会超时？ 求教qwq vec.push_back(LCA(a, b)); vec.push_back(LCA(a, c)); vec.push_back(LCA(a, d)); vec.push_back(LCA(b, c)); vec.push_back(LCA(b, d)); vec.push_back(LCA(c, d)); vec.erase(unique(vec.begin(), vec.end()), vec.end()); for (int i = 0; i &lt; (int)vec.size(); ++i) &#123; for (int j = i + 1; j &lt; (int)vec.size(); ++j) &#123; int len = inPath(a, b, vec[i], vec[j]); if (len &gt; nowLength &amp;&amp; inPath(c, d, vec[i], vec[j])) &#123; u = vec[i]; v = vec[j]; nowLength = len; &#125; &#125; &#125; a = u, b = v; return nowLength;&#125;inline bool check(int lim) &#123; int a = -1, b = -1; for (int i = 1; i &lt;= m; ++i) &#123; if (sum[i] &lt;= lim) continue; if (a == -1 &amp;&amp; b == -1) a = s[i], b = t[i]; else if (getIntersection(a, b, s[i], t[i]) &lt;= 0) return false; &#125; int decrease = maxLength(a, b); for (int i = 1; i &lt;= m; ++i) &#123; if (sum[i] - decrease &gt; lim) return false; &#125; return true;&#125;inline void solve() &#123; int l = -1, r = 300000000; while (r - l &gt; 1) &#123; int mid = (l + r) &gt;&gt; 1;// printf(\"%d %d %d\\n\", l, r, mid); if (check(mid)) r = mid; else l = mid; // &#125; printf(\"%d\\n\", r);&#125;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); memset(head, -1, sizeof head); for (int i = 1; i &lt;= n - 1; ++i) &#123; int u = readIn&lt;int&gt;(), v = readIn&lt;int&gt;(), w = readIn&lt;int&gt;(); addEdge(u, v, w); &#125; for (int i = 1; i &lt;= m; ++i) s[i] = readIn&lt;int&gt;(), t[i] = readIn&lt;int&gt;(); dfs(1, 0); prepare(); solve();// fprintf(stderr, \"Time used : %.3f\\n\", (double)clock() / CLOCKS_PER_SEC); return 0;&#125; 好了，在 Lantern 的帮助下明白了为什么吧 vector 放在外面会 TLE。就是如果吧 vector 放在外面每一次求 (a, c) , (b, d) 线段的交的时候把他们和之前的 LCA 都累加了，求完线段交之后又没有清空 vector （因为 vector 此时是作为全局变量而言的），这样每次去重的效率就很低，自然而然就 TLE 了 $100 \\%$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138// Created by ZJYelizaveta on 2017年11月02日 星期四 17时20分28秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 300000 + 3;const int MAX_LOG_N = 17 + 3;const int INF = 0x3f3f3f3f;int n, m;struct Edge &#123; int to, w; Edge (int to, int w) : to(to), w(w)&#123;&#125;&#125;;vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1];int s[MAX_N], t[MAX_N];int depth[MAX_N], dis[MAX_N], val[MAX_N], fa[MAX_N][MAX_LOG_N];int lca[MAX_N], cost[MAX_N];inline void addEdge(int from, int to, int cost) &#123; G[from].push_back(Edge(to, cost)); G[to].push_back(Edge(from, cost));&#125;int pos[MAX_N], timeStamp = 0;inline void dfs(int u, int f) &#123; pos[++timeStamp] = u; depth[u] = f == 0 ? 0 : depth[f] + 1; fa[u][0] = f; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.to == f) continue; val[e.to] = e.w; dis[e.to] = dis[u] + e.w; dfs(e.to, u); &#125;&#125;inline int LCA(int a, int b) &#123; if (depth[a] &lt; depth[b]) swap(a, b); for (int i = MAX_LOG_N - 1; i &gt;= 0; --i) &#123; if (depth[a] - (1 &lt;&lt; i) &gt;= depth[b]) &#123; a = fa[a][i]; &#125; &#125; if (a == b) return a; for (int i = MAX_LOG_N - 1; i &gt;= 0; --i) &#123; if (depth[a] - (1 &lt;&lt; i) &gt;= 0 &amp;&amp; fa[a][i] != fa[b][i]) &#123; a = fa[a][i], b = fa[b][i]; &#125; &#125; return fa[a][0];&#125;inline void prepare() &#123;// for (int i = 1; i &lt;= n; ++i) printf(\"%d \", pos[i]); printf(\"\\n\");// for (int i = 1; i &lt;= n; ++i) printf(\"%d fa = %d depth = %d val = %d dis = %d\\n\", i, fa[i][0], depth[i], val[i], dis[i]); for (int j = 1; j &lt; MAX_LOG_N; ++j) &#123; for (int i = 1; i &lt;= n; ++i) &#123; fa[i][j] = fa[fa[i][j - 1]][j - 1]; &#125; &#125; for (int i = 1; i &lt;= m; ++i) &#123; lca[i] = LCA(s[i], t[i]); cost[i] = dis[s[i]] + dis[t[i]] - 2 * dis[lca[i]]; &#125;// for (int i = 1; i &lt;= m; ++i) printf(\"%d %d %d\\n\", i, lca[i], cost[i]);&#125;int sum[MAX_N];inline bool check(int lim) &#123; int cnt = 0; memset(sum, 0, sizeof sum); for (int i = 1; i &lt;= m; ++i) &#123; if (cost[i] &lt;= lim) continue; ++cnt; ++sum[s[i]], ++sum[t[i]], sum[lca[i]] -= 2; &#125; if (cnt == 0) return true; for (int i = n; i &gt;= 1; --i) &#123; sum[fa[pos[i]][0]] += sum[pos[i]]; &#125; int dec = 0; // max decrease for (int i = 1; i &lt;= n; ++i) &#123; if (sum[i] == cnt) dec = max(dec, val[i]); &#125; for (int i = 1; i &lt;= m; ++i) &#123; if (cost[i] - dec &gt; lim) return false; &#125; return true;&#125;inline void solve() &#123; int l = -1, r = INF; while (r - l &gt; 1) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) r = mid; else l = mid; &#125; printf(\"%d\\n\", r);&#125;int main()&#123;// freopen(\"test.in\", \"r\", stdin); n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n - 1; ++i) &#123; int u = readIn&lt;int&gt;(), v = readIn&lt;int&gt;(), w = readIn&lt;int&gt;(); addEdge(u, v, w); &#125; for (int i = 1; i &lt;= m; ++i) s[i] = readIn&lt;int&gt;(), t[i] = readIn&lt;int&gt;(); dfs(1, 0); prepare(); solve(); return 0;&#125; 写完这个树上前缀和这个方法后，美滋滋的去 UOJ 上交，以为可以过 Extra test，结果还是 97 分qwq，不是 TLE 但是 WA 了。内心比较崩溃，很仔细的看了好几遍程序，没问题呀，绝望之下改了一下 MAX_LOG_N 的大小，再交，然后 A 了qwq。可是 $ln(3 \\times 10^{5}) = 13$ 不是吗，$ln$ 的底数可是自然数 $e$ 呀，[关爱智障的眼神].jpg","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"},{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/二分/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://yoursite.com/tags/拓扑排序/"},{"name":"强连通分量","slug":"强连通分量","permalink":"http://yoursite.com/tags/强连通分量/"},{"name":"LCA","slug":"LCA","permalink":"http://yoursite.com/tags/LCA/"},{"name":"树上前缀和","slug":"树上前缀和","permalink":"http://yoursite.com/tags/树上前缀和/"},{"name":"差分","slug":"差分","permalink":"http://yoursite.com/tags/差分/"},{"name":"倍增","slug":"倍增","permalink":"http://yoursite.com/tags/倍增/"}]},{"title":"NOIP 2012 整理","slug":"NOIP-2012-整理","date":"2017-10-30T23:21:36.000Z","updated":"2017-11-02T08:09:31.399Z","comments":true,"path":"2017/10/31/NOIP-2012-整理/","link":"","permalink":"http://yoursite.com/2017/10/31/NOIP-2012-整理/","excerpt":"Day 1Vigenère 密码描述16 世纪法国外交家 Blaise de Vigenère 设计了一种多表密码加密算法 —— Vigenère 密码。Vigenère 密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。在密码学中，我们称需要加密的信息为明文，用 $M$ 表示；称加密后的信息为密文，用$C$ 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 $k$。 在 Vigenère","text":"Day 1Vigenère 密码描述16 世纪法国外交家 Blaise de Vigenère 设计了一种多表密码加密算法 —— Vigenère 密码。Vigenère 密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。在密码学中，我们称需要加密的信息为明文，用 $M$ 表示；称加密后的信息为密文，用$C$ 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 $k$。 在 Vigenère 密码中，密钥 $k$ 是一个字母串，$k=k_{1} k_{2} \\cdots k_{n}$ 。当明文 $M=m_{1}m_{2} \\cdots m_{n}$ 时，得到的密文 $C=c_{1} c_{2} \\cdots c_{n}$ ，其中 $c_{i} =m_{i} ®k_{i}$ 运算 ® 的规则如，下表所示： Vigenère 加密在操作时需要注意： ® 运算忽略参与运算的字母的大小写，并保持字母在明文 $M$ 中的大小写形式。 当明文 $M$ 的长度大于密钥 $k$ 的长度时，将密钥 $k$ 重复使用。 输入的密匙长度不超过 $100$，输入的密文的长度不超过 $1000$，且都仅包含英文字母。 分析当我看到这个图的时候，我的内心是拒绝的，然后我很认真的找了一下规律。 我们令横坐标表示明文，纵坐标为密钥。 那么 m_{i}=\\left\\{\\begin{matrix} c_{i} -k_{i} & (c_{i} - k_{i} \\geq 0)\\\\ c_{i} - k_{i} + 26 & (c_{i} - k_{i} < 0) \\end{matrix}\\right.然后根据 ACSII 表的特点，在 $\\Theta(n)$ 的时间内模拟一遍，注意判断一下大小写。 代码12345678910111213141516171819202122232425262728293031323334353637// Created by ZJYelizaveta on Friday, October 20, 2017 PM03:31:14 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3; // keyconst int MAX_M = 1000 + 3; // secret stringchar str1[MAX_N], str2[MAX_M];int len1, len2;int main()&#123; scanf(\"%s\", str1); scanf(\"%s\", str2); len1 = strlen(str1), len2 = strlen(str2); for (int i = 0; i &lt; len1; ++i) str1[i] = toupper(str1[i]); for (int i = 0; i &lt; len2; ++i) &#123; int num = (toupper(str2[i]) - str1[i % len1] + 26) % 26; if (isupper(str2[i])) putchar('A' + num); else putchar('a' + num); &#125; return 0;&#125; 国王游戏描述恰逢 H 国国庆，国王邀请 $n​$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n​$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 $1 \\leq n \\leq 1000, 1 \\leq a, b \\leq 10000$ 分析想不到正解，然后贪心拿了 60 分。 有两个人 $i, j$ ， $i$ 在 $j$ 前面更优一些，当且仅当 $sum \\times \\frac{q[i].a}{q[j].b} &lt; sum \\times \\frac{q[j].a}{q[i].b}$ ，即 $ \\frac{q[i].a}{q[j].b} &lt; \\frac{q[j].a}{q[i].b}$，以这样的方式排序，我们可以拿到 60 分。 那么剩下的 40 分为什么拿不到呢qwq，因为 $a, b \\leq 10^{4}$，而最极端的情况下会有 $1000$ 个 $10^{4}$ 相乘，这种情况下肯定是要用高精度来解决的。 那么代码剩下的部分就是在于手写高精度啦，就当 NOIP 之前复习一下高精度啦，写的差点吐了。 代码$60 \\%$ 骗分大法好qwq 123456789101112131415161718192021222324252627282930313233343536373839404142434445// Created by ZJYelizaveta on Friday, October 20, 2017 PM03:52:49 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int INF = 0x3f3f3f3f;int n;struct Person &#123; int a, b; bool operator &lt; (const Person &amp;rhs) const &#123; return a / rhs.b &lt; rhs.a / b; &#125;&#125;q[MAX_N];int ans[MAX_N], res;int main()&#123; n = readIn&lt;int&gt;(); q[0].a = readIn&lt;int&gt;(), q[0].b = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) q[i].a = readIn&lt;int&gt;(), q[i].b = readIn&lt;int&gt;(); sort(q + 1, q + n + 1); for (int i = 1; i &lt;= n; ++i) &#123; ans[i] = 1; for (int j = 0; j &lt; i; ++j) ans[i] *= q[j].a; ans[i] /= q[i].b; &#125; res = -INF; for (int i = 1; i &lt;= n; ++i) res = max(res, ans[i]); printf(\"%d\\n\", res); return 0;&#125; $100 \\%$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176// Created by ZJYelizaveta on Thursday, October 26, 2017 AM08:45:14 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int INF = 0x3f3f3f3f;int n;struct Person &#123; int a, b; bool operator &lt; (const Person &amp;rhs) const &#123; return a * b &lt; rhs.a * rhs.b; &#125;&#125;q[MAX_N];struct BigInt &#123; vector&lt;int&gt; v; static const int BASE = 10; BigInt(ll x) &#123; do &#123; v.push_back(x % 10); &#125; while (x /= 10); &#125; BigInt(const string &amp;str) &#123; v.reserve(str.length()); for (int i = str.length() - 1; i &gt;= 0; --i) &#123; v.push_back(str[i] - '0'); &#125; &#125; BigInt() &#123;&#125; void removePreZero() &#123; while (v.size() &gt;= 1 &amp;&amp; v.back() == 0) v.pop_back(); &#125; bool operator&lt;(const BigInt &amp;a) const &#123; if (v.size() != a.v.size()) &#123; return v.size() &lt; a.v.size(); &#125; for (int i = v.size() - 1; i &gt;= 0; --i) &#123; if (v[i] != a.v[i]) &#123; return v[i] &lt; a.v[i]; &#125; &#125; return false; // equal &#125; bool operator&gt;(const BigInt &amp;a) const &#123; return a &lt; *this; &#125; bool operator&lt;=(const BigInt &amp;a) const &#123; return !(a &lt; *this); &#125; bool operator&gt;=(const BigInt &amp;a) const &#123; return !(a &gt; *this); &#125; bool operator!=(const BigInt &amp;a) const &#123; return a &lt; *this || a &gt; *this; &#125; bool operator==(const BigInt &amp;a) const &#123; return !(a &lt; *this) &amp;&amp; !(a &gt; *this); &#125; BigInt operator+(const BigInt &amp;a) const &#123; BigInt res; int sum = 0; for (int i = 0; i &lt; max(v.size(), a.v.size()); ++i) &#123; if (i &lt; a.v.size()) sum += a.v[i]; if (i &lt; v.size()) sum += v[i]; res.v.push_back(sum % BASE); sum /= BASE; &#125; if (sum) res.v.push_back(sum); res.removePreZero(); return res; &#125; BigInt operator-(const BigInt &amp;a) const &#123; BigInt res; int dif = 0; for (int i = 0; i &lt; max(v.size(), a.v.size()); ++i) &#123; if (i &lt; v.size()) dif += v[i]; if (i &lt; a.v.size()) dif -= a.v[i]; if (dif &gt;= 0) &#123; res.v.push_back(dif); dif = 0; &#125; else &#123; res.v.push_back((dif + BASE) % BASE); dif = -1; &#125; &#125; res.removePreZero(); return res; &#125; BigInt operator*(const BigInt &amp;a) const &#123; BigInt res; res.v.resize(v.size() + a.v.size(), 0); // for (int i = 0; i &lt; v.size(); ++i) &#123; for (int j = 0; j &lt; a.v.size(); ++j) &#123; res.v[i + j] += v[i] * a.v[j]; res.v[i + j + 1] += res.v[i + j] / BASE; res.v[i + j] %= BASE; &#125; &#125; res.removePreZero(); return res; &#125; BigInt operator/(const BigInt &amp;a) const &#123; BigInt res, ret(0); res.v.resize(v.size(), 0); ret = 0; for (int i = v.size() - 1; i &gt;= 0; --i) &#123; ret = ret * 10 + v[i]; while (ret &gt;= a) &#123; ret = ret - a; res.v[i]++; &#125; &#125; res.removePreZero(); return res; &#125;&#125;;istream&amp; operator&gt;&gt;(istream &amp;in, BigInt &amp;x) &#123; string str; in &gt;&gt; str; x = BigInt(str); return in;&#125;ostream&amp; operator&lt;&lt;(ostream &amp;out, const BigInt &amp;x) &#123; for (int i = x.v.size() - 1; i &gt;= 0; --i) &#123; cout &lt;&lt; x.v[i]; &#125; return out;&#125;int main()&#123; n = readIn&lt;int&gt;(); for (int i = 0; i &lt;= n; ++i) q[i].a = readIn&lt;int&gt;(), q[i].b = readIn&lt;int&gt;(); sort(q + 1, q + n + 1); BigInt ans = 0, sum = 1; for (int i = 0; i &lt; n; ++i) sum = sum * q[i].a; ans = sum / q[n].b; ans = ans &lt;= 1 ? 1 : ans; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 开车旅行描述小 A 和小 B 决定利用假期外出旅行，他们将想去的城市从 $1$ 到 $N$ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $i$ 的海拔高度为 $H_{i}$ ，城市 $i$ 和城市 $j$ 之间的距离 $d[i,j]$ 恰好是这两个城市海拔高度之差的绝对值，即 $d[i, j] = \\left |H_{i} − H_{j} \\right |$。旅行过程中，小 A 和小 B 轮流开车，第一天小 A 开车，之后每天轮换一次。他们计划选择一个城市 $S$ 作为起点，一直向东行驶，并且最多行驶 $X$ 公里就结束旅行。小 A 和小 B 的驾驶风格不同，小 B 总是沿着前进方向选择一个最近的城市作为目的地，而小 A 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $X$ 公里，他们就会结束旅行。在启程之前，小 A 想知道两个问题： 对于一个给定的 $X=X_{0}$ ，从哪一个城市出发，小 A 开车行驶的路程总数与小 B 行驶的路程总数的比值最小（如果小 B 的行驶路程为 $0$ ，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 A 开车行驶的路程总数与小 B 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。 对任意给定的 $X=X_{i}$ 和出发城市 $S_{i}$ ，小 A 开车行驶的路程总数以及小 B 行驶的路程总数。 $1≤N≤100000,1≤M≤10000,-1000000000≤H_{i} ≤1000000000,0≤X_{0}≤1000000000,1≤S_{i} ≤N,0≤X_{i} ≤1000000000$ ，数据保证 $H_{i}$ 互不相同 分析题目描述很恶心，但是出题人的部分分还是给的比较良心的，首先 $\\Theta(n^{2})$ 预处理从每个点出发的最小值和次小值和到达的点，然后第一问枚举每一个点模拟，第二问一样模拟，这样可以拿到 70 分。时间复杂度约为 $\\Theta(n^{2} + n^{2} + nm)$ 。 考虑正解。 $\\Theta(n^{2})$ 预处理的代价太大了，考虑降低时间复杂度。因为这里我们只需要求出每一个点与后面的点中的距离最小值与次小值，所以要考虑用链表 $\\Theta(n)$ 维护每一个点的前驱和后继，然后求出最小值和次小值。当然也可以考虑用平衡树 $\\Theta(nlogn)$ 维护前驱和后继，这里可以不用写 Splay 直接用 STL 中的 set 来维护。 同样第一问我们暴力模拟的时间复杂度接近 $\\Theta(n^{2})$ 暴力模拟第二问的时间复杂度也接近 $\\Theta(nm)$ ，所以考虑优化。 这里应该是一个套路，我们可以像求 LCA 一样，我们用倍增来求，每一轮让 A, B 各跳一次。 $fa[i][j]$ 为从 $i$ 出发跳 $2^{j}$ 轮之后到达的位置。（一轮为 A, B 各跳一次）。 $disA[i][j]$ 为从 $i$ 出发跳 $2^{j}$ 次后走的距离。$disB[i][j]$ 为从 $i$ 出发条 $2^{j}$ 次后走的距离。 用双向链表预处理是我没有想到的，虽然最后还是用 set 水过去的，但是不可否认这道题目的思维含量还是不错的，需要注意许多小细节，免得不小心翻车 qwq 总时间复杂度 $\\Theta(2nlogn + mlogn)$ 。真 $\\cdot$ 调了一上午qwq 代码$70 \\%$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// Created by ZJYelizaveta on Monday, October 30, 2017 AM09:06:03 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int MAX_M = 10000 + 3;const int INF = INT_MAX;const double inf = 0x7fffffff;int n, m;int h[MAX_N];int X0;int s[MAX_M], x[MAX_M];struct Node &#123; int to, dist;&#125;a[MAX_N], b[MAX_N];inline void prepare() &#123; for (int i = 1; i &lt;= n; ++i) a[i].dist = b[i].dist = INF; for (int i = 1; i &lt;= n; ++i) a[i].to = b[i].to = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = i + 1; j &lt;= n; ++j) &#123; int temp = abs(h[i] - h[j]); if (!b[i].to || temp &lt; b[i].dist || (temp == b[i].dist &amp;&amp; h[j] &lt; h[b[i].to])) &#123; a[i] = b[i]; b[i].to = j; b[i].dist = temp; &#125; else if (!a[i].to || temp &lt; a[i].dist || (temp == a[i].dist &amp;&amp; h[j] &lt; h[a[i].to])) &#123; a[i].to = j; a[i].dist = temp; &#125; &#125; &#125;/* for (int i = 1; i &lt;= n; ++i) &#123; printf(\"%d %d\\n\", a[i].to, a[i].dist); printf(\"%d %d\\n\", b[i].to, b[i].dist); printf(\"\\n\"); &#125;*/&#125;inline void solve1() &#123; int X = X0, res = 1; double ans = inf, temp; for (int i = 1; i &lt;= n; ++i) &#123; int dist = 0, op = 0, pos = i, sumA = 0, sumB = 0; while (1) &#123; if (op == 0) &#123; // A drive the car if (dist + a[pos].dist &gt; X || a[pos].to == 0) break; dist += a[pos].dist; sumA += a[pos].dist; pos = a[pos].to; &#125; else &#123; if (dist + b[pos].dist &gt; X || b[pos].to == 0) break; dist += b[pos].dist; sumB += b[pos].dist; pos = b[pos].to; &#125; op ^= 1; &#125; if (sumB == 0) temp = inf; else temp = (double)sumA / (double)sumB; if (temp &lt; ans || (temp == ans &amp;&amp; h[i] &gt; h[res])) &#123; ans = temp; res = i; &#125; &#125;// printf(\"%.3f\\n\", ans); printf(\"%d\\n\", res);&#125;inline void solve2(int pos, int X) &#123; int dist = 0, op = 0, sumA = 0, sumB = 0; while (1) &#123; if (op == 0) &#123; // A drive the car if (dist + a[pos].dist &gt; X || a[pos].to == 0) break; dist += a[pos].dist; sumA += a[pos].dist; pos = a[pos].to; &#125; else &#123; if (dist + b[pos].dist &gt; X || b[pos].to == 0) break; dist += b[pos].dist; sumB += b[pos].dist; pos = b[pos].to; &#125; op ^= 1; &#125; printf(\"%d %d\\n\", sumA, sumB);&#125;int main()&#123; n = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) h[i] = readIn&lt;int&gt;();// for (int i = 1; i &lt;= n; ++i) printf(\"%d \", h[i]); printf(\"\\n\"); X0 = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 1; i &lt;= m; ++i) s[i] = readIn&lt;int&gt;(), x[i] = readIn&lt;int&gt;(); prepare(); solve1(); for (int i = 1; i &lt;= m; ++i) &#123; solve2(s[i], x[i]); &#125; return 0;&#125; $100 \\%$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), fa(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') fa = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * fa;&#125;const int MAX_N = 1000000 + 3;const int MAX_LOG_N = 17 + 3;const int INF = INT_MAX;const ll INFLL = 0x3f3f3f3f3f3f3f3fll;const double inf = 0x7fffffff;int n, m;int X0;int S[MAX_N], X[MAX_N];struct City &#123; int high, pos; bool operator &lt; (const City &amp;rhs) const &#123; return high &lt; rhs.high; &#125;&#125;a[MAX_N];set &lt;City&gt; s;struct temp &#123; int pos, diff; bool operator &lt; (const temp &amp;rhs) const &#123; if (diff != rhs.diff) return diff &lt; rhs.diff; return a[pos].high &lt; a[rhs.pos].high; &#125;&#125;q[5];int nextA[MAX_N], nextB[MAX_N], fa[MAX_N][MAX_LOG_N];long long disA[MAX_N][MAX_LOG_N], disB[MAX_N][MAX_LOG_N];inline void find(int i) &#123; set&lt;City&gt;::iterator it = s.find(a[i]); int add = 0; if (it != s.begin()) &#123; --it; q[++add] = (temp)&#123;it -&gt; pos, abs(it -&gt; high - a[i].high)&#125;; if (it != s.begin()) &#123; --it; q[++add] = (temp)&#123;it -&gt; pos, abs(it -&gt; high - a[i].high)&#125;; ++it; &#125; ++it; &#125; if ((++it) != s.end()) &#123; q[++add] = (temp)&#123;it -&gt; pos, abs(it -&gt; high - a[i].high)&#125;; if ((++it) != s.end()) &#123; q[++add] = (temp)&#123;it -&gt; pos, abs(it -&gt; high - a[i].high)&#125;; &#125; &#125; sort(q + 1, q + add + 1);/* printf(\"\\n\"); for (int j = 1; j &lt;= add; ++j) printf(\"%d %d\\n\", q[j].pos, q[j].diff);*/ nextB[i] = q[1].pos; if (add == 1) return; nextA[i] = q[2].pos;&#125;inline void prepare() &#123; for (int i = n; i &gt;= 1; --i) &#123; s.insert(a[i]); if (i ^ n) find(i); // i ^ n means when i = 1 ~ n - 1 we can find the minDis and second minDis; &#125;/* printf(\"\\n\"); for (int i = 1; i &lt;= n; ++i) printf(\"%d %d\\n\", nextA[i], nextB[i]); printf(\"\\n\");*/ for (int i = 1; i &lt;= n; ++ i) &#123; int pos1 = nextA[i], pos2 = nextB[nextA[i]]; fa[i][0] = pos2; // disA[i][0] = pos1 ? abs(a[pos1].high - a[i].high) : 0; disB[i][0] = pos2 ? abs(a[pos2].high - a[pos1].high) : 0; &#125; for (int j = 1; j &lt; MAX_LOG_N; ++ j) &#123; for (int i = 1; i &lt;= n; ++ i) &#123; fa[i][j] = fa[fa[i][j - 1]][j - 1]; // disA[i][j] = disA[i][j - 1] + disA[fa[i][j - 1]][j - 1]; disB[i][j] = disB[i][j - 1] + disB[fa[i][j - 1]][j - 1]; // printf(\"%d %lld %lld\\n\", fa[i][j], disA[i][j], disB[i][j]); &#125;// printf(\"\\n\"); &#125;&#125;inline void query(int x, int lim, long long &amp;sumA, long long &amp;sumB) &#123; for (int i = 19; ~i; -- i) if (fa[x][i] &amp;&amp; disA[x][i] + disB[x][i] &lt;= lim) &#123; sumA += disA[x][i]; sumB += disB[x][i]; lim -= disA[x][i] + disB[x][i]; x = fa[x][i]; &#125; int posA = nextA[x]; if (!posA) return; int dis = abs(a[posA].high - a[x].high); if (dis &lt;= lim) sumA += dis; //&#125;inline void solve1() &#123; int pos = 0; long long ansA = 1e15, ansB = 0ll; for (int i = 1; i &lt;= n; ++ i) &#123; long long sumA = 0ll, sumB = 0ll; query(i, X0, sumA, sumB); if (sumB &amp;&amp; (!pos || ansA * sumB &gt; ansB * sumA)) &#123; ansA = sumA; ansB = sumB; pos = i; &#125; &#125; printf(\"%d\\n\", pos);&#125;int main()&#123; n = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++ i) &#123; a[i].high = readIn&lt;int&gt;(), a[i].pos = i; &#125; X0 = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 1; i &lt;= m; ++i) S[i] = readIn&lt;int&gt;(), X[i] = readIn&lt;int&gt;(); prepare(); solve1(); for (int i = 1; i &lt;= m; ++i) &#123; ll sumA = 0ll, sumB = 0ll; query(S[i], X[i], sumA, sumB); printf(\"%lld %lld\\n\", sumA, sumB); &#125; return 0;&#125; Day 2同余方程描述关于 $x$ 的同余方程 $ax \\equiv 1 \\pmod b$ 的最小正整数解。 $2 \\leq a, b, \\leq 2 \\times 10^{9}$ 分析求 $ax \\equiv 1 \\pmod b$ 的最小正整数解，不妨将式子变一下形： \\because ax \\equiv 1 \\pmod b \\\\ \\therefore ax = by + 1\\\\ \\therefore ax - by = 1那么我们需要求得就是满足 $ax - by = 1$ 最小的 $x$ 的值。 这里我们用到扩展欧几里德来求解，稍微回忆一下 exgcd 吧！ 求满足 $ax + by = gcd(a, b)$ 的一组解 $x, y$ 。 因为在欧几里得定理中 $b \\neq 0 \\Rightarrow gcd(a, b) = gcd(b, a \\pmod b)$ 又因为 $bx’ + (a \\pmod b)y’ = gcd(b, a \\pmod b)$ 所以 $ax + by = bx’ + (a \\pmod b)y’ = bx’ + (a - b \\left \\lfloor \\frac{a}{b} \\right \\rfloor )y’$ 将式子变形： $ax + by = ay’ + b(x’ - \\left \\lfloor \\frac{a}{b} \\right \\rfloor y’)$ 很明显有一组通解： $x = y’, y = x’ - \\left \\lfloor \\frac{a}{b} \\right \\rfloor y’ $ 然后我们可以递归求得 $x, y$ ，注意：当 $b = 0$ 时， $x = 1, y = 0$ 。 其实当 $gcd \\nmid 1$ ，方程此时无解，但是这里保证方程有解就不用判断这种情况了。 我们用 exgcd 求出的解并不一定是最小解，所以输出的时候要对 $b$ 取模。如果出现负数解，先加一个 $b$，再对 $b$ 取模即可。 代码1234567891011121314151617181920212223242526272829303132333435// Created by ZJYelizaveta on Wednesday, October 25, 2017 PM12:10:00 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;ll a, b;inline void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) &#123;x = 1, y = 0;&#125; else &#123; exgcd(b, a % b, y, x); y -= (a / b) * x; &#125;&#125;int main()&#123; a = readIn&lt;ll&gt;(), b = readIn&lt;ll&gt;(); ll x = 0, y = 0; exgcd(a, b, x, y); printf(\"%lld\\n\", (x + b) % b); return 0;&#125; 借教室描述在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。面对海量租借教室的信息，我们自然希望编程解决这个问题。我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_{i}$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_{j} , s_{j} , t_{j}$ ，表示某租借者需要从第 $s_{j}$ 天到第 $t_{j}$ 天租借教室（包括第 $s_{j}$ 天和第 $t_{j}$ 天），每天需要租借 $d_{j}$ 个教室。我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供$d_{j}$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_{j}$ 天到第 $t_{j}$ 天中有至少一天剩余的教室数量不足 $d_{j}$ 个。现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。 $1 \\leq n, m \\leq 10^{6} , 0 \\leq r_{i} , d_{j} \\leq 10^{9} , 1 \\leq s_{j} \\leq t_{j} \\leq n$ 分析暴力模拟 40 分。 很明显的区间修改和区间查询，开始准备 树状数组 + 差分 来解决，结果发现最差的时间复杂度为 $\\Theta(mnlogn)$ ，不会进一步优化，遂放弃以这种思路刚正解。 换一个思路吧！“借教室的原则是先到先得” 也就是说， $m$ 个人借教室这个序列是有序的，有序的我们就可以二分来解决。 二分，我们 check 的时间复杂度为 $\\Theta(nm)$ ，需要优化。想到前面 NOIP 2011 聪明的质监员，我们可以用前缀和来优化，从而优化掉一个 $n$ ，由 $\\Theta(nm) \\rightarrow \\Theta(m)$ 。 这里我们不只是简单的前缀和优化，因为我们需要支持区间修改和区间 check ，因此我们需要把前缀和差分一下，使得做完前缀和之后每一位表示的是这一天需要借出的教室总数。 具体操作如图所示： 总时间复杂度 $\\Theta((m + 2n)logm)$ 。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Created by ZJYelizaveta on Thursday, October 26, 2017 AM11:17:07 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000000 + 3;const int INF = 0x3f3f3f3f;int n, m;int r[MAX_N];struct Note &#123; int d, s, t;&#125;a[MAX_N];int sum[MAX_N];inline bool check(int x) &#123; memset(sum, 0, sizeof sum); for (int i = 1; i &lt;= x; ++i) &#123; sum[a[i].s] += a[i].d; sum[a[i].t + 1] -= a[i].d; &#125;// for (int i = 1; i &lt;= n; ++i) printf(\"%d \", sum[i]); printf(\"\\n\"); for (int i = 1; i &lt;= n; ++i) sum[i] += sum[i - 1];// for (int i = 1; i &lt;= n; ++i) printf(\"%d \", sum[i]); printf(\"\\n\"); for (int i = 1; i &lt;= n; ++i) if (sum[i] &gt; r[i]) return true; return false;&#125;inline void solve() &#123; int l = 1, r = m, ans = 0; while (r - l &gt; 0) &#123; int mid = (l + r) &gt;&gt; 1;// printf(\"\\n%d %d %d\\n\\n\", l, r, mid); if (check(mid)) r = mid, ans = mid; else l = mid + 1; &#125; if (r == m) printf(\"0\\n\"); else printf(\"-1\\n%d\\n\", ans);&#125;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) r[i] = readIn&lt;int&gt;(); for (int i = 1; i &lt;= m; ++i) a[i].d = readIn&lt;int&gt;(), a[i].s = readIn&lt;int&gt;(), a[i].t = readIn&lt;int&gt;(); solve(); return 0;&#125; 疫情控制描述H 国有 $n$ 个城市，这 $n$ 个城市用 $n-1$ 条双向道路相互连通构成一棵树，$1$ 号城市是首都，也是树中的根节点。H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。 $2 \\leq m \\leq n \\leq 50,000,0&lt;w &lt;10^{9}$ 分析首先我们有一个贪心的结论：选择的检查点肯定越靠近根越优，因为这样可以尽可能多的覆盖到一些节点。 这样一来我们就要贪心让军队尽可能往根节点走。 又因为 “不同的军队可以同时移动” ，也就是说我们所求的是所有的军队到达相应地点中耗时最长的军队花费的时间，而我们要最小化这个时间。也就是我们要最小化时间的最大值，这是一个二分的套路，所以我们可以每次二分一个人时间 $mid$ 然后 check 一下。 现在问题在于如何以比较优的时间复杂度实现 check 这个函数。 我们让军队往根节点跳，根据套路，可以用倍增来优化。 军队往上跳最后有两种情况： 军队到达不了根节点，那么就在这支军队能到达的最靠近的根节点位置的节点上打一个标记。 如果这只军队能够到达根节点，那么记录一下它的编号以及它到达根节点后还可以走的时间 $last_{i}$ 以及这只军队的起始节点所属根节点的哪棵子树 $a_{i}$ 。 军队跳完以后，查找所有根节点到其的路径中没有设置检查点的子树（如果一个结点 $u$ 设置了观察节点就意味着节点 $u$ 及其在所有的子树都设立了观察结点）。这个部分我们可以用树形动规求出来。 现在找出了所有没有设立观察节点的子树，但是现在就 check 完了吗，没有呀！我们还有到达根节点后仍然可以移动的军队，现在是这些军队做贡献的时候了。 将记录了的可以到达根节点的军队按照 $last_{i}$ 从大到小排序，将刚刚找出未设立观察点的子树按照子树到根节点的距离从大到小排序。一次处理每一棵子树需要那一支军队来管辖。 这里我们仍然需要运用贪心的思想：这里离根节点距离最远的子树用 $last_{i}$ 最大的来管辖这是一个比较直接的想法。但是若这棵子树 $u$ 原本有一支可以到达根节点但是不够走回军队起始点的军队（即存在根节点的子树 $x$ 中且 $last_{i}$ 最小的结点），那么我们不妨就将这支军队放在结点 $u$ ，这样一来就不用浪费更大的 $last_{i}$ 了。若不存在这样的军队，那么还是用一开始最直接的贪心想法来判断。 NOIP 2012 Day2 居然考了两次二分；两天考了两次倍增预处理？？？ 这样一来我们的总时间复杂度为 $\\Theta(logn(mlogn))$ 。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179// Created by ZJYelizaveta on Tuesday, October 31, 2017 AM08:59:35 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 50000 + 3;const int INF = INT_MAX;const int MAX_LOG_N = 15 + 3;const ll INFLL = 0x3f3f3f3f3f3f3f3fll;int n, m;struct Edge &#123; int to, next; ll w;&#125;edge[MAX_N &lt;&lt; 1];int head[MAX_N], cnt = 0;int army[MAX_N];inline void addEdge(int from, int to, ll w) &#123; edge[++cnt].to = to; edge[cnt].w = w; edge[cnt].next = head[from]; head[from] = cnt; edge[++cnt].to = from; edge[cnt].w = w; edge[cnt].next = head[to]; head[to] = cnt;&#125;int fa[MAX_N][MAX_LOG_N];ll dis[MAX_N][MAX_LOG_N];inline void dfs(int u, int f, ll w) &#123; fa[u][0] = f; dis[u][0] = w; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (v == f) continue; dfs(v, u, edge[i].w); &#125;&#125;inline void prepare() &#123; dfs(1, 0, 0); for (int j = 1; j &lt; MAX_LOG_N; ++j) &#123; for (int i = 1; i &lt;= n; ++i) &#123; fa[i][j] = fa[fa[i][j - 1]][j - 1]; dis[i][j] = dis[i][j - 1] + dis[fa[i][j - 1]][j - 1]; &#125; &#125;/* for (int j = 0; j &lt; MAX_LOG_N; ++j) &#123; for (int i = 1; i &lt;= n; ++i) &#123; printf(\"%d %d %d %lld\\n\", i, j, fa[i][j], dis[i][j]); &#125; printf(\"\\n\"); &#125;*/&#125;int vis[MAX_N], used[MAX_N], pos[MAX_N];ll restMin[MAX_N];struct Military &#123; int id; ll rest; bool operator &lt; (const Military &amp;rhs) const &#123; return rest &gt; rhs.rest; &#125;&#125;a[MAX_N], b[MAX_N]; // a -&gt; the military that can reach the root, the tree that cannot be coveredint numA, numB;inline int find(int u , int f) &#123; // check the tree can be covered or not bool flag1 = true, flag2 = false; if (vis[u]) return 1; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (v == f) continue; flag2 = true; if (!find(edge[i].to, u)) &#123; flag1 = false; if (u == 1) b[++numB].id = edge[i].to, b[numB].rest = edge[i].w; else return 0; &#125; &#125; if (!flag2) return 0; return flag1;&#125;inline bool check(ll lim) &#123; numA = 0, numB = 0; memset(vis, 0, sizeof vis); memset(pos, 0, sizeof pos); memset(used, 0, sizeof used); for (int i = 1; i &lt;= m; ++i) &#123;// printf(\"%lld\\n\", lim); int x = army[i]; ll depth = 0; for (int j = MAX_LOG_N - 1; j &gt;= 0; --j) &#123; if (fa[x][j] &gt; 1 &amp;&amp; depth + dis[x][j] &lt;= lim) &#123; depth += dis[x][j]; x = fa[x][j]; &#125; &#125;// printf(\"%d %lld %lld\\n\", fa[x][0], lim - depth - dis[x][0], lim); if (fa[x][0] == 1 &amp;&amp; depth + dis[x][0] &lt;= lim) &#123; // can reach the root a[++numA].id = i; a[numA].rest = lim - depth - dis[x][0];// printf(\"%d %lld\\n\", a[numA].id, a[numA].rest); if (!pos[x] || a[numA].rest &lt; restMin[x]) &#123; pos[x] = i; restMin[x] = a[numA].rest; &#125; &#125; else vis[x] = true; // cannot reach the root &#125;// for (int i = 1; i &lt;= n; ++i) printf(\"%d \", vis[i]); printf(\"\\n\"); if (find(1, 0)) return true; // already cover the tree, make r = mid, trie to narrow the range sort(a + 1, a + numA + 1); sort(b + 1, b + numB + 1);/* for (int i = 1; i &lt;= numA; ++i) printf(\"%d %lld\\n\", a[i].id, a[i].rest); for (int i = 1; i &lt;= numB; ++i) printf(\"%d %lld\\n\", b[i].id, b[i].rest);*/// printf(\"%d %d\\n\", numA, numB); used[0] = 1; int cur = 1; for (int i = 1; i &lt;= numB; ++i) &#123; if (!used[pos[b[i].id]]) &#123; used[pos[b[i].id]] = 1; continue; &#125; while (cur &lt;= numA &amp;&amp; (used[a[cur].id] || a[cur].rest &lt; b[i].rest)) ++cur; if (cur &gt; numA) return false; // nothing can cover this tree used[a[cur].id] = 1; &#125; return true;&#125;inline void solve() &#123; ll l = 0, r = INF, ans = -1;/* if (check(2)) printf(\"qwq\\n\"); else printf(\"Naive\\n\");*/ while (l &lt;= r) &#123; ll mid = (l + r) &gt;&gt; 1;// printf(\"%lld\\n\", mid); if (check(mid)) r = mid - 1, ans = mid; // return true; else l = mid + 1; &#125; printf(\"%lld\\n\", ans);&#125;int main()&#123; n = readIn&lt;int&gt;(); memset(head, -1, sizeof head); for (int i = 1; i &lt; n; ++i) &#123; int u = readIn&lt;int&gt;(), v = readIn&lt;int&gt;(); ll w = readIn&lt;ll&gt;(); addEdge(u, v, w); &#125; m = readIn&lt;int&gt;(); for (int i = 1; i &lt;= m; ++i) army[i] = readIn&lt;int&gt;(); prepare(); solve(); return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"},{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/二分/"},{"name":"差分","slug":"差分","permalink":"http://yoursite.com/tags/差分/"},{"name":"倍增","slug":"倍增","permalink":"http://yoursite.com/tags/倍增/"},{"name":"高精度","slug":"高精度","permalink":"http://yoursite.com/tags/高精度/"},{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"},{"name":"gcd及exgcd","slug":"gcd及exgcd","permalink":"http://yoursite.com/tags/gcd及exgcd/"}]},{"title":"BZOJ 1588: [HNOI2002]营业额统计","slug":"BZOJ-1588-HNOI2002-营业额统计","date":"2017-10-27T15:50:12.000Z","updated":"2017-10-27T16:00:25.246Z","comments":true,"path":"2017/10/27/BZOJ-1588-HNOI2002-营业额统计/","link":"","permalink":"http://yoursite.com/2017/10/27/BZOJ-1588-HNOI2002-营业额统计/","excerpt":"描述题面比较长，简化一下就是这样：给出一个长为 $n$ 序列，对于每一个数 $a_{i}$，找出之前与它相差最小的数，两者相减取绝对值加入答案。 序列长度 $n\\leq 32767, a_{i} \\leq 10^{6}$","text":"描述题面比较长，简化一下就是这样：给出一个长为 $n$ 序列，对于每一个数 $a_{i}$，找出之前与它相差最小的数，两者相减取绝对值加入答案。 序列长度 $n\\leq 32767, a_{i} \\leq 10^{6}$ 分析我们可以用 Splay 来实现，时间复杂度 $\\Theta(nlog_{2}n)$ 。 这里考虑如何用更基础的数据结构来实现。 将 $n$ 个元素从小到大排序得到序列 $c[]$ ，用 $rank[]$ 数组记录原来的第 $i$ 个元素在排序之后的位置。 将排序后的序列在数组中建成一个双向链表。然后从 $n \\rightarrow 1$ 依次计算贡献。 对于 $a[i]$ ，查看 $rank[i]$ 的前驱 $pre[rank[i]]$ 和其后继 $nxt[rank[i]]$ 所指向的数。 最小的波动必然是 $a[i]$ 与 $a[pre[i]]$ 之间或是 $a[i]$ 与 $a[nxt[i]]$ 之间的绝对值。 处理完 $a[i]$ 之后我们把 $a[i]$ 从双向链表中删除，然后处理 $a[i - 1]$ 。 这么说，可能不是很容易懂。举一个例子来看看吧： - 1 2 3 4 $a[]$ 9 3 7 5 $b[]$ 3 5 7 9 - 1 2 3 4 $rank[]$ 2 4 3 1 从 $5$ 开始 且 $i = 4$ ，$pre[i] = 2, nxt[i] = 3$ ，那么这个点的贡献 $Add_{i} = min(\\left | a_{4} - a_{2} \\right |,\\left | a_{4} - a_{3} \\right | ) = 2$ 。在序列 $b[]$ 中删除 $a_{4}$ 。 然后是 $7$ 且$i = 3$ ，$pre[i] = 2, nxt[i] = 1$ ，那么这个点的贡献为 $Add_{i} = min(\\left | a_{3} - a_{2} \\right |,\\left | a_{1} - a_{3} \\right | ) = 2$ ，在序列 $b[]$ 中删除 $a_{3}$ 。 恩，就酱。时间复杂度依然是 $\\Theta(nlog_{2}n)$ 。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Created by ZJYelizaveta on Thursday, October 26, 2017 PM04:31:33 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 32767 + 3;const int INF = 0x3f3f3f3f;int n;int val[MAX_N];int pre[MAX_N], nxt[MAX_N], rank[MAX_N];inline bool cmp(int i, int j) &#123; return val[i] &lt; val[j];&#125;int main()&#123; n = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) &#123; val[i] = readIn&lt;int&gt;(); rank[i] = i; &#125; sort(rank + 1, rank + n + 1, cmp);/* for (int i = 1; i &lt;= n; ++i) printf(\"%d \", i); printf(\"\\n\"); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", val[i]); printf(\"\\n\"); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", val[rank[i]]); printf(\"\\n\"); for (int i = 1; i &lt;= n; ++i) printf(\"%d \", rank[i]); printf(\"\\n\");*/ for (int i = 1; i &lt;= n; ++i) &#123; pre[rank[i]] = rank[i - 1]; nxt[rank[i]] = rank[i + 1]; &#125; int ans = val[1]; for (int i = n; i &gt;= 2; --i) &#123; int l = INT_MAX, r = INT_MAX; if (pre[i] != 0) l = val[i] - val[pre[i]]; if (nxt[i] != 0) r = val[nxt[i]] - val[i]; ans += min(l, r); nxt[pre[i]] = nxt[i]; pre[nxt[i]] = pre[i]; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"双向链表","slug":"双向链表","permalink":"http://yoursite.com/tags/双向链表/"}]},{"title":"高精度加、减、乘、除模板","slug":"高精度加、减、乘、除模板","date":"2017-10-25T05:17:15.000Z","updated":"2017-10-25T05:20:47.882Z","comments":true,"path":"2017/10/25/高精度加、减、乘、除模板/","link":"","permalink":"http://yoursite.com/2017/10/25/高精度加、减、乘、除模板/","excerpt":"描述高精度的加、减、乘、除模板。","text":"描述高精度的加、减、乘、除模板。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189// Created by ZJYelizaveta on Wednesday, October 25, 2017 PM03:14:56 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int INF = 0x3f3f3f3f;struct BigInt &#123; vector&lt;int&gt; v; static const int BASE = 10; BigInt(ll x) &#123; do &#123; v.push_back(x % 10); &#125; while (x /= 10); &#125; BigInt(const string &amp;str) &#123; v.reserve(str.length()); for (int i = str.length() - 1; i &gt;= 0; i--) &#123; v.push_back(str[i] - '0'); &#125; &#125; BigInt() &#123;&#125; void removePreZero() &#123; while(v.size() &gt;= 1 &amp;&amp; v.back() == 0) v.pop_back(); &#125; bool operator&lt;(const BigInt &amp;a) const &#123; if (v.size() != a.v.size()) &#123; return v.size() &lt; a.v.size(); &#125; for (int i = v.size() - 1; i &gt;= 0; i--) &#123; if (v[i] != a.v[i]) &#123; return v[i] &lt; a.v[i]; &#125; &#125; return false; &#125; bool operator&gt;(const BigInt &amp;a) const &#123; return a &lt; *this; &#125; bool operator&lt;=(const BigInt &amp;a) const &#123; return !(a &lt; *this); &#125; bool operator&gt;=(const BigInt &amp;a) const &#123; return !(*this &lt; a); &#125; bool operator!=(const BigInt &amp;a) const &#123; return a &lt; *this || a &gt; *this; &#125; bool operator==(const BigInt &amp;a) const &#123; return !(a &lt; *this) &amp;&amp; !(a &gt; *this); &#125; BigInt operator+(const BigInt &amp;a) const &#123; BigInt res; int sum = 0; for (int i = 0; i &lt; max(a.v.size(), v.size()); i++) &#123; if (i &lt; a.v.size()) sum += a.v[i]; if (i &lt; v.size()) sum += v[i]; res.v.push_back(sum % BASE); sum /= BASE; &#125; if (sum) res.v.push_back(sum); res.removePreZero(); return res; &#125; BigInt operator-(const BigInt &amp;a) const &#123; BigInt res; int dif = 0; for (int i = 0; i &lt; max(a.v.size(), v.size()); i++) &#123; if (i &lt; v.size()) dif += v[i]; if (i &lt; a.v.size()) dif -= a.v[i]; if (dif &gt;= 0) &#123; res.v.push_back(dif); dif = 0; &#125; else &#123; res.v.push_back((dif + BASE) % BASE); dif = -1; &#125; &#125; res.removePreZero(); return res; &#125; BigInt operator*(const BigInt &amp;a) const &#123; BigInt res; res.v.resize(v.size() + a.v.size(), 0); for (int i = 0; i &lt; v.size(); i++) &#123; for (int j = 0; j &lt; a.v.size(); j++) &#123; res.v[i + j] += v[i] * a.v[j]; res.v[i + j + 1] += res.v[i + j] / BASE; res.v[i + j] %= BASE; &#125; &#125; res.removePreZero(); return res; &#125; BigInt operator/(const BigInt &amp;a) const &#123; BigInt res, ret(0); res.v.resize(v.size(), 0); ret = 0; for (int i = v.size() - 1; i &gt;= 0; i--) &#123; ret = ret * 10 + v[i]; while (ret &gt;= a) &#123; ret = ret - a; res.v[i]++; &#125; &#125; res.removePreZero(); return res; &#125;&#125;;ostream&amp; operator&lt;&lt;(ostream &amp;out, const BigInt &amp;x) &#123; for (int i = x.v.size() - 1; i &gt;= 0; i--) &#123; out &lt;&lt; x.v[i]; &#125; return out;&#125;istream&amp; operator&gt;&gt;(istream &amp;in, BigInt &amp;x) &#123; string str; in &gt;&gt; str; x = BigInt(str); return in;&#125;int main()&#123; BigInt a, b; cin &gt;&gt; a &gt;&gt; b;// 加 BigInt c = a + b; cout &lt;&lt; c &lt;&lt; endl;// 减 BigInt c; bool flag = false; if (a &lt; b) &#123; flag = true; c = a; a = b; b = c; &#125;// cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; endl; BigInt ans = a - b; if (a == b) cout &lt;&lt; 0 &lt;&lt; endl; else if (flag) cout &lt;&lt; '-' &lt;&lt; ans &lt;&lt; endl; else cout &lt;&lt; ans &lt;&lt; endl;// 乘 BigInt ans = a * b; cout &lt;&lt; ans &lt;&lt; endl;// 除 BigInt ans = a / b; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"高精度","slug":"高精度","permalink":"http://yoursite.com/tags/高精度/"}]},{"title":"NOIP 2013 整理","slug":"NOIP-2013-整理","date":"2017-10-25T05:03:41.000Z","updated":"2017-10-25T05:09:56.549Z","comments":true,"path":"2017/10/25/NOIP-2013-整理/","link":"","permalink":"http://yoursite.com/2017/10/25/NOIP-2013-整理/","excerpt":"Day 1转圈游戏描述$n$ 个小伙伴围成一个圈（编号从 $0 \\sim 1$），按照顺时针方向给 $n$ 个位置标号，每次每个人向后移动 $m$ 个位置，问操作 $10^{k}$ 次的时候，第 $x$ 号小伙伴走到了第几号位置？$1 &lt; n &lt; 10^{6}, 0 &lt; m &lt; n, 1 \\leq x \\leq n, 0 &lt; k &lt; 10^{9}$","text":"Day 1转圈游戏描述$n$ 个小伙伴围成一个圈（编号从 $0 \\sim 1$），按照顺时针方向给 $n$ 个位置标号，每次每个人向后移动 $m$ 个位置，问操作 $10^{k}$ 次的时候，第 $x$ 号小伙伴走到了第几号位置？$1 &lt; n &lt; 10^{6}, 0 &lt; m &lt; n, 1 \\leq x \\leq n, 0 &lt; k &lt; 10^{9}$ 分析我们可以用式子表示出 $x$ 号小朋友最后的位置： x = (x + m \\times 10^{k}) \\% n我们可以将式子恒等变形一下，变成一个比较容易求的形式： x = (x + m \\times (10^{k}\\ \\% \\ n) \\ \\% \\ n) \\ \\% \\ n这样一来式子的关键就变成了做快速幂的时候顺便取模。 mdzz，第一次好把快速幂写错了qwq 代码12345678910111213141516171819202122232425262728293031323334353637383940// Created by ZJYelizaveta on Tuesday, October 17, 2017 AM08:58:17 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000000 + 3;const int INF = 0x3f3f3f3f;ll n, m, k, x;inline ll quickPow(ll a, ll b) &#123; ll res = 1; // while (b) &#123; if (b &amp; 1) (res *= a) %= n; (a *= a) %= n; b &gt;&gt;= 1; &#125; return res;&#125;int main()&#123; n = readIn&lt;ll&gt;(), m = readIn&lt;ll&gt;(), k = readIn&lt;ll&gt;(), x = readIn&lt;ll&gt;(); ll temp = quickPow(10, k); x = (x + m * quickPow(10, k) % n + n) % n; printf(\"%lld\\n\", x); return 0;&#125; 火柴排队描述有两个长为 $n$ 的序列 $a, b$，定义两个序列的距离为 \\sum_{i = 1}^{n} \\left ( a_{i} - b_{i}\\right )^{2}每个序列中相邻两个位置的数可以交换，问最少需要交换多少次，可以最小化这个式子？答案对 $99999997$ 取模。$1 \\leq n \\leq 10^{5}, 0 \\leq $ 火柴高度 $\\leq 2^{31} - 1$ 分析我们需要最小化 $\\sum_{i = 1}^{n}(a_{i} - b_{i})^{2}$，相当于要最小化 $(a_{i} - b_{i})$，也就是说 $a$ 序列第 $k$ 大的元素必须和序列 $b$ 中第 $k$ 大的元素（$k \\in [1, n]$）的位置必须一样。 可以这样来理解：$A$ : $1$ $998$ $2$ $87$ $3$ $3$$B$ : $1$ $6$ $2$ $5$ $3$ $4$ 那么我们我们可以把 $a, b$ 先离散化，那么问题将转化为 $b$ 序列要交换几次可以令其等于 $a$，但是我们还是没有一个具体成形的算法。 好了，这道题目的精华在于对于新建序列！假设我们现在有离散化后的序列 $a = \\{4, 3, 1, 2\\}$，$b = \\{1, 3, 2, 4\\}$。 我们令 $q[a[i]] = b[i]$，相当于以 $a[i]$ 为关键字对序列 $b[i]$ 排序。 若序列 $a$ 与序列 $b$ 相等，那么此时 $q[a[i]]$ 应该等于 $a[i]$ 的，也就是 $q[i] = i$。 那么也就是说如果我们想让序列 $a$ 与序列 $b$ 相等，那么我们需要让 $q$ 升序排列。 问题就变为，将原本乱的 $q$ 序列升序排列的最少交换次数。 诶，这不就是逆序对吗？ 于是，用树状数组求之即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// Created by ZJYelizaveta on Tuesday, October 17, 2017 AM09:22:55 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100000 + 3;const int MOD = 99999997;const int INF = 0x3f3f3f3f;int n;int a[MAX_N], b[MAX_N];int c[MAX_N], d[MAX_N];int q[MAX_N];int ans;namespace fenwickTree &#123; int vec[MAX_N]; inline int lowbit(int x) &#123; return x &amp; (-x); &#125; inline void modify(int id, int x) &#123; while (id &lt;= n) &#123; vec[id] += x; id += lowbit(id); &#125; &#125; inline int query(int id) &#123; int res = 0; while (id &gt;= 1) &#123; res += vec[id]; id -= lowbit(id); &#125; return res; &#125;&#125;using namespace fenwickTree;// 60%/*inline void solve() &#123; ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = i + 1; j &lt;= n; ++j) if (i &lt; j &amp;&amp; q[i] &gt; q[j]) &#123; swap(q[i], q[j]); ++ans; &#125; &#125; printf(\"%d\\n\", (ans % MOD + MOD) % MOD);&#125;*/// 100%inline void solve() &#123; ans = 0; for (int i = n; i &gt;= 1; --i) &#123;// printf(\"%d %d\\n\", q[i], query(q[i] - 1)); ans += query(q[i] - 1); modify(q[i], 1); if (ans &gt;= MOD) ans -= MOD; &#125; printf(\"%d\\n\", (ans % MOD + MOD) % MOD);&#125;inline bool cmp1(int i, int j) &#123; return a[i] &lt; a[j];&#125;inline bool cmp2(int i, int j) &#123; return b[i] &lt; b[j];&#125;int main()&#123; n = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) a[i] = readIn&lt;int&gt;(), c[i] = i; for (int i = 1; i &lt;= n; ++i) b[i] = readIn&lt;int&gt;(), d[i] = i; sort(c + 1, c + n + 1, cmp1); sort(d + 1, d + n + 1, cmp2);// for (int i = 1; i &lt;= n; ++i) printf(\"%d \", c[i]); printf(\"\\n\");// for (int i = 1; i &lt;= n; ++i) printf(\"%d \", d[i]); printf(\"\\n\"); memset(q, 0, sizeof q); for (int i = 1; i &lt;= n; ++i) q[c[i]] = d[i];// for (int i = 1; i &lt;= n; ++i) printf(\"%d \", q[i]); printf(\"\\n\"); solve(); return 0;&#125; 货车运输描述A 国有 $n$ 座城市编号，从 $1$ 到 $n$，城市之间有 $m$ 条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有 $q$ 辆货车在运输货物，司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。 $0 &lt; n &lt; 10^{4}, 0 &lt; m &lt; 5 \\times 10^{4}, 0 &lt; q &lt; 3 \\times 10^{4}, 0 \\leq z \\leq 10^{5}$ 分析模拟的时候做到这道题目之剩下 1.5h，有点慌，看到这道题目的时候，诶，不就是最大生成树重构图，然后在树上询问吗qwq 这道题目实际上是最大化两点之间的最小瓶颈路，而这种路径一定存在于最大生成树中。考试的时候没有仔细想，这里简要证明一下。 证明这里我们简称最大化最小瓶颈路为最大瓶颈路。 假设两点 $u, v$ 之间的最大瓶颈路不在最大生成树中。 那么我们将这条路径加入最大生成树中，此时的树中必定存在一个环，我们可以删除环上权值最小的一条边使之又成为一棵树，那么现在的生成树的权值一定大于之前的最大生成树的权值，这与我们之前定义的矛盾。 故，任意两点之间的最大瓶颈路在最大生成树中，证毕。 我们用 Kruskal 重构图，在 $\\Theta(n + mlogm)$ 的时间内建出这个图的最大生成树。 然后我们可以在树上询问，但是如果每次询问都 dfs，这样的时间复杂度是平方级别的。怎样来优化时间复杂度呢？ 考虑先预处理处每一个点的 depth[]，任意两点之间的 minVal[][] ,fa[][]，然后在求两点 LCA 倍增往上跳的时候顺便计算一下两点之间的最小权值即为答案。 P.S. 在求两地之间的 LCA 并计算两点之间的最小权值，注意一定要先取最小值再往上跳，因为这里的意义是 以这个点 $u, v$ 向上跳 $2^{i}$ 的最小值，如果先跳的话当然会 WA 呀qwq 在这里调了 20 多分钟的 zz 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// Created by ZJYelizaveta on 2017年10月18日 星期三 18时19分28秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int MAX_M = 50000 + 3;const int MAX_LOG_N = 12 + 3;const int MAX_Q = 30000 + 3;const int INF = 0x3f3f3f3f;int n, m, q;struct Edge &#123; int to, cost; Edge (int to, int cost) : to(to), cost(cost)&#123;&#125; //&#125;;vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1];int depth[MAX_N];int fa[MAX_N][MAX_LOG_N], minVal[MAX_N][MAX_LOG_N];int p[MAX_N], c[MAX_N]; // each point's father, and it father's costnamespace LCA &#123; inline void addEdge(int from, int to, int cost) &#123; G[from].push_back(Edge(to, cost)); G[to].push_back(Edge(from, cost)); &#125; inline void dfs(int u, int par) &#123; depth[u] = depth[par] + 1; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.to == par) continue; p[e.to] = u; c[e.to] = e.cost;// printf(\"%d %d %d\\n\", u, e.to, e.cost); dfs(e.to, u); &#125; &#125; inline void prepare() &#123; for (int i = 1; i &lt;= n; ++i) &#123; fa[i][0] = p[i], minVal[i][0] = c[i];// printf(\"%d %d %d\\n\", i, p[i], c[i]); for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) fa[i][j] = -1; &#125; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) &#123; for (int i = 1; i &lt;= n; ++i) &#123; if (fa[i][j - 1] != -1) &#123; fa[i][j] = fa[fa[i][j - 1]][j - 1]; minVal[i][j] = min(minVal[i][j - 1], minVal[fa[i][j - 1]][j - 1]);// printf(\"%d %d %d %d\\n\", i, j, fa[i][j], minVal[i][j]); &#125; &#125; &#125; &#125; inline int lca(int a, int b) &#123; if (depth[a] &lt; depth[b]) swap(a, b); // a must be deeper than b int lim; for (lim = 1; (1 &lt;&lt; lim) &lt;= n; ++lim); --lim; int ans = INF; for (int i = lim; i &gt;= 0; --i) &#123; if (depth[a] - (1 &lt;&lt; i) &gt;= depth[b]) &#123; ans = min(ans, minVal[a][i]); a = fa[a][i];// printf(\"%d %d %d %d %d\\n\", i, a, b, minVal[a][i], ans); &#125; &#125; if (a == b) return ans; for (int i = lim; i &gt;= 0; --i) &#123; if (fa[a][i] != -1 &amp;&amp; fa[a][i] != fa[b][i]) &#123; ans = min(ans, min(minVal[a][i], minVal[b][i])); // a = fa[a][i], b = fa[b][i]; // &#125; &#125; ans = min(ans, min(c[a], c[b])); return ans; &#125;&#125;using namespace LCA;struct Tree &#123; int u, v, w; bool operator &lt; (const Tree &amp;rhs) const &#123; return w &gt; rhs.w; &#125;&#125;t[MAX_M];int f[MAX_N];namespace Kruskal &#123; inline int find(int x) &#123; return f[x] == x ? x : f[x] = find(f[x]); &#125; inline void kruskal() &#123; sort(t + 1, t + m + 1);// for (int i = 1; i &lt;= m; ++i) printf(\"%d %d %d\\n\", t[i].u, t[i].v, t[i].w); for (int i = 1; i &lt;= n; ++i) f[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int x = find(t[i].u), y = find(t[i].v);// printf(\"%d %d %d %d\\n\", t[i].u, t[i].v, x, y); if (x != y) &#123; f[y] = x; //// printf(\"%d %d %d\\n\", t[i].u, t[i].v, t[i].w); addEdge(t[i].u, t[i].v, t[i].w); &#125; &#125; &#125;&#125;using namespace Kruskal;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 1; i &lt;= m; ++i) &#123; t[i].u = readIn&lt;int&gt;(), t[i].v = readIn&lt;int&gt;(), t[i].w = readIn&lt;int&gt;(); &#125; kruskal(); dfs(1, 0); prepare(); q = readIn&lt;int&gt;(); while (q--) &#123; int a = readIn&lt;int&gt;(), b = readIn&lt;int&gt;(); int x = find(a), y = find(b); if (x != y) printf(\"-1\\n\"); else printf(\"%d\\n\", lca(a, b)); &#125; return 0;&#125; Day 2积木大赛描述今年比赛的内容是搭建一座宽度为 $n$ 的大厦，大厦可以看成由 $n$ 块宽度为 $1$ 的积木组成，第 $i$ 块积木的最终高度需要是 $h_{i} 。每次可以选择一个区间 $[L, R]$ 将区间内积木的高度都增加 $1$。问最少需要操作多少次，可以搭建出这座大厦？ $1 \\leq n \\leq 10^{5}, 0 \\leq h_{i} \\leq 10^{5}$ 分析整体来说这道题目还是比较简单的，并且解法也很多，可以用递归，线段树，贪心，动态规划等来解决。 这里我用的是比较容易理解的递归区间的方法，具体细节见代码。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Created by ZJYelizaveta on Tuesday, October 17, 2017 PM02:10:00 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100000 + 3;const int INF = 0x3f3f3f3f;int n;int a[MAX_N];int ans;inline void dfs(int temp, int l, int r) &#123; if (l &gt; r) return; int val = INF, pos = 0; for (int i = l; i &lt;= r; ++i) &#123; if (a[i] &lt; val) &#123; val = a[i]; pos = i; &#125; &#125; ans += val - temp; dfs(val, l, pos - 1); dfs(val, pos + 1, r);&#125;inline void solve() &#123; dfs(0, 1, n); printf(\"%d\\n\", ans);&#125;int main()&#123; n = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) a[i] = readIn&lt;int&gt;(); solve(); return 0;&#125; 花匠描述栋栋的花的高度可以看成一列整数 $h_{1} , h_{2} , \\cdots , h_{n}$ 。设当一部分花被移走后，剩下的花的高度依次为 $g_{1} , g_{2} , \\cdots , g_{m}$ ，则栋栋希望下面两个条件中至少有一个满足 : 条件 A : 对于所有的 $i$，$g_{2i} &gt; g_{2i−1}$ ，且 $g_{2i} &gt; g_{2i+1}$ 条件 B : 对于所有的 $i$，$g_{2i} &lt; g_{2i−1}$ ，且 $g_{2i} &lt; g_{2i+1}$ 注意上面两个条件在 $m = 1$ 时同时满足，当 $m &gt; 1$ 时最多有一个能满足。请问，栋栋最多能将多少株花留在原地。 $1 \\leq n \\leq 10^{5}, 0 \\leq h_{i} \\leq 10^{6}$ 分析诶，序列，好像可以用动态规划来解决，然后就开始想如何用动态规划来解决 我们可以将方案 A 和方案 B 用 $\\Lambda$ 和 $V$ 型来表示，每次考虑第 $i- 1$ 朵花和第 $i$ 朵花之间的高度关系。 令 $dp[i][0]$ 为前 $i$ 朵花最后一朵花为最高点的最长长度，$dp[i][1]$ 为前 $i$ 朵花为最低点的最长的长度。 那么我们有转移方程 : \\left\\{\\begin{matrix} dp[i][0] =max(dp[i - 1][0] ,dp[i - 1][1] + 1) , dp[i][1] = dp[i - 1][1]& (h[i - 1] < h[i])\\\\ dp[i][0] = dp[i - 1][0] , dp[i][1] = dp[i - 1][1] & (h[i - 1] = h[i ]) \\\\ dp[i][0] = dp[i - 1][0] , dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + 1) & (h[i - 1] > h[i]) \\end{matrix}\\right.这里我们实际上不需要真的将这个 $dp$ 数组建立出来，只需要用一个 bool 变量来表示当前这个点是最高点还是最低点即可。 具体细节见代码qwq 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Created by ZJYelizaveta on Tuesday, October 17, 2017 PM03:21:18 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100000 + 3;const int INF = 0x3f3f3f3f;int n;int h[MAX_N];int ansA, ansB;bool flag;// if flag == true, then at this moment this point is the highest// else if flag == false, then at this moment this point is the lowestint main()&#123; n = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) h[i] = readIn&lt;int&gt;(); ansA = ansB = 1; for (int i = 2; i &lt;= n; ++i) &#123; if ((flag &amp;&amp; h[i] &lt; h[i - 1]) || (!flag &amp;&amp; h[i] &gt; h[i - 1])) &#123; ++ansA; flag = !flag; &#125; &#125; flag = false; for (int i = 2; i &lt;= n; ++i) &#123; if ((flag &amp;&amp; h[i] &gt; h[i - 1]) || (!flag &amp;&amp; h[i] &lt; h[i - 1])) &#123; ++ansB; flag = !flag; &#125; &#125; int ans = ansA &lt; ansB ? ansB : ansA; printf(\"%d\\n\", ans); return 0;&#125; 华容道描述小 B 最近迷上了华容道，可是他总是要花很长的时间才能完成一次。于是，他想到用编程来完成华容道 : 给定一种局面，华容道是否根本就无法完成，如果能完成，最少需要多少时间。小 B 玩的华容道与经典的华容道游戏略有不同，游戏规则是这样的 : 在一个 $n \\times m$ 棋盘上有 $n \\times m$ 个格子，其中有且只有一个格子是空白的，其余 $n \\times m - 1$ 个格子上每个格子上有一个棋子，每个棋子的大小都是 $1 \\times 1$ 的 有些棋子是固定的，有些棋子则是可以移动的 任何与空白的格子相邻 ( 有公共的边 ) 的格子上的棋子都可以移动到空白格子上。游戏的目的是把某个指定位置可以活动的棋子移动到目标位置。 给定一个棋盘，游戏可以玩 $q$ 次，当然，每次棋盘上固定的格子是不会变的，但是棋盘上空白的格子的初始位置、指定的可移动的棋子的初始位置和目标位置却可能不同。第 $i$ 次玩的时候，空白的格子在第 $EX_{i}$ 行第 $EY_{i}$ 列，指定的可移动棋子的初始位置为第 $SX_{i}$ 行第 $SY_{i}$ 列，目标位置为第 $TX_{i}$ 行第 $TY_{i} 列。假设小 B 每秒钟能进行一次移动棋子的操作，而其他操作的时间都可以忽略不计。请你告诉小 B 每一次游戏所需要的最少时间，或者告诉他不可能完成游戏。 $1 \\leq n , m \\leq 30, q \\leq 500$ 分析对于 $70 \\%$ 的数据 BFS 可以轻松做到，正解我还没有想到 / 想明白qwq 代码$70 \\%$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// Created by ZJYelizaveta on Tuesday, October 17, 2017 PM03:31:50 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 30 + 3;const int dx[] = &#123;1, -1, 0, 0&#125;;const int dy[] = &#123;0, 0, 1, -1&#125;;int n, m, testCase;int a[MAX_N][MAX_N];int exe, eye, sxs, sys, tx, ty;struct Edge &#123; int ex, ey, sx, sy, d; Edge (int ex, int ey, int sx, int sy, int d) : ex(ex), ey(ey), sx(sx), sy(sy), d(d)&#123;&#125;&#125;;int vis[MAX_N][MAX_N][MAX_N][MAX_N];inline int bfs() &#123; queue&lt;Edge&gt; q; q.push(Edge(exe, eye, sxs, sys, 0)); // 空白块的位置, 目标格子的位置 vis[exe][eye][sxs][sys] = 1; while(!q.empty()) &#123; int ex = q.front().ex, ey = q.front().ey, sx = q.front().sx, sy = q.front().sy, d = q.front().d; q.pop(); for (int i = 0; i &lt; 4; ++i) &#123; int lx = ex + dx[i], ly = ey + dy[i]; if (lx &lt; 1 || lx &gt; n || ly &lt; 1 || ly &gt; m || !a[lx][ly]) continue; if (lx == sx &amp;&amp; ly == sy) &#123; if (vis[lx][ly][ex][ey]) continue; if (ex == tx &amp;&amp; ey == ty) return d + 1; else &#123; q.push(Edge(lx, ly, ex, ey, d + 1)); vis[lx][ly][ex][ey] = 1; &#125; &#125; else &#123; if (vis[lx][ly][sx][sy]) continue; q.push(Edge(lx, ly, sx, sy, d + 1)); vis[lx][ly][sx][sy] = 1; &#125; &#125; &#125; return -1;&#125;inline void solve() &#123; while (testCase--) &#123; exe = readIn&lt;int&gt;(), eye = readIn&lt;int&gt;(), sxs = readIn&lt;int&gt;(), sys = readIn&lt;int&gt;(); tx = readIn&lt;int&gt;(), ty = readIn&lt;int&gt;(); memset(vis, 0, sizeof vis);// q.push((Edge)&#123;ex, ey, sx, sy, 0&#125;); printf(\"%d\\n\", (sxs == tx &amp;&amp; sys == ty) ? 0 : bfs()); &#125;&#125;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(), testCase = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) a[i][j] = readIn&lt;int&gt;(); &#125; if (n &lt;= 30) solve(); return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"LCA","slug":"LCA","permalink":"http://yoursite.com/tags/LCA/"},{"name":"快速幂","slug":"快速幂","permalink":"http://yoursite.com/tags/快速幂/"},{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"},{"name":"逆序对","slug":"逆序对","permalink":"http://yoursite.com/tags/逆序对/"},{"name":"Kruskal","slug":"Kruskal","permalink":"http://yoursite.com/tags/Kruskal/"},{"name":"分治","slug":"分治","permalink":"http://yoursite.com/tags/分治/"},{"name":"BFS","slug":"BFS","permalink":"http://yoursite.com/tags/BFS/"}]},{"title":"NOIP 2014 整理","slug":"NOIP-2014-整理","date":"2017-10-25T04:53:39.000Z","updated":"2017-10-25T05:00:20.738Z","comments":true,"path":"2017/10/25/NOIP-2014-整理/","link":"","permalink":"http://yoursite.com/2017/10/25/NOIP-2014-整理/","excerpt":"Day 1生活大爆炸版石头剪刀布描述石头剪刀布是常见的猜拳游戏：石头胜剪刀，剪刀胜布，布胜石头。如果两个人出拳一样，则不分胜负。在《生活大爆炸》第二季第 8 集中出现了一种石头剪刀布的升级版游戏。","text":"Day 1生活大爆炸版石头剪刀布描述石头剪刀布是常见的猜拳游戏：石头胜剪刀，剪刀胜布，布胜石头。如果两个人出拳一样，则不分胜负。在《生活大爆炸》第二季第 8 集中出现了一种石头剪刀布的升级版游戏。 升级版游戏在传统的石头剪刀布游戏的基础上，增加了两个新手势：斯波克:《星际迷航》主角之一。蜥蜴人:《星际迷航》中的反面角色。这五种手势的胜负关系如表一所示，表中列出的是甲对乙的游戏结果。 现在，小 A 和小 B 尝试玩这种升级版的猜拳游戏。已知他们的出拳都是有周期性规律的，但周期长度不一定等。例如：如果小 A 以“石头-布-石头-剪刀-蜥蜴人-斯波克”长度为 $6$ 的周期出拳，那么他的出拳序列就是“石头-布-石头-剪刀-蜥蜴人-斯波克-石头-布-石头-剪刀-蜥蜴人-斯波克-……”；而如果小 B 以“剪刀-石头-布-斯波克-蜥蜴人”长度为 $5$ 的周期出拳，那么他出拳的序列就是“剪刀-石头-布-斯波克-蜥蜴人-剪刀-石头-布-斯波克-蜥蜴人-……”已知小 A 和小 B 一共进行 $N$ 次猜拳。每一次赢的人得 $1$ 分，输的得 $0$ 分；平局两人都得 $0$ 分。现请你统计 $N$ 次猜拳结束之后两人的得分。 $0 &lt; N \\leq 200, 0 &lt; NA \\leq 200, 0 &lt; NB \\leq 200$ 分析模拟题。 可以先 $\\Theta(n)$ 预先处理处每一个人第 $i$ 次的决策，放在 $a[], b[]$ 中，然后再 $\\Theta(n)$ 计算结果。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Created by ZJYelizaveta on Friday, September 22, 2017 AM09:22:06 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 200 + 3;const int INF = 0x3f3f3f3f;const int win[5][5] = &#123; &#123;0, -1, 1, 1, -1&#125;, &#123;1, 0, -1, 1, -1&#125;, &#123;-1, 1, 0, -1, 1&#125;, &#123;-1, -1, 1, 0, 1&#125;, &#123;1, 1, -1, -1 ,0&#125;&#125;;int n, s1, s2;int r1[MAX_N], r2[MAX_N];int a[MAX_N], b[MAX_N];int main()&#123; n = readIn&lt;int&gt;(), s1 = readIn&lt;int&gt;(), s2 = readIn&lt;int&gt;(); for (int i = 0; i &lt; s1; ++i) r1[i] = readIn&lt;int&gt;(); for (int i = 0; i &lt; s2; ++i) r2[i] = readIn&lt;int&gt;(); int cnt1 = n / s1, cnt2 = n / s2; for (int i = 0; i &lt; cnt1 * s1; ++i) a[i] = r1[i % s1]; for (int i = cnt1 * s1; i &lt; n; ++i) a[i] = r1[i % s1]; for (int i = 0; i &lt; cnt2 * s2; ++i) b[i] = r2[i % s2]; for (int i = cnt2 * s2; i &lt; n; ++i) b[i] = r2[i % s2]; //// for (int i = 0; i &lt; n; ++i) printf(\"%d \", a[i]); printf(\"\\n\");// for (int i = 0; i &lt; n; ++i) printf(\"%d \", b[i]); printf(\"\\n\"); int ans1 = 0, ans2 = 0; for (int i = 0; i &lt; n; ++i) &#123;// printf(\"%d %d\\n\", a[i], b[i]); if (win[a[i]][b[i]] == 0) continue; else if (win[a[i]][b[i]] == 1) ++ans1; else ++ans2; &#125; printf(\"%d %d\\n\", ans1, ans2); return 0;&#125; 联合权值描述无向连通图 G 有 $n$ 个点，$n-1$ 条边。点从 $1$ 到 $n$ 依次编号，编号为 $i$ 的点的权值为 $W_{i}$ ，每条边的长度均为 $1$。图上两点 $(u, v)$ 的距离定义为 $u$ 点到 $v$ 点的最短距离。对于图 G 上的点对 $(u, v)$ ，若它们的距离为 $2$ ，则它们之间会产生 $W _{u} \\times W_{v} $ 的联合权值。请问图 G 上所有可产生联合权值的有序点对中，联合权值最大的是多少？所有联合权值之和是多少? $1 &lt; n \\leq 200000, 0 &lt; W_{i} \\leq 10000$ 分析既然只要求图 G 上的点对 $(u, v)$ ，它们的距离为 $2$ 便可以计算联合权值，那么我们不妨枚举每一个点为中点时，与之相连的距离为 $1$ 的点中，权值最大和次大的点并记下来，然后比较联合权值的大小。 至于求所有的联合权值之和，那么就准备一个 $sum[]$ 数组，记录每一个点与之相连且距离为 $1$ 的所有的点的权值之和，然后逐点记录贡献。 Add_{v} = w[v] \\times (sum[u] - w[v])具体细节看代码qwq 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Created by ZJYelizaveta on Friday, September 22, 2017 AM09:53:42 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 200000 + 3;const int INF = 0x3f3f3f3f;const int MOD = 10007;int n;vector&lt;int&gt; G[MAX_N];ll w[MAX_N], sum[MAX_N];pair&lt;ll, ll&gt; p;ll ans, maxVal;inline void solve() &#123; ans = 0, maxVal = 0; memset(sum, 0, sizeof sum); for (register int u = 1; u &lt;= n; ++u) &#123; p.first = 0, p.second = 0; for (register int i = 0; i &lt; (int)G[u].size(); ++i) &#123; int v = G[u][i]; sum[u] += w[v]; if (p.first &lt;= w[v]) p.second = p.first, p.first = w[v]; else if (p.first &gt; w[v] &amp;&amp; p.second &lt; w[v]) p.second = w[v]; &#125; maxVal = max(maxVal, p.first * p.second); for (register int i = 0; i &lt; (int)G[u].size(); ++i) &#123; int v = G[u][i]; ans = ans + w[v] * (sum[u] - w[v]); ans = (ans % MOD + MOD) % MOD; &#125; &#125;// for (register int i = 1; i &lt;= n; ++i) printf(\"%lld\\n\", sum[i]);&#125;int main()&#123; n = readIn&lt;int&gt;(); for (register int i = 0; i &lt;= n; ++i) G[i].clear(); for (register int i = 1; i &lt;= n - 1; ++i) &#123; int u = readIn&lt;int&gt;(), v = readIn&lt;int&gt;(); G[u].push_back(v), G[v].push_back(u); &#125; for (register int i = 1; i &lt;= n; ++i) w[i] = readIn&lt;int&gt;(); solve(); printf(\"%lld %lld\\n\", maxVal, ans); return 0;&#125; 飞扬的小鸟描述Flappy Bird 是一款风靡一时的休闲手机游戏。玩家需要不断控制点击手机屏幕的频率来调节小鸟的飞行高度，让小鸟顺利通过画面右方的管道缝隙。如果小鸟一不小心撞到了水管或者掉在地上的话，便宣告失败。为了简化问题，我们对游戏规则进行了简化和改编: 游戏界面是一个长为 $n$ ，高为 $m$ 的二维平面，其中有 $k$ 个管道（忽略管道的宽度）。 小鸟始终在游戏界面内移动。小鸟从游戏界面最左边任意整数高度位置出发，到达游戏界面最右边时，游戏完成。 小鸟每个单位时间沿横坐标方向右移的距离为 $1$ ，竖直移动的距离由玩家控制。如 果点击屏幕，小鸟就会上升一定高度 $X$ ，每个单位时间可以点击多次，效果叠加；如果不点击屏幕，小鸟就会下降一定高度 $Y$。小鸟位于横坐标方向不同位置时，上升的高度 $X$ 和下降的高度 $Y$ 可能互不相同。 小鸟高度等于 $0$ 或者小鸟碰到管道时，游戏失败。小鸟高度为 $m$ 时，无法再上升。 现在，请你判断是否可以完成游戏。如果可以，输出最少点击屏幕数；否则，输出小鸟最多可以通过多少个管道缝隙。 $5 \\leq n \\leq 10000, 5 \\leq m \\leq 1000, 0 \\leq k&lt;n, 0&lt;X&lt;m, 0&lt;Y&lt;m, 0&lt;P&lt;n, 0 \\leq L&lt;H ≤m,L +1&lt;H$ 分析搜索 + 剪枝，动态规划 + 优化 这两种方法都是可以过这道题目的。 令 $dp[i][j]$ 为横坐标到 $i$ ，纵坐标到 $j$ 所需的最少点击数。 上升高度因为可以点击多次所以可以看做是做“完全背包”，而下降则相当于做“01 背包”。 这样一来我们有一个很见到的 $\\Theta(nm^{2})$ 的转移方程： dp[i][j] = \\left\\{\\begin{matrix} \\underset{k}{min}(dp[i - 1][j - k \\times x[i - 1]])& (j - k \\times x[i - 1] > 0) \\\\ dp[i - 1][j + y[i - 1]]& (j + y[i - 1] \\leq m) \\end{matrix}\\right.这个转移方程每次状态转移的时间复杂度为 $\\Theta(m)$ ，那么如何每次状态转移的时间复杂度呢？ 考虑“点击 $k - 1$ 次”和“点击 $k$ 次”之间的关联。 如果到达点 $[i, j]$ 最少点击数为 $k$ ，那么也就是说点击 $k - 1$ 可以到达 $[i, j - x[i - 1]]$ 。那么在只考虑上升的情况下，转移方程可以优化为： dp[i][j] = min(dp[i][j], min(dp[i - 1][j - x[i - 1]] + 1, dp[i][j - x[i - 1]] + 1));这样我们就可以 $\\Theta(1)$ 转移啦qwq 这里要注意一点，就是我们肯定要判断上升和下降是否接触到边界，也就是将边界标记为 $dp[pos][low] = \\textrm{INF}, dp[pos][high] = \\textrm{INF}$ ，这里把判断要放在最后。因为有一种情况，即点击 $k - 1$ 次会到达管道最下方，但是点击 $k$ 次并不会触碰到管道，因为点击 $k$ 次由点击 $k - 1$ 次转移而来，所以这里将判断放在最后面。 然后上升的时候，因为不管怎么上升最高高度只会为 $m$ 所以这里要拎出来单独计算。 总时间复杂度 $\\Theta(nm)$ 。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// Created by ZJYelizaveta on Wednesday, October 25, 2017 AM10:45:41 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int MAX_M = 1000 + 3;const int INF = 0x3f3f3f3f;int n, m, k;int x[MAX_N], y[MAX_N];struct Pipe &#123; int flag, low, high;&#125;a[MAX_N];int dp[MAX_N][MAX_M];int ans;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(), k = readIn&lt;int&gt;(); for (int i = 0; i &lt; n; ++i) x[i] = readIn&lt;int&gt;(), y[i] = readIn&lt;int&gt;(); for (int i = 1; i &lt;= k; ++i) &#123; int x = readIn&lt;int&gt;(); a[x].flag = true; a[x].low = readIn&lt;int&gt;(), a[x].high = readIn&lt;int&gt;(); &#125; dp[0][0] = INF; for (int i = 1; i &lt;= n; ++i) &#123; dp[i][0] = INF; for (int j = 1; j &lt; m; ++j) &#123; dp[i][j] = INF; if (j - x[i - 1] &gt; 0) &#123; // clicks if (dp[i - 1][j - x[i - 1]] != INF) &#123; dp[i][j] = min(dp[i][j], dp[i - 1][j - x[i - 1]] + 1); &#125; if (dp[i][j - x[i - 1]] != INF) &#123; dp[i][j] = min(dp[i][j], dp[i][j - x[i - 1]] + 1); &#125; &#125; &#125; for (int j = 1; j &lt;= m - y[i - 1]; ++j) &#123; // down if (dp[i - 1][j + y[i - 1]] != INF) dp[i][j] = min(dp[i][j], dp[i - 1][j + y[i - 1]]); &#125; dp[i][m] = INF; for (int j = m - x[i - 1]; j &lt;= m; ++j) &#123; // Edge if (dp[i - 1][j] != INF) dp[i][m] = min(dp[i][m], dp[i - 1][j] + 1); if (dp[i][j] != INF) dp[i][m] = min(dp[i][m], dp[i][j] + 1); &#125; if (a[i].flag) &#123; // check for (int j = 1; j &lt;= m; ++j) if (j &lt;= a[i].low || j &gt;= a[i].high) dp[i][j] = INF; &#125; // &#125; ans = INF; for (int i = 1; i &lt;= m; ++i) ans = min(ans, dp[n][i]); if (ans != INF) &#123; printf(\"1\\n%d\\n\", ans); &#125; else &#123; int pos = -INF; for (int i = n - 1; i &gt;= 0; --i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (dp[i][j] != INF) &#123; pos = i; break; &#125; &#125; if (pos != -INF) break; &#125;// printf(\"%d\\n\", pos); int cnt = 0; for (int i = 1; i &lt;= pos; ++i) if (a[i].flag) ++cnt; printf(\"0\\n%d\\n\", cnt); &#125; return 0;&#125; Day 2无线网络发射器选址代码随着智能手机的日益普及，人们对无线网的需求日益增大。某城市决定对城市内的公共场所覆盖无线网。假设该城市的布局为由严格平行的 $129$ 条东西向街道和 $129$ 条南北向街道所形成的网格状，并且相邻的平行街道之间的距离都是恒定值 $1$。东西向街道从北到南依次编号为 $0,1,2, \\cdots ,128$ ，南北向街道从西到东依次编号为 $0,1,2, \\cdots,128$。东西向街道和南北向街道相交形成路口，规定编号为 $x$ 的南北向街道和编号为 $y$ 的东西向街道形成的路口的坐标是 $(x, y)$。在某些路口存在一定数量的公共场所。由于政府财政问题，只能安装一个大型无线网络发射器。该无线网络发射器的传播范围是一个以该点为中心，边长为 $2 \\times d$ 的正方形。传播范围包括正方形边界。例如下图是一个 $d = 1$ 的无线网络发射器的覆盖范围示意图。 现在政府有关部门准备安装一个传播参数为 $d$ 的无线网络发射器，希望你帮助他们在城市内找出合适的安装地点，使得覆盖的公共场所最多。 $1 \\leq d \\leq 20, 1 \\leq n \\leq 20, 0 \\leq x \\leq 128, 0 \\leq y \\leq 128, 0 &lt; k \\leq 10^{6}$ 分析因为 $0 \\leq x \\leq 128, 0 \\leq y \\leq 128$ ，那么我们令 $cnt[i][j]$ 为范围在 $x \\leq i, y \\leq j$ 的覆盖的公共场所数量。那么我们可以以 $\\Theta(128^{2}40^{2})$ 的时间复杂度预处理出来。 然后我们将所有的 $cnt[i][j]$ 放进优先队里来维护，这样队首就是我们所求的最大值。至于方案数量，那么就只需要遍历一遍队列即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// Created by ZJYelizaveta on Tuesday, October 24, 2017 AM08:52:01 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 128 + 3;const int INF = 0x3f3f3f3f;int d, n;int a[MAX_N][MAX_N];int sum[MAX_N][MAX_N];int mx, cnt;int main()&#123; d = readIn&lt;int&gt;(), n = readIn&lt;int&gt;();// printf(\"%d %d\\n\", d, n); for (int i = 1; i &lt;= n; ++i) &#123; int x = readIn&lt;int&gt;(), y = readIn&lt;int&gt;(), k = readIn&lt;int&gt;(); a[x][y] = k; &#125; priority_queue&lt;int&gt; q; for (int i = 0; i &lt;= 128; ++i) &#123; for (int j = 0; j &lt;= 128; ++j) &#123; for (int l = max(0, i - d); l &lt;= min(128, i + d); ++l) &#123; for (int r = max(0, j - d); r &lt;= min(128, j + d); ++r) &#123; sum[i][j] += a[l][r]; &#125; &#125; q.push(sum[i][j]); &#125; &#125; mx = q.top(); while (!q.empty()) &#123; int temp = q.top(); q.pop(); if (temp == mx) ++cnt; &#125; printf(\"%d %d\\n\", cnt, mx); return 0;&#125; 寻找道路描述在有向图 G 中，每条边的长度均为 $1$ ，现给定起点和终点，请你在图中找一条从起点到终点的路径，该路径满足以下条件： 路径上的所有点的出边所指向的点都直接或间接与终点连通。 在满足条件 1 的情况下使路径最短。 注意：图 G 中可能存在重边和自环，题目保证终点没有出边。请你输出符合条件的路径的长度。 $0 &lt; n \\leq 10000, 0 &lt; m \\leq 200000, 0 &lt; x, y, s, t \\leq n, x \\neq t$ 分析这道题目还是比较简单的。 我们有结论：如果在原图上有点 $u$ 不能走到终点 $t$ ，那么在反图中（即将原图中所有边的方向都取反）我们从终点出发也遍历不到点 $u$ 。 有了这个结论，那么我们可以先预处理处在反图上从终点出发到达不了的点，即从终点开始 dfs，每遍历到一个点，就标记一下。如果 dfs 结束，还有点没有遍历到，那么这个点就是从终点 $t$ 出发走不到的点。我们还要将与这些点相邻的点（能到达且距离为 $1$ 的点）也标记一下。 然后就可以在原图上做 spfa 了，那些被标记的点在做最短路的时候，判断一下使之不能加入队列中即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// Created by ZJYelizaveta on Tuesday, October 24, 2017 AM10:47:29 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int MAX_M = 200000 + 3;const int INF = 0x3f3f3f3f;int n, m;int s, t;int ans;vector&lt;int&gt; G[MAX_N];int vis[MAX_N];inline void dfs(int u) &#123;// printf(\"%d\\n\", u); vis[u] = 1; for (int i = 0; i &lt; (int)G[u].size(); ++i) if (!vis[G[u][i]]) dfs(G[u][i]);&#125;int vis1[MAX_N];inline void prepare() &#123;// printf(\"%d\\n\", t); memset(vis, 0, sizeof vis); dfs(t); memset(vis1, 1, sizeof vis1); for (int u = 1; u &lt;= n; ++u) if (!vis[u]) &#123; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; int v = G[u][i]; vis1[v] = 0; &#125; &#125; for (int i = 1; i &lt;= n; ++i) if (!vis1[i]) vis[i] = 0;&#125;struct Edge &#123; int to, next;&#125;edge[MAX_M];int head[MAX_N], cnt = 0;int dist[MAX_N], inq[MAX_N];inline void addEdge(int from, int to) &#123; edge[++cnt].to = to; edge[cnt].next = head[from]; head[from] = cnt;&#125;inline void spfa() &#123; queue&lt;int&gt; q; memset(dist, INF, sizeof dist); memset(inq, 0, sizeof inq); q.push(s); inq[s] = 1; dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = 0; for (int i = head[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (vis[v] &amp;&amp; dist[v] &gt; dist[u] + 1) &#123; dist[v] = dist[u] + 1; if (!inq[v]) &#123; inq[v] = 0; q.push(v); &#125; &#125; &#125; &#125; if (dist[t] == INF) ans = -1; else ans = dist[t];&#125;inline void solve() &#123; if (!vis[s]) ans = -1; else &#123; ans = 0; spfa(); &#125; printf(\"%d\\n\", ans);&#125;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 1; i &lt;= m; ++i) &#123; int u = readIn&lt;int&gt;(), v = readIn&lt;int&gt;(); G[v].push_back(u); addEdge(u, v); &#125; s = readIn&lt;int&gt;(), t = readIn&lt;int&gt;(); prepare(); solve(); return 0;&#125; 解方程描述已知多项式方程： a_{0} + a_{1}x + a_{2}x^{2} + \\cdots + a_{n}x^{n} = 0求这个方程在 $[1, m]$ 内的整数解（$n$ 和 $m$ 均为正整数）。 $0 &lt; n \\leq 100, \\left | a_{i} \\right | \\leq 10^{10000}, a_{n} \\neq 0, m \\leq 1000000$ 分析感谢出题人，给我这种数学渣渣留了 30 分，[滑稽].jpg 没思路，然后看了一下题解。 首先对于 $50 \\%$ 的分数如果考虑暴力的思路，肯定是需要用高精度的，于是换一个思路考虑。 一元高次方程是没有通解的，而且本题系数非常大，显然不是用一个很确切的数学方法来求解。 考虑将方程放在模意义下来考虑，我们令 f(x) = a_{0} + a_{1}x+a_{2}x^{2} + \\cdots + a_{n}x^{n}我们取一个大质数 $p$ ，如果 $f(x) \\pmod p = 0$ ，那么 $(f(x) + p) \\pmod p = 0$ ，虽然反过来不一定成立，那么这个时候就需要看你的人品了qwq，这样可以水到 70 分，时间复杂度 $\\Theta(mnlogn)$ 。 如果计算的时候不想以 $\\Theta(nlogn)$ 这样较高的时间复杂度计算 $f(x)$，那么其实我们可以将时间复杂度降至 $\\Theta(n)$ 的，我们需要用到 秦九韶算法 ，原理是这样的： \\begin{align*} f(x) &= 2x^{3} + 6x^{2} - 5x + 3\\\\ &= x(2x^{2} + 6x - 5) + 3\\\\ &= x(x(2x + 6) - 5) + 3 \\end{align*}因为 $f(x) \\ \\% \\ p = 0$ ，那么有 $(f(x) + p) \\ \\% \\ p = 0$ ；又因为反过来不一定成立，所以我们不妨多取几个质数来验证，但是这样时间复杂度仍然降不到一个理想的程度。 又因为我们考虑，在模 $p$ 意义下，若 $f(x) \\pmod p= 0$ ，则一定有 $f(x+p) \\pmod p = 0$ 。反之，若 $f(x) \\pmod p\\neq 0$ ，则一定有$f(x+p) \\pmod p \\neq 0$ 。所以我们只需验证 $[1,p)$ 即可。 这样我们取两个较小的质数和一个较大的质数，然后三者同时成立时，此时的 $x​$ 为解之一。 时间复杂度为 $\\Theta(mn + MOD1 + MOD2)$ ，看起来有点吓人，但是实际上这个复杂度并不满qwq 代码$30 \\%$ 12345678910111213141516171819202122232425262728293031323334353637383940414243// Created by ZJYelizaveta on Tuesday, October 24, 2017 PM02:17:24 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.// 30%#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;int n, m;int a[MAX_N];vector&lt;int&gt; ans;int cnt;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n + 1; ++i) a[i] = readIn&lt;int&gt;(); for (int x = 1; x &lt;= m; ++x) &#123; int temp = 0; for (int i = 1; i &lt;= n + 1; ++i) &#123; if (i == 1) temp += a[i]; if (i == 2) temp += a[i] * x; if (i == 3) temp += a[i] * x * x; &#125; if (temp == 0) &#123; ++cnt; ans.push_back(x); &#125; &#125; printf(\"%d\\n\", cnt); for (int i = 0; i &lt; ans.size(); ++i) printf(\"%d\\n\", ans[i]); return 0;&#125; $70 \\%$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Created by ZJYelizaveta on Tuesday, October 24, 2017 PM02:49:31 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.// 70%#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int INF = 0x3f3f3f3f;const int MOD = 1e9 + 7;int n, m;char str[MAX_N];ll a[MAX_N];vector&lt;int&gt; ans;int cnt;inline ll quickPow(ll a, ll b) &#123; ll res = 1; while (b) &#123; if (b &amp; 1) (res *= a) %= MOD; (a *= a) %= MOD; b &gt;&gt;= 1; &#125; return res;&#125;inline ll readStr() &#123; ll x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = (x * 10 + ch - '0' % MOD + MOD) % MOD; ch = getchar();&#125; return (x * f % MOD + MOD) % MOD;&#125;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n + 1; ++i) a[i] = readStr();// for (int i = 1; i &lt;= n + 1; ++i) printf(\"%lld \", a[i]); printf(\"\\n\"); for (int x = 1; x &lt;= m; ++x) &#123; ll temp = 0; for (int i = 1; i &lt;= n + 1; ++i) &#123; temp = (temp + a[i] * quickPow(x, i - 1) % MOD + MOD) % MOD; &#125; if (temp == 0) &#123; ans.push_back(x); ++cnt; &#125; &#125; printf(\"%d\\n\", cnt); for (int i = 0; i &lt; ans.size(); ++i) printf(\"%d\\n\", ans[i]); return 0;&#125; $100 \\%$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// Created by ZJYelizaveta on Tuesday, October 24, 2017 PM03:18:44 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int MAX_M = 1000000 + 3;const int MOD1 = 10651;const int MOD2 = 11677;const int MOD3 = 11987;int n, m;int a[MAX_N][5];int flag1[MOD1], flag2[MOD2];vector&lt;int&gt; ans;int cnt;inline void readStr(int i) &#123; char ch; bool flag; while (!isdigit(ch = getchar()) &amp;&amp; ch != '-'); flag = (ch == '-') ? false : true; a[i][1] = (ch == '-') ? 0 : (ch - '0') % MOD1; a[i][2] = (ch == '-') ? 0 : (ch - '0') % MOD2; a[i][3] = (ch == '-') ? 0 : (ch - '0') % MOD3; while (isdigit(ch = getchar())) &#123; a[i][1] = (a[i][1] * 10 + ch - '0') % MOD1; a[i][2] = (a[i][2] * 10 + ch - '0') % MOD2; a[i][3] = (a[i][3] * 10 + ch - '0') % MOD3; &#125; if (flag == false) &#123; a[i][1] = (MOD1 - a[i][1]) % MOD1; a[i][2] = (MOD2 - a[i][2]) % MOD2; a[i][3] = (MOD3 - a[i][3]) % MOD3; &#125;&#125;inline bool calculate(int x, int mod, int flag) &#123; int res = 0; for (int i = n; i &gt;= 0; --i) &#123; res = (1ll * res * x + a[i][flag]) % mod; &#125; return res == 0 ? true : false;&#125;int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(); for (int i = 0; i &lt;= n; ++i) readStr(i);// for (int i = 0; i &lt;= n; ++i) printf(\"%d %d %d\\n\", a[i][1], a[i][2], a[i][3]); for (int i = 0; i &lt; MOD1; ++i) flag1[i] = calculate(i, MOD1, 1); for (int i = 0; i &lt; MOD2; ++i) flag2[i] = calculate(i, MOD2, 2); ans.clear(); for (int i = 1; i &lt;= m; ++i) &#123; int fir = i % MOD1; int sec = i % MOD2; if (flag1[fir] &amp;&amp; flag2[sec] &amp;&amp; calculate(i, MOD3, 3)) &#123; ans.push_back(i); ++cnt; &#125; &#125; printf(\"%d\\n\", cnt); for (int i = 0; i &lt; (int)ans.size(); ++i) printf(\"%d\\n\", ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"SPFA","slug":"SPFA","permalink":"http://yoursite.com/tags/SPFA/"},{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"},{"name":"哈希","slug":"哈希","permalink":"http://yoursite.com/tags/哈希/"},{"name":"背包dp","slug":"背包dp","permalink":"http://yoursite.com/tags/背包dp/"},{"name":"枚举","slug":"枚举","permalink":"http://yoursite.com/tags/枚举/"}]},{"title":"NOIP 2011 整理","slug":"NOIP-2011-整理","date":"2017-10-23T06:42:29.000Z","updated":"2017-10-23T15:29:00.202Z","comments":true,"path":"2017/10/23/NOIP-2011-整理/","link":"","permalink":"http://yoursite.com/2017/10/23/NOIP-2011-整理/","excerpt":"Day 1铺地毯描述为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。","text":"Day 1铺地毯描述为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 $n$ 张地毯，编号从 $1$ 到 $n$。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。 注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。 $0 \\leq n \\leq 1000, 0 \\leq a, b, g, k \\leq 10^{5}$ 分析题目较为简单，是 NOIP Day1 T1 的水准。 $\\Theta(n)$ 的扫一遍，如果这个点包含在某一张地毯中则更新答案。 代码12345678910111213141516171819202122232425262728293031323334353637383940// Created by ZJYelizaveta on 2017年09月02日 星期六 09时13分58秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int INF = 0x3f3f3f3f;int n;struct Carpet &#123; int a, b, g, k;&#125;c[MAX_N];int fx, fy;int ans;int main()&#123; n = readIn(); for (int i = 0; i &lt; n; ++i) &#123; c[i].a = readIn(), c[i].b = readIn(), c[i].g = readIn(), c[i].k = readIn(); &#125; fx = readIn(), fy = readIn();//final x and final y ans = -1; for (int i = 0; i &lt; n; ++i) &#123; int x = c[i].a + c[i].g; int y = c[i].b + c[i].k; if (c[i].a &lt;= fx &amp;&amp; fx &lt;= x &amp;&amp; c[i].b &lt;= fy &amp;&amp; fy &lt;= y) ans = i + 1; &#125; printf(\"%d\\n\", ans); return 0;&#125; 选择客栈描述丽江河边有 $n$ 家很有特色的客栈，客栈按照其位置顺序从 $1$ 到 $n$ 编号。每家客栈都按照某一种色调进行装饰（总共 $k$ 种，用整数 $0 \\sim k-1$ 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $p$。他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $p$ 元的咖啡店小聚。 $2 \\leq n \\leq 200000, 0 &lt; k \\leq 50, 0 \\leq p \\leq 100, 0 \\leq$ 最低消费 $\\leq 100$ 分析$\\Theta(n^{2})$ 枚举可以拿到 60 分，我也不知道为什么是 60 呢！竟然没有越界qwq $\\Theta(n^{2})$ 这样的时间复杂度肯定是不行的，考虑优化时间复杂度到 $\\Theta(n)$ 或 $\\Theta(nlogn)$，同样也可以考虑关于关于颜色 $k$ 的时间复杂度哒。 像这种有关区间的计数，可以考虑固定其中一个端点，然后扫一下区间。 如果 $q[i].b \\leq p$，令 $pos = i$ 则计算： $sum[]$ 表示 $pos$ 以左颜色 $q[i].a$ 的颜色个数。 $cnt[]$ 表示当前颜色 $q[i].a$ 的个数。 $lastPos[]$ 表示颜色 $q[i].a$ 上一次出现的位置。 计算之后，更新 $cnt[], lastPos[]$ 即可。 代码$60 \\%$ 12345678910111213141516171819202122232425262728293031323334353637383940414243// Created by ZJYelizaveta on Thursday, October 19, 2017 AM08:49:42 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int INF = 0x3f3f3f3f;int n, k, p;struct Hotel &#123; int c, p;&#125;a[MAX_N];int ans;int main()&#123; n = readIn&lt;int&gt;(), k = readIn&lt;int&gt;(), p = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) a[i].c = readIn&lt;int&gt;(), a[i].p = readIn&lt;int&gt;(); ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; int color = a[i].c; for (int j = i + 1; j &lt;= n; ++j) if (a[j].c == color) &#123;// printf(\"%d %d\\n\", i, j); for (int k = i; k &lt;= j; ++k) &#123; if (a[k].p &lt;= p) &#123; ++ans; break; &#125; &#125; &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125; $100 \\%$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Created by ZJYelizaveta on Thursday, October 19, 2017 PM03:37:49 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 200000 + 3;const int MAX_K = 50 + 3;const int MAX_P = 100 + 3;const int INF = 0x3f3f3f3f;int n, m, p;struct Hotel &#123; int a, b;&#125;q[MAX_N];int sum[MAX_K], cnt[MAX_K], lastPos[MAX_K];int main()&#123; n = readIn&lt;int&gt;(), m = readIn&lt;int&gt;(), p = readIn&lt;int&gt;(); for (int i = 1; i &lt;= n; ++i) q[i].a = readIn&lt;int&gt;(), q[i].b = readIn&lt;int&gt;(); int pos = 0, ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (q[i].b &lt;= p) pos = i; // if (pos &gt;= lastPos[q[i].a]) sum[q[i].a] = cnt[q[i].a]; ans += sum[q[i].a]; ++cnt[q[i].a]; lastPos[q[i].a] = i; &#125; printf(\"%d\\n\", ans); return 0;&#125; mayan 游戏描述Mayan puzzle 是最近流行起来的一个游戏。游戏界面是一个 $7$ 行 $5$ 列的棋盘，上面堆放着一些方块，方块不能悬空堆放，即方块必须放在最下面一行，或者放在其他方块之上。游戏通关是指在规定的步数内消除所有的方块，消除方块的规则如下： 每步移动可以且仅可以沿横向（即向左或向右）拖动某一方块一格：当拖动这一方 块时，如果拖动后到达的位置（以下称目标位置）也有方块，那么这两个方块将交换位置（参见输入输出样例说明中的图 6 到图 7)；如果目标位置上没有方块，那么被拖动的方块将从原来的竖列中抽出，并从目标位置上掉落（直到不悬空,参见下面图 1 和图 2）； 任一时刻，如果在一横行或者竖列上有连续三个或者三个以上相同颜色的方块，则 它们将立即被消除（参见图 1 到图 3）。 注意： a) 如果同时有多组方块满足消除条件，几组方块会同时被消除（例如下面图 4，三个颜色为 $1$ 的方块和三个颜色为 $2$ 的方块会同时被消除，后剩下一个颜色为 $2$ 的方块）。 b) 当出现行和列都满足消除条件且行列共享某个方块时，行和列上满足消除条件的所有方块会被同时消除（例如下面图 5 所示的情形，$5$ 个方块会同时被消除）。 方块消除之后，消除位置之上的方块将掉落，掉落后可能会引起新的方块消除。注意：掉落的过程中将不会有方块的消除。 上面图 1 到图 3 给出了在棋盘上移动一块方块之后棋盘的变化。棋盘的左下角方块的坐标为 $(0, 0)$ 将位于 $(3, 3)$ 的方块向左移动之后，游戏界面从图 1 变成图 2 所示的状态，此时在一竖列上有连续三块颜色为 $4$ 的方块，满足消除条件，消除连续 $3$ 块颜色为 $4$ 的方块后，上方的颜色为 $3$ 的方块掉落，形成图 3 所示的局面。 分析模拟的时候就是连暴力都不想写了，然后改题目的时候由于代码能力较差 写 + 调试 用了一上午，Sign 思路很简洁，因为已经限制了步数，那么我们用 dfs 就可以求解了，至于下落和消除就是模拟。 但是单纯的 dfs 回溯是不够的，我们需要一些剪枝和优化： 因为我们要求方案的字典序最小，所以我们在平移的时候遵从一下几点 在中间的时候向右交换（左边那个向右边移动字典序更小） 当左边没有格的时候向左移动 当右边的格子和自己相同时跳过 最优化剪枝：不移动相同的色块 可行性剪枝：若某种颜色的方块数量小于 $3$ 则无解 然后就是模拟 + 爆搜了qwq 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165// Created by ZJYelizaveta on Monday, October 23, 2017 AM09:11:19 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#pragma GCC optimize(3)#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 7 + 3;const int INF = 0x3f3f3f3f;int n;int color[MAX_N][MAX_N];int cnt[MAX_N + 3];struct Node &#123; int x, y, flag;&#125;ans[MAX_N];inline bool empty() &#123; for (int i = 0; i &lt; 5; ++i) &#123; for (int j = 0; j &lt; 7; ++j) if (color[i][j]) return false; // &#125; return true;&#125;int num[10][10];inline void drop() &#123; memset(num, -1, sizeof num); for (int i = 0; i &lt; 5; ++i) &#123; int k = 0; for (int j = 0; j &lt; 7; ++j) &#123; if (color[i][j]) num[i][k++] = j; &#125; &#125; for (int i = 0; i &lt; 5; ++i) &#123; for (int j = 0; j &lt; 7; ++j) &#123; color[i][j] = num[i][j] == -1 ? 0 : color[i][num[i][j]]; // drop the square which in the middle of the row without another square beneath it &#125; &#125;/* for (int i = 0; i &lt; 5; ++i) &#123; for (int j = 0; j &lt; 7; ++j) printf(\"%d \", color[i][j]); printf(\"\\n\"); &#125;*/ return; //&#125;bool clear() &#123; bool flag = 0; for (int i = 0; i &lt; 3; ++i) &#123; for (int j = 0; j &lt; 7; ++j) if (color[i][j]) &#123; int k; for (k = i; k + 1 &lt; 5 &amp;&amp; color[k + 1][j] == color[i][j]; ++k); if (k - i &gt;= 2) &#123; for (int l = i; l &lt;= k; l++) &#123; int up = j, down = j; while (up + 1 &lt; 7 &amp;&amp; color[l][up + 1] == color[i][j]) up++; while (down - 1 &gt;= 0 &amp;&amp; color[l][down - 1] == color[i][j]) down--; if (up - down &gt;= 2) &#123; for (int h = down; h &lt;= up; ++h) color[l][h] = 0; &#125; &#125; for (int l = i; l &lt;= k; ++l) color[l][j] = 0; flag = true; &#125; &#125; &#125; for (int i = 0; i &lt; 5; ++i) &#123; for (int j = 0; j &lt; 5; ++j) if (color[i][j]) &#123; int k; for (k = j; k + 1 &lt; 7 &amp;&amp; color[i][k + 1] == color[i][j]; k++); if (k - j &gt;= 2) &#123; for (int h = j; h &lt;= k; ++h) &#123; int lft = i,rht = i; while (lft - 1 &gt;= 0 &amp;&amp; color[lft - 1][h] == color[i][j]) lft--; while (rht + 1 &lt; 7 &amp;&amp; color[rht + 1][h] == color[i][j]) rht++; if (rht - lft &gt;= 2) &#123; for (int l = lft; l &lt;= rht; ++l) color[l][h] = 0; &#125; &#125; for (int h = j; h &lt;= k; h++) color[i][h] = 0; flag = 1; &#125; &#125; &#125; if (flag) return true; else return false;&#125;void dfs(int step) &#123; if (step &gt; n) &#123; if (empty()) &#123; for (int i = 1; i &lt;= n; ++i) &#123; if (ans[i].flag) &#123; printf(\"%d %d %d\\n\", ans[i].x + 1, ans[i].y, -1); // move the square which on [i, j]'s right to the left &#125; else &#123; printf(\"%d %d %d\\n\", ans[i].x, ans[i].y, 1); &#125; &#125; exit(0); &#125; return; &#125; int cnt[12]; memset(cnt, 0, sizeof cnt); // caculate for (int i = 0; i &lt; 5; ++i) &#123; for (int j = 0; j &lt; 7; ++j) ++cnt[color[i][j]]; &#125; for (int i = 1; i &lt;= 10; ++i) // if there is a color which its quantity is less than 3, it means that in this situation we have no solution if (cnt[i] != 0 &amp;&amp; cnt[i] &lt; 3) return; for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 7; ++j) if (color[i][j] != color[i + 1][j]) &#123; // if the color between [i, j] and [i + 1, j] are the same, we don't need to swap them ans[step].x = i; ans[step].y = j; ans[step].flag = (!color[i][j]); int temp[10][10]; memcpy(temp, color, sizeof temp); swap(color[i][j], color[i + 1][j]); drop(); while (clear()) drop(); dfs(step + 1); ans[step].x = 0; ans[step].y = 0, ans[step].flag = 0; memcpy(color, temp, sizeof color); &#125; &#125;&#125;int main()&#123; n = readIn&lt;int&gt;(); for (int i = 0; i &lt; 5; ++i) &#123; for (int j = 0; ; ++j) &#123; color[i][j] = readIn&lt;int&gt;(); if (color[i][j] == 0) break;// printf(\"%d \", color[i][j]); &#125;// printf(\"\\n\"); &#125; dfs(1); printf(\"-1\\n\"); return 0;&#125; Day 2计算系数描述给定一个多项式 $( ax + by )^{k}$ ，请求出多项式展开后 $x^{n} y^{m}$ 项的系数。 $0 \\leq k \\leq 1000, 0 \\leq n, m \\leq k$，且 $n + m = k, 0 \\leq a, b \\leq 10^{6}$ 分析就是二项式定理呀 qwq 对于不带系数的形式，我们有如下的形式： (x + y)^{n} = \\sum_{k = 0}^{n} \\binom{n}{k}x^{n - k}y^{k}那么对于有系数的形式呢？ (ax + by)^{k} = \\sum_{i = 0}^{k}\\binom{k}{i}a^{k - i}b^{i}x^{k - i}y^{i}这样一来，对于 $x^{n}y^{m}$ 这一项的系数我们可以将其表示为： ans = a^{n}b^{m}\\binom{k}{n}处理组合数的时候我们可以将其分为阶层 $fac[]$ 和逆元 $inv[]$ 来处理，其中我们可以 $\\Theta(n)$ 预处理处阶层，并在 $\\Theta(n + logn)$ 的时间复杂度内预处理处逆元。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// Created by ZJYelizaveta on Monday, September 04, 2017 AM09:19:33 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0; int f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int INF = 0x3f3f3f3f;const int MOD = 10007;int k, n, m;int fac[MAX_N], inv[MAX_N];ll ans;inline void exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if(b == 0) &#123;x = 1, y = 0;&#125; else&#123; exgcd(b, a % b, y, x); y -= (a / b) * x; &#125;&#125;inline int calculate(int a, int b)&#123; int x = 0, y = 0; exgcd(a, b, x, y); return (x % b + b) % b;&#125;inline void prepare()&#123; fac[0] = 1; for(int i = 1; i &lt;= k; ++i) fac[i] = fac[i - 1] * i % MOD;// for(int i = 1; i &lt;= n; ++i) printf(\"f[%d] = %lld\\n\", i, fac[i]); inv[k] = calculate(fac[k], MOD); for(int i = k - 1; i &gt;= 0; --i) inv[i] = inv[i + 1] * (i + 1) % MOD;// for(int i = 1; i &lt;= n; ++i) printf(\"inv[%d] = %lld\\n\", i, inv[i]);&#125;inline ll quickPow(int a, int b) &#123; ll res = 1; while (b) &#123; if (b &amp; 1) res = 1ll * res * a % MOD; a = 1ll * a * a % MOD; b &gt;&gt;= 1; &#125; return res;&#125;inline void solve(int a, int b) &#123; ans = (ll)quickPow(a, n) * quickPow(b, m) % MOD;// printf(\"%lld\\n\", ans); ans = (ll)ans * fac[k] % MOD * inv[n] % MOD * inv[m] % MOD; printf(\"%lld\\n\", ans);&#125;int main()&#123; int a = readIn(), b = readIn(); k = readIn(), n = readIn(), m = readIn(); prepare(); ans = 0; if (n == 0) &#123; ans = quickPow(b, k); printf(\"%lld\\n\", (ans % MOD + MOD) % MOD); &#125; else if (m == 0) &#123; ans = quickPow(a, k); printf(\"%lld\\n\", (ans % MOD + MOD) % MOD); &#125; else solve(a, b); return 0;&#125; 聪明的质监员描述小 T 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 $n$ 个矿石，从 $1$ 到 $n$ 逐一编号，每个矿石都有自己的重量 $w_{i}$ 以及价值 $v_{i}$ 。检验矿产的流程是： 给定 $m$ 个区间 $[L_{i} ,R_{i}]$。 选出一个参数 $W$。 对于一个区间 $[L_{i} ,R_{i} ]$，计算矿石在这个区间上的检验值 $Y_{i}$： Y_{i} = \\sum_{j}1 \\times \\sum_{j}v_{j}, j \\in [L_{i}, R_{i}] 且 w_{j} \\geq W, j是矿石编号 这批矿产的检验结果 $Y$ 为各个区间的检验值之和。即：$Y = \\sum_{i = 1}^{m}Y_{i}$若这批矿产的检验结果与所给标准值 $S$ 相差太多，就需要再去检验另一批矿产。小 T不想费时间去检验另一批矿产，所以他想通过调整参数 $W$ 的值，让检验结果尽可能的靠近标准值 $S$，即使得 $S-Y$ 的绝对值最小。请你帮忙求出这个最小值。 $1 \\leq n, m \\leq 2 \\times 10^{5}, 0 &lt; w_{i}, v_{i} \\leq 10^{6}, 0 &lt; S \\leq 10^{12}, 1 \\leq L_{i} \\leq R_{i} \\leq n$ 分析我们需要最小化 $S - Y$ 的绝对值，因为 $S$ 是定值，那么我们要最小化 $Y$ 的值。 最极端的我们可以枚举 $W$ 的所有可能值 $0 \\sim max(w[i])$ ，然后 $\\Theta(n^{3})$ 计算。 这应该是我们暴力的思路，但是作为正解而言时间复杂度太高了，考虑如何优化时间复杂度。 因为 $W$ 的取值是线性的，所以考虑 $\\Theta(logn)$ 二分 $W$，然后 $\\Theta(n^{2})$ 来计算和判断。 我们把枚举 $W$ 的时间复杂度由 $\\Theta(n)$ 降到了 $\\Theta(logn)$ 但是由于计算和判断的时间复杂度很大，所以我们仍然只能拿到 50 分，考虑优化计算和判断的时间复杂度。 用 $cnt[i]$ 表示前 $i$ 个矿石中满足条件的个数， $sum[i]$ 表示前 $i$ 个满足条件的矿石的价值之和。这样一来我们将计算和判断的时间复杂度优化至 $\\Theta(n)$。 总时间复杂度为 $\\Theta(nlogn)$。 P.S. 在进行二维求和计算的时候，可以考虑用前缀和来优化，使得计算的时候时间复杂度下降一个 $n$（由 $\\Theta(n^{2})$ 到 $\\Theta(n)$）。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// Created by ZJYelizaveta on Monday, September 04, 2017 AM10:17:46 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 200000 + 3;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3fll;int n, m; ll S;int w[MAX_N], v[MAX_N];int l[MAX_N], r[MAX_N];ll cnt[MAX_N], sum[MAX_N];ll ans;inline bool check(int W) &#123; memset(cnt, 0, sizeof cnt); memset(sum, 0, sizeof sum); ll res = 0; // 前缀和优化 for (int i = 1; i &lt;= n; ++i) &#123; cnt[i] = cnt[i - 1], sum[i] = sum[i - 1]; if (w[i] &gt;= W) &#123; ++cnt[i]; sum[i] += v[i]; &#125; &#125;// printf(\"%d\\n\", W);// for (int i = 1; i &lt;= n; ++i) printf(\"%lld \", sum[i]); printf(\"\\n\");// for (int i = 1; i &lt;= n; ++i) printf(\"%lld \", cnt[i]); printf(\"\\n\"); for (int i = 1; i &lt;= m; ++i) &#123; res += (ll)(cnt[r[i]] - cnt[l[i] - 1]) * (sum[r[i]] - sum[l[i] - 1]); &#125; ans = min(ans, abs(S - res)); if (res &lt; S) return false; return true;&#125;int main()&#123; n = readIn(), m = readIn(); scanf(\"%lld\", &amp;S);// printf(\"%lld\\n\", S); int MAX = -INF; for (int i = 1; i &lt;= n; ++i) &#123; w[i] = readIn(), v[i] = readIn(); MAX = max(MAX, w[i]); &#125; for (int i = 1; i &lt;= m; ++i) l[i] = readIn(), r[i] = readIn(); ans = INFLL; int l = 0, r = MAX + 1; while (r - l &gt; 1) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) l = mid; else r = mid; &#125; printf(\"%lld\\n\", ans);// fprintf(stderr, \"Time used : %.3f\\n\", (double)clock() / CLOCKS_PER_SEC); return 0;&#125; 观光公交描述风景迷人的小城 Y 市，拥有 $n$ 个美丽的景点。由于慕名而来的游客越来越多，Y 市特意安排了一辆观光公交车，为游客提供更便捷的交通服务。观光公交车在第 $0$ 分钟出现在 $1$ 号景点,随后依次前往 $2,3,4, \\cdots , n$ 号景点。从第 $i$ 号景点开到第 $i+1$ 号景点需要 $D_{i}$ 分钟。任意时刻，公交车只能往前开，或在景点处等待。设共有 $m$ 个游客，每位游客需要乘车 $1$ 次从一个景点到达另一个景点，第 $i$ 位游客在$T_{i}$ 分钟来到景点 $A_{i}$ ，希望乘车前往景点 $B_{i} (A_{i} &lt;B_{i} )$。为了使所有乘客都能顺利到达目的地，公交车在每站都必须等待需要从该景点出发的所有乘客都上车后才能出发开往下一景点。假设乘客上下车不需要时间。一个乘客的旅行时间，等于他到达目的地的时刻减去他来到出发地的时刻。因为只有一辆观光车，有时候还要停下来等其他乘客，乘客们纷纷抱怨旅行时间太长了。于是聪明的司机 ZZ 给公交车安装了 $k$ 个氮气加速器，每使用一个加速器，可以使其中一个 $D_{i}$ 减 $1$。对于同一个 $D_{i}$ 可以重复使用加速器，但是必须保证使用后 $D_{i}$ 大于等于 $0$。那么 ZZ 该如何安排使用加速器，才能使所有乘客的旅行时间总和最小？ $1 \\leq n \\leq 1000, 1 \\leq m \\leq 10000, 0 \\leq k \\leq 100000, 0 \\leq D_{i} \\leq 100, 0 \\leq T_{i} \\leq 100000$ 分析模拟的时候没有什么思路，好像有点费用流的感觉（一定是我的错觉），但是还是只写了特判的 30 分，Sign 原来是 贪心 + 模拟 qwq 首先，我们可以先预处理出结点 $i$ 最晚出发的人的出发时间 $last[i]$ ，以及结点 $i$ 在不使用氮气加速的时候公交到达的时间 $arv[i]$ ，还有在第 $i$ 站下车的人数（对答案有贡献）。 这样我们可以计算出，在不使用氮气加速的时候，所有旅客的旅行时间之和： ans = \\sum_{i = 1}^{m}arv[b[i]] - t[i]因为 $t[i]$ 是不会改变的，如果我们想令 $ans$ 最小，那么我们需要最小化 $arv[b[i]]$ 。 如何可以最大化的最小化 $arv[b[i]]$ 呢？我们要使被影响的结点尽可能多，那么我们每一次 $\\Theta(n)$ 线性扫一次。 考虑对于结点 $i$ ，如果有 $arv[i + 1] &gt; last[i + 1]$ ，那么在这个时候我们在 $i$ 处使用氮气不仅对 $i + 1$ 这个结点有贡献还有可能对之后的结点也有贡献。 若 $arv[i + 1] \\leq last[i + 1]$ ，那么如果在 $i$ 处使用氮气，那么只会对 $i + 1$ 处产生贡献，因为在景点停靠等待使得后面的景点的到达时间依然没有改变。 因此，我们在 $i$ 处使用加速器对别的景点的贡献是可以递推出来的。 求出了在 $i$ 处使用加速器可以影响的最远的点，那么影响的总时间就等于在每个被影响的点下车的人数之和乘以使用加速器的数量，然后记得更新。 最后的答案为 ans = (\\sum_{i = 1}^{m}arv[b[i]] - t[i]) - maxDecrease代码特判 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Created by ZJYelizaveta on Monday, September 04, 2017 AM11:10:09 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int MAX_M = 10000 + 3;const int MAX_K = 100000 + 3;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3fll;int n, m, k;int d[MAX_N];int t[MAX_M], a[MAX_M], b[MAX_M];int arv[MAX_N], st[MAX_N];int ans;inline void solve1() &#123; ans = 0; memset(arv, 0, sizeof arv); memset(st, 0, sizeof st); for (int i = 1; i &lt;= m; ++i) st[a[i]] = max(st[a[i]], t[i]); arv[1] = st[1]; for (int i = 2; i &lt;= n; ++i) &#123; arv[i] = max(arv[i - 1], st[i - 1]) + d[i - 1]; &#125;// for (int i = 1; i &lt;= n; ++i) printf(\"%d \", st[i]); printf(\"\\n\");// for (int i = 1; i &lt;= n; ++i) printf(\"%d \", arv[i]); printf(\"\\n\"); for (int i = 1; i &lt;= m; ++i) ans += arv[b[i]] - t[i]; printf(\"%d\\n\", ans);&#125;inline void calculate(int x) &#123; int res = 0; for (int i = 2; i &lt;= x; ++i) &#123; arv[i] = max(arv[i - 1], st[i - 1]) + d[i - 1]; &#125; arv[x + 1] = max(arv[x], st[x]) + d[x] - 1; for(int i = x + 2; i &lt;= n; ++i) &#123; arv[i] = max(arv[i - 1], st[i - 1]) + d[i - 1]; &#125; for (int i = 1; i &lt;= m; ++i) res += arv[b[i]] - t[i];// printf(\"%d\\n\", res); ans = min(ans, res);&#125;inline void solve2() &#123; memset(arv, 0, sizeof arv); memset(st, 0, sizeof st); arv[1] = 0; for (int i = 1; i &lt;= m; ++i) st[a[i]] = max(st[a[i]], t[i]); arv[1] = st[1]; ans = INF; for (int i = 1; i &lt;= n - 1; ++i) calculate(i); printf(\"%d\\n\", ans);&#125;int main()&#123; n = readIn(), m = readIn(), k = readIn(); for (int i = 1; i &lt;= n - 1; ++i) d[i] = readIn(); for (int i = 1; i &lt;= m; ++i) t[i] = readIn(), a[i] = readIn(), b[i] = readIn(); if (k == 0) solve1(); else if (k == 1) solve2(); return 0;&#125; $100 \\%$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int MAX_M = 10000 + 3;const int MAX_K = 100000 + 3;const ll INF = 0x3f3f3f3f3f3f3f3fll;ll n, m, k;ll d[MAX_N];ll t[MAX_M], a[MAX_M], b[MAX_M];ll last[MAX_N], arv[MAX_N], sum[MAX_N];ll cntPerson, numK, from, to;ll ans;inline void prepare() &#123; for (int i = 2; i &lt;= n; i++) arv[i] = max(arv[i - 1], last[i - 1]) + d[i - 1]; for (int i = 2; i &lt;= n; i++) sum[i] += sum[i - 1]; for (int i = 1; i &lt;= m; i++) ans += arv[b[i]] - t[i];// for (int i = 1; i &lt;= n; ++i) printf(\"%d %lld\\n\", i, last[i]);// for (int i = 1; i &lt;= n; ++i) printf(\"%d %lld\\n\", i, sum[i]);// for (int i = 1; i &lt;= n; ++i) printf(\"%d %lld\\n\", i, arv[i]);// printf(\"%d\\n\", ans);&#125;inline bool find() &#123; ll curK = INF, pos = n; cntPerson = 0, numK = INF; for (int i = n - 1; i &gt;= 1; --i) &#123; if (arv[i + 1] &gt; last[i + 1]) curK = min(curK, arv[i + 1] - last[i + 1]); else &#123; curK = arv[i + 1]; // the max number we can decrease pos = i + 1; &#125; if (d[i] &amp;&amp; sum[pos] - sum[i] &gt; cntPerson) &#123; cntPerson = sum[pos] - sum[i]; from = i; to = pos; numK = min(k, min(curK, d[i])); &#125; &#125; return numK;&#125;inline void calculate() &#123; for (int i = from + 1; i &lt;= to; ++i) arv[i] -= numK; k -= numK; d[from] -= numK; ans -= cntPerson * numK;&#125;inline void solve() &#123; while (find()) calculate(); printf(\"%lld\\n\", ans);&#125;int main()&#123;// freopen(\"testdata.in\", \"r\", stdin); n = readIn&lt;ll&gt;(), m = readIn&lt;ll&gt;(), k = readIn&lt;ll&gt;(); for (int i = 1; i &lt;= n - 1; ++i) d[i] = readIn&lt;ll&gt;(); for (int i = 1; i &lt;= m; ++i) &#123; t[i] = readIn&lt;ll&gt;(), a[i] = readIn&lt;ll&gt;(), b[i] = readIn&lt;ll&gt;(); ++sum[b[i]]; last[a[i]] = max(last[a[i]], t[i]); &#125; prepare(); solve(); return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"NOIP","slug":"NOIP","permalink":"http://yoursite.com/tags/NOIP/"},{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"},{"name":"dfs","slug":"dfs","permalink":"http://yoursite.com/tags/dfs/"},{"name":"二分","slug":"二分","permalink":"http://yoursite.com/tags/二分/"}]},{"title":"Hello World!","slug":"hello-world","date":"2017-10-22T03:03:05.806Z","updated":"2017-09-08T15:29:58.716Z","comments":true,"path":"2017/10/22/hello-world/","link":"","permalink":"http://yoursite.com/2017/10/22/hello-world/","excerpt":"I’m an OIer.来自武汉二中，现役高二 QAQ","text":"I’m an OIer.来自武汉二中，现役高二 QAQ 习惯Blog上的第一篇文章写 Hello World12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; cout &lt;&lt; \"Hello World!\" &lt;&lt; endl; return 0;&#125; 我一直相信一句话：“无论你遇见谁，他都是你生命里该出现的人，绝非偶然，他一定会教会你一些什么。”所以我也相信：“无论我走到哪里，那都是我该去的地方，经历一些我该经历的事，遇见我该遇见的人。”","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"「BZOJ 2301」「HAOI2011」Problem b","slug":"「BZOJ-2301」「HAOI2011」Problem-b","date":"2017-09-28T07:44:48.000Z","updated":"2017-10-21T08:43:09.845Z","comments":true,"path":"2017/09/28/「BZOJ-2301」「HAOI2011」Problem-b/","link":"","permalink":"http://yoursite.com/2017/09/28/「BZOJ-2301」「HAOI2011」Problem-b/","excerpt":"题目地址 描述对于给出的 $n$ 个询问，每次求有多少个数对 $(x,y)$，满足 $a \\leq x \\leq b$，$c \\leq y \\leq d$，且 $gcd(x,y) = k$。$gcd(x,y)$ 函数为 $x$ 和 $y$ 的最大公约数。 $1 \\leq n\\leq50000，1\\leq a\\leq b\\leq 50000，1\\leq c \\leq d\\leq 50000，1\\leq k \\leq 50000$","text":"题目地址 描述对于给出的 $n$ 个询问，每次求有多少个数对 $(x,y)$，满足 $a \\leq x \\leq b$，$c \\leq y \\leq d$，且 $gcd(x,y) = k$。$gcd(x,y)$ 函数为 $x$ 和 $y$ 的最大公约数。 $1 \\leq n\\leq50000，1\\leq a\\leq b\\leq 50000，1\\leq c \\leq d\\leq 50000，1\\leq k \\leq 50000$ 分析这是一个计算满足 gcd(i, j) = k 的 i, j 个数的题目，这样的模型经常出现。 这里我们默认 $n \\leq m$，如果不满足就交换。令 $f(k)$ 为 $gcd(i, j) = k$ 的个数，$g(k)$ 为 $k \\mid gcd(i, j)$ 的个数。 那么有以下关系：g(k) = \\sum_{d = 1}^{\\left \\lfloor \\frac{n}{k} \\right \\rfloor}f(d \\times k)我们需要求 $f(k)$，通过反演我们得到： f(k) = \\sum_{d = 1}^{\\left \\lfloor \\frac{n}{k} \\right \\rfloor}g(d \\times k)\\mu(d)那么这里的瓶颈就是如何快速求出 $g(d \\times k)$，首先考虑如何快速求出 $g(k)$，因为 $i = k \\times x_{1}, j = k \\times y_{1}$，我们只需要求出来有多少对满足条件的 $x_{1}, y_{1}$，即可求出 $g(k)$，因此有： g(k) = \\left \\lfloor \\frac{n}{k} \\right \\rfloor\\left \\lfloor \\frac{m}{k} \\right \\rfloor那么原式可改写为：f(k) = \\sum_{d = 1}^{\\left \\lfloor \\frac{n}{k} \\right \\rfloor}\\mu(d)\\left \\lfloor \\frac{n}{kd} \\right \\rfloor\\left \\lfloor \\frac{m}{kd} \\right \\rfloor我们可以暴力计算在 $\\Theta(n + T\\frac{n}{k})$ 的时间内算出来，但是时间复杂度仍然太高，考虑如何降低时间复杂度。 如之前所说，算法的瓶颈在于如何快速计算 $g(d \\times k)$，这里可以用 分块 来解决。 如图所示，是 $n = 32, m = 40, k = 2$ 的 $\\left \\lfloor \\frac{n}{dk} \\right \\rfloor,\\left \\lfloor \\frac{m}{dk} \\right \\rfloor, \\mu(d)$ 的取值。 $1 \\leq d \\leq \\sqrt n$，$d$ 最多有 $\\sqrt n$ 个取值，$\\left \\lfloor \\frac{n}{d} \\right \\rfloor$ 最多有 $\\left \\lfloor \\sqrt n \\right \\rfloor$ 个不同的取值。 $\\sqrt n + 1 \\leq d \\leq n$，$\\left \\lfloor \\frac{n}{d} \\right \\rfloor \\leq \\left \\lfloor \\sqrt n \\right \\rfloor$，所以 $\\left \\lfloor \\frac{n}{d} \\right \\rfloor$ 最多有 $\\left \\lfloor \\sqrt n \\right \\rfloor$ 个取值。 综上所述，$\\left \\lfloor \\frac{n}{d} \\right \\rfloor$ 最多有 $2 \\left \\lfloor \\sqrt n \\right \\rfloor$ 个取值。那么我们可以最多分为 $2 \\left \\lfloor \\frac{n}{dk} \\right \\rfloor + 2 \\left \\lfloor \\frac{m}{dk} \\right \\rfloor$ 段来计算。 总时间复杂度 $\\Theta(T(\\sqrt n + \\sqrt m))$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// Created by ZJYelizaveta on Thursday, September 28, 2017 PM02:17:53 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;template&lt;typename T&gt; T readIn() &#123; T x(0), f(1); char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 50000 + 3;const int INF = 0x3f3f3f3f;int testCase;int prime[MAX_N], mu[MAX_N], sum[MAX_N], cnt = 0;bool isNotPrime[MAX_N];inline void sieve() &#123; memset(prime, 0, sizeof prime); memset(mu, 0, sizeof mu); memset(isNotPrime, false, sizeof isNotPrime); mu[1] = 1, isNotPrime[0] = isNotPrime[1] = true; for (register int i = 2; i &lt; MAX_N; ++i) &#123; if (!isNotPrime[i]) &#123; prime[++cnt] = i; mu[i] = -1; &#125; for (register int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt; MAX_N; ++j) &#123; isNotPrime[i * prime[j]] = true; if (i % prime[j] == 0) &#123; mu[i * prime[j]] = 0; break; &#125; else mu[i * prime[j]] = -mu[i]; &#125; &#125;// for (int i = 1; i &lt;= 12; ++i) printf(\"%d \", mu[i]); printf(\"\\n\"); sum[0] = 0; for (register int i = 1; i &lt; MAX_N; ++i) sum[i] = sum[i - 1] + mu[i];// for (int i = 1; i &lt;= 12; ++i) printf(\"%d \", sum[i]); printf(\"\\n\");&#125;inline int solve(int n, int m, int k) &#123; if (n &gt; m) swap(n, m); n /= k, m /= k; int last = 0, ans = 0; for (register int i = 1; i &lt;= n; i = last + 1) &#123; last = min((n / (n / i)), (m / (m / i))); ans += (sum[last] - sum[i - 1]) * (n / i) * (m / i); // &#125; return ans;&#125;int main()&#123; sieve(); testCase = readIn&lt;int&gt;(); while (testCase--) &#123; int a = readIn&lt;int&gt;(), b = readIn&lt;int&gt;(), c = readIn&lt;int&gt;(), d = readIn&lt;int&gt;(), k = readIn&lt;int&gt;(); int ans = solve(b, d, k) - solve(a - 1, d, k) - solve(b, c - 1, k) + solve(a - 1, c - 1, k); printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"http://yoursite.com/tags/莫比乌斯反演/"}]},{"title":"线性规划与网络流24题 Part 3","slug":"线性规划与网络流24题-Part-3","date":"2017-09-21T05:31:51.000Z","updated":"2017-10-22T03:17:31.588Z","comments":true,"path":"2017/09/21/线性规划与网络流24题-Part-3/","link":"","permalink":"http://yoursite.com/2017/09/21/线性规划与网络流24题-Part-3/","excerpt":"最后一部分！","text":"最后一部分！ 「网络流 24 题」负载平衡 - 19转化为最小代价供求问题，用最小费用最大流解决。 计算出每个仓库的盈余后，可以把问题转化为供求问题。建立供求网络，把$A$集合中所有结点看做供应节点，$B$集合所有节点看做需求结点，在能一次搬运满足供需的$A_{i}$和$B_{j}$之间连接一条费用为$1$的有向边，表示搬运一个单位货物费用为$1$。另外还要在$A_{i}$与相邻的$A_{j}$之间连接边，表示货物可以暂时搬运过去，不立即满足需求，费用也为$1$。（转自 hzwer） 因此可以建出如下的图： 首先求出$equal = \\frac{\\sum_{i = 1}^{n}w[i]}{n}$的值，每一个仓库有一个$a[i]$，令$a[i] = w[i] - equal$ 将一个仓库拆分为两个点，分别代表这个仓库可以输出的货流量$A$集合，仓库需要的货流量$B$集合 建立超级源点$s$，若$a[i] &gt; 0$，从$s$向$A_{i}$连一条容量为$a[i]$，费用为$0$的边 建立超级源点$t$，若$a[i] &lt; 0$，从$A_{i}$向$t$连一条容量为$-a[i]$，费用为$0$的边 $A$集合中的点$A_{i}$向其相邻的点$B_{i + 1},B_{i - 1},A_{i - 1}, A_{i + 1}$（$0 \\leq i &lt; n$）连一条容量为$\\infty$，费用为$1$的边 最小费用最大流，最小费用流值就是最少搬运量 「网络流 24 题」深海机器人问题 - 20多出发点和目的地的网络运输问题 由于“多个深海机器人可以在同一时间占据同一位置”，所以不需限制点的流量，不用拆点。而且，每条边的价值只能计算一次，容量限制要设为$1，$同时还将要连接上容量不限，费用为0的重边。 把网格中每个位置抽象成网络中一个结点 建立超级源点$s$，从点$s$到每个出发点$i$连接一条容量为该点出发的机器人数量，费用为$0$的边 建立超级源点$t$，从每个目标点$i$到$t$连一条容量为可以到达该点的机器人数量，费用为$0$的边 对于每个顶点$i$，若$j$为$i$东边或南边相邻的一个结点，从结点$i$向结点$j$连一条容量为 $1$，费用为该边价值的边 对于每个顶点 $i$，若 $j$ 为 $i$ 东边或南边相邻的一个结点，从结点$i$向结点$j$一条容量为$\\infty$，费用为$0$的边 最大费用最大流，答案为采集到的生物标本的最高总价值 「网络流 24 题」最长 k 可重区间集问题 - 21这个问题可以看做是求$k$条权之和最大的不相交路径，每条路径为一些不相交的区间序列。由于是最大费用流，两条路径之间一定有一些区间相交，可以看做是相交部分重复了$2$次，而$k$条路经就是最多重复了$k$次。最简单的想法就是把区间排序后，不相交的区间之间连接一条边，由于每个区间只能用一次，所以要拆点，点内限制流量。如果我们改变一下思路，把端点作为网络中的顶点，区间恰恰是特定一些端点之间的边，这样建模的复杂度更小。转自 hzwer 建模方法如下： 离散化所有区间的端点，把每个端点看做一个顶点，建立超级源点$s$和超级汇点$t$ 从$s$到顶点$1$（最左边顶点）连接一条容量为$k$，费用为$0$的边 从顶点$2n$（最右边顶点）到$t$连接一条容量为$k$，费用为$0$的边 从顶点$i$到顶点$i+1(i+1 \\leq 2n)$，连接一条容量为$\\infty$，费用为$0$的边 对于每个区间$[a,b]$，从$a$对应的顶点$i$到$b$对应的顶点$j$连接一条容量为$1$，费用为区间长度的有向边。 求最大费用最大流，最大费用流值就是最长k可重区间集的长度。 「网络流 24 题」最长 k 可重线段集问题 - 22依然是最大权不相交路径转化成为最小费用最大流问题。建图方法同 “ 最长 k 可重区间集问题 - 21 “，这里不再赘述了由于$COGS$上的数据有问题，所以这道题目无法评测QAQ 「网络流 24 题」火星探险问题 - 23在$\\text{COGS}$好像没有找到，有哪位大佬可以告诉我在哪里可以交这道题目吗QAQ 「网络流 24 题」骑士共存问题 - 24最大独立集问题同 “ 「网络流 24 题」方格取数 - 9 “ ，首先进行黑白交替染色，显然棋盘变成了一个二分图。然后对于没有障碍物的地方向骑士可以到达的地方连边(连双向边)，然后跑一遍网络流，最后答案等于点数减去最大匹配数。 代码「网络流 24 题」负载平衡 - 19123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// Created by ZJYelizaveta on Monday, August 21, 2017 AM10:41:54 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int MAXNODE = 200 + 3;const int INF = 0x3f3f3f3f;int n;int a[MAX_N], b[MAX_N];namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int dist[MAXNODE]; int prevV[MAXNODE], prevE[MAXNODE]; bool inq[MAXNODE]; inline void clear() &#123; for (int i = 0; i &lt;= MAXNODE; ++i) G[i].clear(); &#125; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow(int s, int t) &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, false, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s); inq[s] = true, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = false; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123;// dist[e.to] = dist[u] + e.cost; prevE[e.to] = i; prevV[e.to] = u; if (!inq[e.to]) &#123; inq[e.to] = true;// if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to); else q.push_front(e.to); &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second += flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;int main()&#123; n = readIn(); int sum = 0, equal = 0; for (int i = 1; i &lt;= n; ++i) a[i] = readIn(), sum += a[i]; equal = sum / n; for (int i = 1; i &lt;= n; ++i) b[i] = a[i] - equal; int s = 0, t = 2 * n + 1; for (int i = 1; i &lt;= n; ++i) if (b[i] &gt; 0) addEdge(s, i, b[i], 0); for (int i = 1; i &lt;= n; ++i) if (b[i] &lt; 0) addEdge(i + n, t, -b[i], 0); for (int i = 1; i &lt;= n; ++i) &#123; if (i != 1) &#123; addEdge(i, i - 1, INF, 1), addEdge(i, i - 1 + n, INF, 1); &#125; if (i != n) &#123; addEdge(i, i + 1, INF, 1), addEdge(i, i + 1 + n, INF, 1); &#125; &#125; addEdge(n, 1, INF, 1), addEdge(n, n + 1, INF, 1); addEdge(1, n, INF, 1), addEdge(1, n + n, INF, 1); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", ans.second); return 0;&#125; 「网络流 24 题」深海机器人问题 - 20123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// Created by ZJYelizaveta on 2017年08月24日 星期四 22时35分18秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAXNODE = 1000 + 3;const int INF = 0x3f3f3f3f;int a, b;int p, q;namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int dist[MAXNODE]; int prevV[MAXNODE], prevE[MAXNODE]; bool inq[MAXNODE]; inline void clear() &#123; for (int i = 0; i &lt;= MAXNODE; ++i) G[i].clear(); &#125; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow(int s, int t) &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, false, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s); inq[s] = true, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = false; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123;// dist[e.to] = dist[u] + e.cost; prevE[e.to] = i; prevV[e.to] = u; if (!inq[e.to]) &#123; inq[e.to] = true;// if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to); else q.push_front(e.to); &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second += flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;int main()&#123; freopen(\"shinkai.in\", \"r\", stdin); freopen(\"shinkai.out\", \"w\", stdout); a = readIn(), b = readIn(); p = readIn() + 1, q = readIn() + 1; int s = 0, t = p * q + 1; for (int i = 0; i &lt; p; ++i) &#123; for (int j = 1; j &lt; q; ++j) &#123; int c = readIn(); int u = i * q + j, v = u + 1; addEdge(u, v, 1, -c); addEdge(u, v, INF, 0); &#125; &#125; for (int j = 1; j &lt;= q; ++j) &#123; for (int i = 0; i &lt;= p - 2; ++i) &#123; int c = readIn(); int u = i * q + j, v = u + q; addEdge(u, v, 1, -c); addEdge(u, v, INF, 0); &#125; &#125; for (int i = 1; i &lt;= a; ++i) &#123; int c = readIn(), x = readIn(), y = readIn(); addEdge(s, x * q + y + 1, c, 0); &#125; for (int i = 1; i &lt;= b; ++i) &#123; int c = readIn(), x = readIn(), y = readIn(); addEdge(x * q + y + 1, t, c, 0); &#125; pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", -ans.second); return 0;&#125; 「网络流 24 题」最长 k 可重区间集问题 - 21123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// Created by ZJYelizaveta on Monday, August 21, 2017 PM01:53:40 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 500 + 3;const int MAXNODE = 1000 + 3;const int INF = 0x3f3f3f3f;int n, k;int l[MAX_N], r[MAX_N];namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int dist[MAXNODE]; int prevE[MAXNODE], prevV[MAXNODE]; bool inq[MAXNODE]; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow(int s, int t) &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, false, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s); inq[s] = true, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = false; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123; dist[e.to] = dist[u] + e.cost; prevV[e.to] = u; prevE[e.to] = i; if (!inq[e.to]) &#123; inq[e.to] = true; if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to); else q.push_front(e.to); &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second += flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;vector&lt;int&gt; vec;map&lt;int, int&gt; mp;int main()&#123; n = readIn(), k = readIn(); for (int i = 1; i &lt;= n; ++i) &#123; l[i] = readIn(), r[i] = readIn(); if (l[i] &gt; r[i]) swap(l[i], r[i]); vec.push_back(l[i]), vec.push_back(r[i]); &#125; sort(vec.begin(), vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end());// int m = vec.size(); int s = m, t = m + 1; addEdge(s, 0, k, 0), addEdge(m - 1, t, k, 0); for (int i = 0; i &lt; m; ++i) &#123; mp[vec[i]] = i; if (i + 1 &lt; m) addEdge(i, i + 1, INF, 0); &#125; for (int i = 1; i &lt;= n; ++i) addEdge(mp[l[i]], mp[r[i]], 1, l[i] - r[i]); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", -ans.second); return 0;&#125; 「网络流 24 题」最长 k 可重线段集问题 - 22「网络流 24 题」火星探险问题 - 23「网络流 24 题」骑士共存问题 - 24123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// Created by ZJYelizaveta on 2017骞?8鏈?5鏃 鏄熸湡浜 08鏃?0鍒?8绉// Copyright (c) 2017骞 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 200 + 3;const int MAXNODE = 400000 + 3;const int INF = 0x3f3f3f3f;const int dx[] = &#123;2, 1, -1, -2, -2, -1, 1, 2&#125;;const int dy[] = &#123;1, 2, 2, 1, -1, -2, -2, -1&#125;;int n, m;int a[MAX_N][MAX_N];int s, t, ans;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int iter[MAXNODE], level[MAXNODE]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; queue&lt;int&gt; q; memset(level, -1, sizeof level); q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if(u == t) return flow;// for (int &amp;i = iter[u]; i &lt; G[u].size(); i++) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(flow, e.cap)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int flow = 0, d = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while(d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;inline int ID(int x, int y) &#123; return (y - 1) * n + x;&#125;int main()&#123; freopen(\"knight.in\", \"r\", stdin); freopen(\"knight.out\", \"w\", stdout); n = readIn(), m = readIn(); s = 0, t = n * n + 1, ans = n * n; memset(a, 0, sizeof a); for (int i = 1; i &lt;= m; ++i) &#123; a[readIn()][readIn()] = 1; --ans; &#125; for (int j = 1; j &lt;= n; ++j) for (int i = 1; i &lt;= n; ++i) if (!a[i][j]) &#123; if ((i + j) &amp; 1) &#123; addEdge(s, ID(i,j), 1); for (int k = 0; k &lt;= 7; ++k) &#123; int x = i + dx[k], y = j + dy[k]; if (1 &lt;= x &amp;&amp; x &lt;= n &amp;&amp; 1 &lt;= y &amp;&amp; y &lt;= n &amp;&amp; !a[x][y]) addEdge(ID(i, j), ID(x, y), INF); &#125; &#125; else addEdge(ID(i,j), t, 1); &#125; ans -= maxFlow(s, t); printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/费用流/"},{"name":"最大权闭合图","slug":"最大权闭合图","permalink":"http://yoursite.com/tags/最大权闭合图/"},{"name":"最小割","slug":"最小割","permalink":"http://yoursite.com/tags/最小割/"},{"name":"最大独立集","slug":"最大独立集","permalink":"http://yoursite.com/tags/最大独立集/"},{"name":"分层图","slug":"分层图","permalink":"http://yoursite.com/tags/分层图/"}]},{"title":"线性规划与网络流24题 Part 2","slug":"线性规划与网络流24题-Part-2","date":"2017-09-21T05:31:40.000Z","updated":"2017-09-21T06:37:31.366Z","comments":true,"path":"2017/09/21/线性规划与网络流24题-Part-2/","link":"","permalink":"http://yoursite.com/2017/09/21/线性规划与网络流24题-Part-2/","excerpt":"失踪人口回归！","text":"失踪人口回归！ 「网络流 24 题」方格取数 - 9建图太神啦QAQ二分图点权最大独立集，转化为最小割模型，从而用最大流解决。贴几个结论和定义，如果不知道可以看一下 最小点权覆盖集：满足每一条边的两个端点至少选一个的最小权点集。最大点权独立集：满足每一条边的两个端点最多选一个的最大权点集。最小点权覆盖 = 原图最小割最大点权独立集 = 总点权 - 最小点权覆盖 = 总点权 - 最小割 = 总点权 - 最大流 我们将棋盘黑白染色，发现只有不同颜色的格子，是不能同时选择的。将每个格子看作一个点，如果我们将有冲突的格子之间连边的话，会发现这是一个二分图。 我们将染成黑色的格子归为$A$集合，染成白色的格子归为$B$集合 建立超级源点$s$连向$A$集合中的每一个点，边的容量为格子中的数值; 建立超级汇点$t$，$B$集合中的每一个点向$t$连一条容量为格子中数值中的边 对于一个染成黑色的格子，向与它相邻的白色格子连一条容量为$INF$的边 $ans = sum - maxFlow(s, t)$ 我们可以发现，我们需要求出最小的流量使得$A$集合与$B$集合不联通，相当于求此图的最小割，而此图的最小割就是原图的最小点权覆盖集，二分图最小点权覆盖集的补集就是二分图的最大点权独立集。 「网络流 24 题」餐巾计划 - 10开始做费用流的题目啦QAQ这个问题的主要约束条件是每天的餐巾够用，经过分析可以把每天要用的和用完的分离开处理，建模后就是二分图。二分图$A$集合中顶点$A_{i}$表示第$i$天用完的餐巾，其数量为$r_{i}$，所以从$s$向$A_{i}$连接容量为$r_{i}$的边作为限制。$B$集合中每个点$B_{i}$则是第$i$天需要的餐巾，数量为$r_{i}$，与$t$连接的边容量作为限制。 具体建模型方法如下: 将每一天拆分为$A$集合中的顶点$A_{i}$和$B$集合中的顶点$B_{i}$ 建立超级源点$s$向$A$集合中的每一个点连一条容量为$r_{i}$，费用为$0$的边 ; 建立超级源点$t$，$B$集合中的每一个点向$t$连一条容量为$r_{i}$，费用为$0$的边 新购买餐巾，从$s$向$B$集合中的每一个点连一条容量$\\infty$，费用为$p$的边。 每天用完的餐巾可以选择留到下一天，从每个$A_{i}$向$A_{i+1}(i+1 \\leq N)$连一条容量为$\\infty$，费用为$0$的边。 送到快洗部，从每个$A_{i}$向$B_{i+m}(i+m \\leq N)$连一条容量为$\\infty$，费用为$f$的边。 送到慢洗部，从每个$A_{i}$向$B{i+n}(i+n \\leq N)$连一条容量为$\\infty$，费用为$s$的有向边。 「网络流 24 题」航空路线问题 - 11LOJ上最后一道网络流，脑抽了，调了很久的输出方案QAQ建模如下: 将每个点拆分为两个集合，$A$集合和$B$集合 从$A$集合的$A_{i}$向$B$集合中的$B_{i}$连一条容量为$1$费用为$-1$的边$(1 &lt; i &lt; n)$ 从$A_{1}$向$B_{1}$连一条容量为$2$,费用为$-1$的边 从$A_{n}$向$B_{n}$连一条容量为$2$,费用为$-1$的边 如果存在边$(i,j), i&lt;j$，那么从$B_{i}$向$A_{j}$连一条容量$1$,费用为$0$的边 跑一遍最小费用最大流，若$A_{1} \\sim B_{1}$满流，则存在解，否则无解 「网络流 24 题」软件补丁 - 12通过状压转换成为最短路问题 好像跟[CTSC 1999]补丁VS错误这道题目是一样的但是当时没意识到这是一个费用流的题QAQ，然后按照原来的写了一遍交上去，结果跑得贼慢，然后虚心的学习了一下别人的代码，发现，诶怎么不用加边呀QAQ 我们可以肯定最多只有$2^{n}$种错误情况 ( 若这是第$i$个错误则用二进制表示时这一位为$0$ )，初始状态为$2^{n}−1$， 最后要求达到的状态是$0$。进一步我们发现$n$实际上很小，可以状压，那么可以想到用二进制来表示出所有的错误情况。但是实际上根本不用建图呀，每一次判断当前的补丁是否可用 (和是否加边的判断是一样的) ，然后状压跑一遍$SPFA$就行了QAQ 「网络流 24 题」星际转移问题 - 13真的贼难调QAQ，需要按照时间来拆点，见识了 我们把网络优化问题转化为枚举答案 $+$可行性判定问题。枚举天数，按天数把图分层，因为乘船每坐一站天数都要增加$1$，把太空船航线抽象成图中的一条边，跨图的两层。由于太空船容量有限，边上也要加上容量限制。除了坐船以外，人还可以在某个空间站等待下一班太空船的到来，所以每个点要与下一层同一点连接一条容量为$\\infty$的边。这样在层限制的图上求出的网络最大流就是在当前天数以内能够从地面到月球的最多的人数，该人数随天数递增不递减，存在单调性。所以可以枚举答案或二分答案，用网络流判定。网络流判定问题更适合枚举答案，而不是二分，因为新增一些点和边只需要在原有的基础上增广，不必重新求网络流。（转自 Byvoid） 首先判断地球到月球之间是否存在一条可行道路，若不存在，那么无解；否则把每一个太空站按照天数拆分成为$d$个点，$[i, d]$表示第$i$个站第$d$天。建立超级源点$s$和超级汇点$t$，并顺序枚举天数（网络流相比二分更适合顺序枚举） 对于第$d$天，从$s$向$[0, d]$连一条容量为$\\infty$的边。 对于第$d$天，从$[-1, d]$向$t$连一条容量为$\\infty$的边 对于第$i$艘飞船，令其第$d - 1$天在$a$处，第$d$天在$b$处，则从$[a, d - 1]$向$[b, d]$连一条容量为该太空飞船容量的边 对于第$i$个太空站，从$[i, d - 1]$向$[i, d]$连一条容量为$\\infty$的边 求最大流，若$ans = k$则停止枚举，那么当前的$d$就为答案 「网络流 24 题」孤岛营救问题 - 14转化为分层图最短路问题。 用一个$p$位二进制串表示当前获得的钥匙状态(若获得则二进制串中的这一位为$1$)，那么我们需要建立$2^{p}$层图。每层图表示在当前钥匙状态下的地图，每获得一把钥匙进入新的一层，然后i跑一次最短路即可。分层图最短路可以看这一个BZOJ 2763: [JLOI2011]飞行路线 「网络流 24 题」汽车加油行驶问题 - 15依然是分层图最短路QAQ 「网络流 24 题」数字梯形 - 16最大权不相交路径问题转化为最大费用最大流模型 梯形的顶至底的$m$条路径互不相交，说明了每个点只能经过一次，所以这里限制条件就是点，建图方法如下 : 将一个点拆分为两个点一个在$A$集合，一个在$B$集合(限制点流量) 建立超级源点$s$向梯形顶层每一个在合中的点连一条容量为$1$，费用为$0$的边 建立超级汇点$t$，从梯形底层每一个在$B$集合中的点向$t$连一条容量为$1$，费用为$0$的边 $A_{i, j}$向$B_{i, j}$连一条容量为$1$，费用为当前该点在数字梯形中对应的权值(这里权值取负)的边 从$B_{i, j}$向$A_{i + 1, j}$，$A_{i + 1, j + 1}$连一条容量为$1$，费用为$0$的边 跑一遍最小费用最大流，答案取反 梯形的顶至底的 $m$条路径仅在数字结点处相交，这时点上没有任何限制，而限制在边 建立超级源点$s$向梯形顶层每一个在$A$集合中的点连一条容量为$1$，费用为$0$的边 建立超级汇点$t$，从梯形底层每一个在$A$集合中的点向$t$连一条容量为$\\infty$，费用为$0$的边 $A_{i, j}$向$B_{i, j}$连一条容量为$\\infty$，费用为当前该点在数字梯形中对应的权值(这里权值取负)的边 从$B_{i, j}$向$A_{i + 1, j}$，$A_{i + 1, j + 1}$连一条容量为$1$，费用为$0$的边(限制边流量) 跑一遍最小费用最大流，答案取反 梯形的顶至底的$m$条路径允许在数字结点相交或边相交，这时点边都没有限制 建立超级源点$s$向梯形顶层每一个在合中的点连一条容量为$1$，费用为$0$的边 建立超级汇点$t$，从梯形底层每一个在$A$集合中的点向$t$连一条容量为$\\infty$，费用为$0$的边 $A_{i, j}$向$B_{i, j}$连一条容量为$\\infty$，费用为当前该点在数字梯形中对应的权值(这里权值取负)的边 从$B_{i, j}$向$A_{i + 1, j}$，$A_{i + 1, j + 1}$连一条容量为$\\infty$，费用为$0$的边 跑一遍最小费用最大流，答案取反 「网络流 24 题」运输问题 - 17费用流问题裸题QAQ建模方法一如既往的很套路： $m$ 个仓库做为$A$集合， $n$个零售商店做为$B$集合。 建立超级源点$s$向$A$集合中的每一个点连一条容量为$a[i]$，费用为$0$的边；建立超级汇点$t$，$B$集合中的每一个点向$t$连一条容量为$b[i]$，费用为$0$的边。 从$A$集合中的点$A_{i}$向$B$集合中的点$B_{j}$连一条容量为$\\infty$，费用为$c[i][j]$的边 最小总效益跑一遍最小费用最大流，最大总效益跑一遍最大费用最大流（与$16$题一样，把费用取负就可以了）。 「网络流 24 题」分配问题 - 18和$17$题一样还是费用流问题裸题QAQ建模方法一如既往的很套路： $n$ 个人做为$A$集合， $n$个任务做为$B$集合。 建立超级源点$s$向$A$集合中的每一个点连一条容量为$1$，费用为$0$的边；建立超级汇点$t$，$B$集合中的每一个点向$t$连一条容量为$1$，费用为$0$的边。 从$A$集合中的点$A_{i}$向$B$集合中的点$B_{j}$连一条容量为$\\infty$，费用为$c[i][j]$的边 最小总效益跑一遍最小费用最大流，最大总效益跑一遍最大费用最大流（与$16$题一样，把费用取负就可以了）。 代码「网络流 24 题」方格取数 - 9123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113// Created by ZJYelizaveta on 2017年08月18日 星期五 19时52分22秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 900 + 3;const int MAX_M = 30 + 3;const int INF = 0x3f3f3f3f;int m, n; // hang, lieint s, t;int a[MAX_M][MAX_M];int ans, sum;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1]; int iter[MAX_N &lt;&lt; 1], level[MAX_N &lt;&lt; 1]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(e.cap, flow)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int d = 0, flow = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;inline int getId(int x, int y) &#123; return (x - 1) * m + y;&#125;int main()&#123; n = readIn(), m = readIn(); s = 0, t = n * m + 1; int cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; int num = readIn(); sum += num; int curId = getId(i, j);// printf(\"%d\\n\", curId); bool flag = (i + j) &amp; 1; if (flag) addEdge(s, curId, num); else addEdge(curId, t, num); if (flag) &#123; if (i - 1 &gt;= 1) addEdge(curId, getId(i - 1, j), INF); if (i + 1 &lt;= n) addEdge(curId, getId(i + 1, j), INF); if (j - 1 &gt;= 1) addEdge(curId, getId(i, j - 1), INF); if (j + 1 &lt;= m) addEdge(curId, getId(i, j + 1), INF); &#125; &#125; &#125; ans = maxFlow(s, t); printf(\"%d\\n\", sum - ans);&#125; 「网络流 24 题」餐巾计划 - 1012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// Created by ZJYelizaveta on 2017年08月19日 星期六 23时01分39秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int INF = 0x3f3f3f3f;namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1]; int dist[MAX_N &lt;&lt; 1]; int prevV[MAX_N &lt;&lt; 1], prevE[MAX_N &lt;&lt; 1]; bool inq[MAX_N &lt;&lt; 1]; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow(int s, int t) &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, 0, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s), inq[s] = 1, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = 0;// for (int i = 0; i &lt; (int)G[u].size(); i++)&#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123; dist[e.to] = dist[u] + e.cost; prevE[e.to] = i; prevV[e.to] = u; if (!inq[e.to]) &#123;// inq[e.to] = 1; if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to);// else q.push_front(e.to);// &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second += flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;int main()&#123; int n = readIn(), P = readIn(), M = readIn(), F = readIn(), N = readIn(), S = readIn(); int s = 0, t = 2 * n + 1; for (int i = 1; i &lt;= n; ++i) &#123; int r = readIn(); addEdge(s, i + n, r, 0); addEdge(i, t, r, 0); addEdge(s, i, INF, P); if (i + 1 &lt;= n) addEdge(i + n, i + n + 1, INF, 0); if (i + M &lt;= n) addEdge(i + n, i + M, INF, F); if (i + N &lt;= n) addEdge(i + n, i + N, INF, S); &#125; pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", ans.second); return 0;&#125; 「网络流 24 题」航空路线问题 - 11123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129// Created by ZJYelizaveta on 2017年08月23日 星期三 22时19分32秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int MAXNODE = 200 + 3;const int INF = 0x3f3f3f3f;int n, m;int s, t;char str[MAX_N][15 + 3], s1[15 + 3], s2[15 + 3];map&lt;string, int&gt; M;namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int dist[MAXNODE]; int prevV[MAXNODE], prevE[MAXNODE]; bool inq[MAXNODE]; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow() &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, false, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s); inq[s] = true, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = false; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123;// dist[e.to] = dist[u] + e.cost; prevE[e.to] = i; prevV[e.to] = u; if (!inq[e.to]) &#123; inq[e.to] = true;// if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to); else q.push_front(e.to); &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second -= flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;int vis[MAXNODE];vector&lt;string&gt; vec;void dfs(int u, int n) &#123; vis[u] = 1; for (int i = 0, v; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (!vis[v = e.to] &amp;&amp; ((!e.cap &amp;&amp; e.cost &lt;= 0) || (e.cap &amp;&amp; e.cost &gt;= 0))) &#123; dfs(v, n); if (v &lt;= n) vec.push_back(str[v]); &#125; &#125;&#125;inline void printPath() &#123; memset(vis, 0, sizeof vis); vec.clear(); vec.push_back(str[1]); dfs(1, n); vec.push_back(str[1]); for (int i = (int)vec.size() - 1; i &gt;= 0; --i) cout &lt;&lt; vec[i] &lt;&lt; endl;&#125;int main()&#123; n = readIn(), m = readIn(); M.clear(); s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%s\", str[i]); M[str[i]] = i; if (i == 1 || i == n) addEdge(i, i + n, 2, 0); else addEdge(i, i + n, 1, 0); &#125; addEdge(s, 1, 2, 0); addEdge(n * 2, t, 2, 0); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%s\", s1); scanf(\"%s\", s2); int a = M[s1], b = M[s2]; if (a &gt; b) swap(a, b); if (a == 1 &amp;&amp; b == n) addEdge(a + n, b, 2, -1); addEdge(a + n, b, 1, -1); &#125; pair&lt;int, int&gt; ans = minCostMaxFlow(); if (ans.first != 2) printf(\"No Solution!\\n\"); else &#123; printf(\"%d\\n\", ans.second); printPath(); &#125; return 0;&#125; 「网络流 24 题」软件补丁 - 12123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// Created by ZJYelizaveta on 2017年08月20日 星期日 09时47分57秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = (1 &lt;&lt; (17 + 3));const int INF = 0x3f3f3f3f;int n, m, s, t;int w[MAX_N];char str1[MAX_N], str2[MAX_N];struct Limited &#123; int s1, s2, t1, t2; //b+, b-, f+, f-&#125;lim[100 + 3];int dist[MAX_N];bool inq[MAX_N];inline bool check(int u, int id) &#123; if ((u | lim[id].s1) != u) return false; if (u &amp; lim[id].s2) return false; return true;&#125;inline void SPFA() &#123; memset(inq, false, sizeof inq); memset(dist, INF, sizeof dist); queue&lt;int&gt; q; q.push(s); inq[s] = true; dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (register int i = 0; i &lt; m; ++i) &#123; if (check(u, i)) &#123; int to = (u &amp; (~lim[i].t2)) | lim[i].t1; if (dist[to] &gt; dist[u] + w[i]) &#123; dist[to] = dist[u] + w[i]; if (!inq[to]) &#123; inq[to] = true; q.push(to); &#125; &#125; &#125; &#125; &#125; if (dist[t] == INF) printf(\"%d\\n\", 0); else printf(\"%d\\n\", dist[t]);&#125;int main()&#123; n = readIn(), m = readIn(); s = (1 &lt;&lt; n) - 1, t = 0; for (register int i = 0; i &lt; m; ++i) &#123; w[i] = readIn(); scanf(\"%s\", str1); for (register int j = 0; j &lt; n; ++j) &#123; if (str1[j] == '+') lim[i].s1 |= (1 &lt;&lt; j); else if (str1[j] == '-') lim[i].s2 |= (1 &lt;&lt; j); &#125; scanf(\"%s\", str2); for (register int j = 0; j &lt; n; ++j) &#123; if (str2[j] == '+') lim[i].t1 |= (1 &lt;&lt; j); else if (str2[j] == '-') lim[i].t2 |= (1 &lt;&lt; j); &#125; &#125; SPFA(); return 0;&#125; 「网络流 24 题」星际转移问题 - 13123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145// Created by ZJYelizaveta on 2017年08月22日 星期二 19时53分41秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 13 + 3;const int MAX_M = 20 + 3;const int MAX_K = 50 + 3;const int MAXNODE = 500000 + 3;const int INF = 0x3f3f3f3f;int n, m, k;int h[MAX_M], r[MAX_M], a[MAX_M][MAX_N];int s, t;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int level[MAXNODE], iter[MAXNODE]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(e.cap, flow)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int d = 0, flow = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;namespace unionFindSet &#123; int fa[MAX_N]; inline void prepare() &#123; for (int i = 1; i &lt; MAX_N; ++i) fa[i] = i; &#125; inline int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]); &#125;&#125;using namespace unionFindSet;inline int ID(int station, int day) &#123; return day * (n + 2) + station;&#125;inline void solve() &#123; int moon = 1, earth = 2; int cur = 0, ans = 0; addEdge(s, ID(earth, 0), k), addEdge(ID(moon, 0), t, 0); while (1) &#123; ++cur; for (int i = 1; i &lt;= n + 2; ++i) &#123; addEdge(ID(i, cur - 1), ID(i, cur), INF); &#125; for (int i = 1; i &lt;= m; ++i) &#123; addEdge(ID(a[i][(cur - 1) % r[i]], cur - 1), ID(a[i][cur % r[i]], cur), h[i]); &#125; addEdge(ID(moon, cur), t, INF); ans += maxFlow(s, t); if (ans == k) &#123; printf(\"%d\\n\", cur); break; &#125; &#125;&#125;int main()&#123; n = readIn(), m = readIn(), k = readIn(); prepare(); s = 0, t = n * (n + 2) * (m + 1) * k * 2 + 1; for (int i = 1; i &lt;= m; ++i) &#123; h[i] = readIn(), r[i] = readIn(); for (int j = 0; j &lt; r[i]; ++j) &#123; a[i][j] = readIn() + 2;// printf(\"%d \", b[i][j]); if (j) &#123; int x = find(a[i][j - 1]); int y = find(a[i][j]);// printf(\"%d %d\\n\", x, y); if (x != y) fa[x] = y; &#125; &#125;// printf(\"\\n\"); &#125; int moon = 1, earth = 2; if (find(earth) != find(moon)) printf(\"%d\\n\", 0); else solve(); return 0;&#125; 「网络流 24 题」孤岛营救问题 - 141234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// Created by ZJYelizaveta on 2017年08月23日 星期三 17时56分49秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10 + 3;const int MAX_K = 150 + 3;const int INF = 0x3f3f3f3f;const int dx[] = &#123;1, 0, -1, 0&#125;;const int dy[] = &#123;0, 1, 0, -1&#125;;int n, m, p, k, s;int x2[MAX_K], x3[MAX_K], y2[MAX_K], y3[MAX_K], g[MAX_K];int x[MAX_K], y[MAX_K], q[MAX_K];int key[MAX_N][MAX_N], d[MAX_N][MAX_N][MAX_N][MAX_N];bool vis[1024 + 3][MAX_N][MAX_N];struct Node &#123; int x, y, st, dist; Node (int x, int y, int st, int dist) : x(x), y(y), st(st), dist(dist)&#123;&#125;&#125;;queue&lt;Node&gt; Q;inline void solve() &#123; Q.push(Node(1, 1, 0, 0)); vis[0][1][1] = true; while (!Q.empty()) &#123; Node cur = Q.front(); Q.pop(); for (int i = 0; i &lt;= 3; ++i) &#123; int x = cur.x + dx[i] , y = cur.y + dy[i] , t = d[cur.x][cur.y][x][y]; if (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m &amp;&amp; t != -1 &amp;&amp; !( ( cur.st ^ t ) &amp; t )) &#123; Node next = Node(x, y, (cur.st | key[x][y]), cur.dist + 1); if( x == n &amp;&amp; y == m ) &#123; printf(\"%d\\n\", next.dist); return; &#125; if (vis[next.st][x][y]) continue; vis[next.st][x][y] = true; Q.push(next); &#125; &#125; &#125; printf(\"%d\\n\", -1);&#125;int main()&#123; n = readIn(), m = readIn(), p = readIn(), k = readIn(); for (int i = 1; i &lt;= k; ++i) x2[i] = readIn(), y2[i] = readIn(), x3[i] = readIn(), y3[i] = readIn(), g[i] = readIn(); s = readIn(); for (int i = 1; i &lt;= s; ++i) x[i] = readIn(), y[i] = readIn(), q[i] = readIn(); for (int i = 1; i &lt;= k; ++i) &#123; int &amp;a = d[x2[i]][y2[i]][x3[i]][y3[i]]; int &amp;b = d[x3[i]][y3[i]][x2[i]][y2[i]]; if (a == -1) continue; if (g[i] == 0) a = b = -1; else a = b = (a | (1 &lt;&lt; (g[i] - 1))); &#125; for (int i = 1; i &lt;= s; ++i) key[x[i]][y[i]] |= (1 &lt;&lt; (q[i] - 1)); solve(); return 0;&#125; 「网络流 24 题」汽车加油行驶问题 - 15「网络流 24 题」数字梯形 - 16123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155// Created by ZJYelizaveta on 2017年08月20日 星期日 19时21分21秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 20 + 3;const int MAXNODE = 800 + 3;const int INF = 0x3f3f3f3f;int n, m;int a[MAX_N][MAX_N], num[MAX_N][MAX_N];int cnt;namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int dist[MAXNODE]; int prevV[MAXNODE], prevE[MAXNODE]; bool inq[MAXNODE]; inline void init() &#123; for (int i = 0; i &lt;= MAXNODE; ++i) G[i].clear(); &#125; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow(int s, int t) &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, 0, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s), inq[s] = 1, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = 0;// for (int i = 0; i &lt; (int)G[u].size(); i++)&#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123; dist[e.to] = dist[u] + e.cost; prevE[e.to] = i; prevV[e.to] = u; if (!inq[e.to]) &#123;// inq[e.to] = 1; if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to);// else q.push_front(e.to);// &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second += flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;inline void solve1() &#123; init(); int s = 0, t = 2 * cnt + 1;// printf(\"%d %d %d\\n\", s, t, cnt); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i + m; ++j) &#123; addEdge(num[i][j], num[i][j] + cnt, 1, -a[i][j]); if (i + 1 &lt;= n) &#123; addEdge(num[i][j] + cnt, num[i + 1][j], 1, 0); addEdge(num[i][j] + cnt, num[i + 1][j + 1], 1, 0); &#125; &#125; &#125; for (int i = 1; i &lt;= m; ++i) addEdge(s, num[1][i], 1, 0); for (int i = 1; i &lt; n + m; ++i) addEdge(num[n][i] + cnt, t, 1, 0); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", -ans.second);&#125;inline void solve2() &#123; init(); int s = 0, t = 2 * cnt + 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i + m; ++j) &#123; addEdge(num[i][j], num[i][j] + cnt, INF, -a[i][j]); if (i + 1 &lt;= n) &#123; addEdge(num[i][j] + cnt, num[i + 1][j], 1, 0); addEdge(num[i][j] + cnt, num[i + 1][j + 1], 1, 0); &#125; &#125; &#125; for (int i = 1; i &lt;= m; ++i) addEdge(s, num[1][i], 1, 0); for (int i = 1; i &lt; n + m; ++i) addEdge(num[n][i] + cnt, t, INF, 0); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", -ans.second);&#125;inline void solve3() &#123; init(); int s = 0, t = 2 * cnt + 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i + m; ++j) &#123; addEdge(num[i][j], num[i][j] + cnt, INF, -a[i][j]); if (i + 1 &lt;= n) &#123; addEdge(num[i][j] + cnt, num[i + 1][j], INF, 0); addEdge(num[i][j] + cnt, num[i + 1][j + 1], INF, 0); &#125; &#125; &#125; for (int i = 1; i &lt;= m; ++i) addEdge(s, num[1][i], 1, 0); for (int i = 1; i &lt; n + m; ++i) addEdge(num[n][i] + cnt, t, INF, 0); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", -ans.second);&#125;int main()&#123; m = readIn(), n = readIn(); cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i + m; ++j) &#123; a[i][j] = readIn(); num[i][j] = ++cnt;// printf(\"%d %d \", num[i][j], a[i][j]); &#125;// printf(\"\\n\"); &#125; solve1(); solve2(); solve3(); return 0;&#125; 「网络流 24 题」运输问题 - 17123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// Created by ZJYelizaveta on Monday, August 21, 2017 AM09:07:18 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int MAXNODE = 200 + 3;const int INF = 0x3f3f3f3f;int n, m;int a[MAX_N], b[MAX_N], c[MAX_N][MAX_N];namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int dist[MAXNODE]; int prevV[MAXNODE], prevE[MAXNODE]; bool inq[MAXNODE]; inline void clear() &#123; for (int i = 0; i &lt;= MAXNODE; ++i) G[i].clear(); &#125; inline void init() &#123; for (int i = 0; i &lt;= MAXNODE; ++i) G[i].clear(); &#125; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow(int s, int t) &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, 0, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s), inq[s] = 1, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = 0;// for (int i = 0; i &lt; (int)G[u].size(); i++)&#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123; dist[e.to] = dist[u] + e.cost; prevE[e.to] = i; prevV[e.to] = u; if (!inq[e.to]) &#123;// inq[e.to] = 1; if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to);// else q.push_front(e.to);// &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second += flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;inline void solve1() &#123; clear(); int s = 0, t = n + m + 1; for (int i = 1; i &lt;= n; ++i) addEdge(s, i, a[i], 0); for (int i = 1; i &lt;= m; ++i) addEdge(i + n, t, b[i], 0); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) addEdge(i, j + n, INF, c[i][j]); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", ans.second);&#125;inline void solve2() &#123; clear(); int s = 0, t = n + m + 1; for (int i = 1; i &lt;= n; ++i) addEdge(s, i, a[i], 0); for (int i = 1; i &lt;= m; ++i) addEdge(i + n, t, b[i], 0); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) addEdge(i, j + n, INF, -c[i][j]); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", -ans.second);&#125;int main()&#123; n = readIn(), m = readIn(); for (int i = 1; i &lt;= n; ++i) a[i] = readIn(); for (int i = 1; i &lt;= m; ++i) b[i] = readIn(); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) c[i][j] = readIn(); solve1(); solve2(); return 0;&#125; 「网络流 24 题」分配问题 - 18123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// Created by ZJYelizaveta on Monday, August 21, 2017 AM09:56:23 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int MAXNODE = 200 + 3;const int INF = 0x3f3f3f3f;int n;int c[MAX_N][MAX_N];namespace MCMF &#123; struct Edge &#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int dist[MAXNODE]; int prevV[MAXNODE], prevE[MAXNODE]; bool inq[MAXNODE]; inline void clear() &#123; for (int i = 0; i &lt;= MAXNODE; ++i) G[i].clear(); &#125; inline void addEdge(int from, int to, int cap, int cost) &#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; pair&lt;int, int&gt; minCostMaxFlow(int s, int t) &#123; pair&lt;int, int&gt; ans(0, 0); while (1) &#123; memset(inq, false, sizeof inq); memset(dist, INF, sizeof dist); deque&lt;int&gt; q; q.push_front(s); inq[s] = true, dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = false; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; dist[e.to] &gt; dist[u] + e.cost) &#123;// dist[e.to] = dist[u] + e.cost; prevE[e.to] = i; prevV[e.to] = u; if (!inq[e.to]) &#123; inq[e.to] = true;// if (q.empty() || dist[e.to] &gt; dist[q.front()]) q.push_back(e.to); else q.push_front(e.to); &#125; &#125; &#125; &#125; if (dist[t] == INF) break; int flow = INF; for (int i = t; i != s; i = prevV[i]) flow = min(flow, G[prevV[i]][prevE[i]].cap); ans.first += flow, ans.second += flow * dist[t]; for (int i = t; i != s; i = prevV[i]) &#123; Edge &amp;e = G[prevV[i]][prevE[i]]; e.cap -= flow; G[e.to][e.rev].cap += flow; &#125; &#125; return ans; &#125;&#125;using namespace MCMF;inline void solve1() &#123; clear(); int s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; ++i) addEdge(s, i, 1, 0); for (int i = 1; i &lt;= n; ++i) addEdge(i + n, t, 1, 0); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) addEdge(i, j + n, INF, c[i][j]); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", ans.second);&#125;inline void solve2() &#123; clear(); int s = 0, t = n * 2 + 1; for (int i = 1; i &lt;= n; ++i) addEdge(s, i, 1, 0); for (int i = 1; i &lt;= n; ++i) addEdge(i + n, t, 1, 0); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) addEdge(i, j + n, INF, -c[i][j]); pair&lt;int, int&gt; ans = minCostMaxFlow(s, t); printf(\"%d\\n\", -ans.second);&#125;int main()&#123; n = readIn(); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; c[i][j] = readIn();// printf(\"%d \", c[i][j]); &#125; &#125; solve1(); solve2(); return 0;&#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/费用流/"},{"name":"最大权闭合图","slug":"最大权闭合图","permalink":"http://yoursite.com/tags/最大权闭合图/"},{"name":"最小割","slug":"最小割","permalink":"http://yoursite.com/tags/最小割/"},{"name":"最大独立集","slug":"最大独立集","permalink":"http://yoursite.com/tags/最大独立集/"},{"name":"分层图","slug":"分层图","permalink":"http://yoursite.com/tags/分层图/"}]},{"title":"线性规划与网络流24题 Part 1","slug":"线性规划与网络流24题-Part-1","date":"2017-09-21T05:31:28.000Z","updated":"2017-09-21T06:37:39.643Z","comments":true,"path":"2017/09/21/线性规划与网络流24题-Part-1/","link":"","permalink":"http://yoursite.com/2017/09/21/线性规划与网络流24题-Part-1/","excerpt":"太菜了，现在才做网络流$24$题QAQ","text":"太菜了，现在才做网络流$24$题QAQ 「网络流 24 题」搭配飞行员 - 1很明显的求二分图最大匹配的模板题呀QAQ 建立源点 $s$ 连向每一个正驾驶员，容量为 $1$。 建立汇点 $t$ 所有的副驾驶员连向 $t$，容量为 $1$。 正驾驶员 $a$ 和副驾驶员 $b$ 可以同机飞行，那么连一条容量为$1$的边$a \\rightarrow b$。 然后跑最大流就是答案了 「网络流 24 题」太空飞行计划 - 2不会做啊QAQ，太菜了最大权闭合图问题，可以转化成最小割问题，进而用最大流解决。 闭合子图就是给定一个有向图，从中选择一些点组成一个点集$V$。对于$V$中任意一个点，其后续节点都仍然在$V$中。通俗的来说是 : 闭合图的性质反映的是事件的必要条件，$A$发生，那么$A$的所有前提要发生。 这道题目里 “ 要想做实验，先做某个实验必须购买好实验所需的设备 “ 构成了事件的必要条件。 先说结论吧，最大权闭合子图的权值等于所有正权点之和减去最小割 / 最大流。 本题要求最大化总收益，设配置仪器花 $C$ 元，这些仪器能进行的实验的总收益为 $P$，不能进行的实验的总收益为 $P’$ ，所有实验的总收益为 $Sum$，则 \\text{Profit} = P - C = (Sum - P') - C = Sum - (P' + C)由于 $S$ 是定值，我们将问题转化到了在合法的情况下，让 $W’ + C$尽量小，于是构图如下: 将每个实验划分为 $A$ 集合，每个仪器划分为 $B$ 集合。 建立超级源点 $s$ 向 $A$ 集合中的每一个点连一条容量为该实验收益的边并累加 $sum$，建立超级汇点 $t$，$B$ 集合中的每一个点向汇点 $t$ 连一条容量为该仪器花费的边。 如果 $A$ 集合中的实验 $A_{i}$ 需要$B$集合中的仪器 $B_{j}$，那么连边 $A_{i} \\rightarrow B_{j}$ 容量为 $\\infty$。 跑一遍最大流，$ans = sum - maxFlow(s, t)$。 我们发现我们需要最小化的$P’ + C$相当于当前图中的最小割 / 最大流。 现在再想一下上面的结论为什么成立，我们需要最小化割，相当于用最小的流量使得 $s$ 与 $t$ 不连通。对于一个实验，我们定义选择还是不选择实验 $A_{i}$ 通过是否割 $s \\rightarrow A_{i}$ 这条边来判定，如果不选择实验 $A_{i}$ 则割掉 $s \\rightarrow A_{i}$ 这条边; 如果选择实验 $A_{i}$ 则不割这条边，那么现在为了使得 $s \\rightarrow t$ 不连通，那么就割掉实验 $A_{i}$ 所需的仪器集合 $B_{i}$ 连向 $t$ 的边 (我们肯定不会选择割容量为$\\infty$的边)。那么这样每一个合法的割的值就为 $P’ + C$，也就是说我们要最小化 $P’ + C$ 的值。 输出方案有一些恶心，这里不想写了，可以看线性规划与网络流24题 - 2 太空飞行计划 「网络流 24 题」最小路径覆盖 - 3我们需要求有向无环图 $G$ 的最小路径覆盖。 最小路径覆盖 = 原图顶点数 - 二分图最大匹配数 我们可以观察一条路径，起点的入度为 $0$，终点的出度为 $0$，中间节点的出入度都为 $1$。也就是说，每一个点最多只能有 $1$ 个后继，同时每一个点最多只能有 $1$ 个前驱。假如我们选择了一条边 $(u,v)$，也就等价于把前驱 $u$ 和后继 $v$ 匹配上了。这样前驱 $u$ 和后继 $v$ 就不能和其他节点匹配。 将每一个点拆分成 $2$ 个，分别表示它作为前驱节点和后继节点，将所有的前驱结点作为 $A$ 集合，所有后继结点作为 $B$ 集合。 若原图中存在一条边$(u,v)$，则连接$A$集合的$u$和$B$集合的$v$。 新建源汇 $s, t$，$s$ 向每个 $A_{i}$连边，$B_{i}$向 $t$ 连边。 如果一个点是路径起点的话，它在$B$集合的结点一定是没有匹配上的，做完二分图最大匹配之后，保证了$B$集合中未匹配的点最少，也就对应了最小路径覆盖数。 输出路径有一些麻烦，画一下图应该就会了吧QAQ 「网络流 24 题」魔术球 - 4依然是一道很神奇的题目QAQ，听说贪心可以过，这里还是写网络流的做法吧 不好求有 $n$ 个柱子时可放的球数量，转换一下思路，我们求可放 $n$ 个球时的最小柱子数量，注意到同一个柱子上球的标号递增，所以可以转化为最小路径覆盖问题。 枚举答案 $A$，在图中建立节点 $1,2, \\cdots ,A$。如果对于 $i&lt;j$有 $i+j$为一个完全平方数，连接一条有向边 $(i,j)$。那么此时我们可以发现五门实际上是在求有向无环图的最小路径覆盖。 如果刚好满足最小路径覆盖数等于 $n$，那么 $A$ 是一个可行解，在所有可行解中找到最大的 $A$，即为最优解。可以顺序枚举 $A$ 的值，当最小路径覆盖数刚好大于 $n$ 时终止，$A-1$就是最优解。 这道题目更适合枚举答案而不是二分答案，因为如果顺序枚举答案，每次只需要在残量网络上增加新的结点点和边，再增广一次即可。如果二分答案，就需要每次重新建图，大大增加了时间复杂度。 「网络流 24 题」圆桌聚餐 - 5二分图多重匹配，为什么总是要输出方案呀QAQ 把每一个代表单位当成$A$集合中的一个元素，每张餐桌当做$B$集合中的一个元素。 建立超级源点$s$向$A$集合连一条容量为代表单位的人数; 建立超级汇点$t$，$B$集合中的每一个点向$t$连一条容量为餐桌最多容纳人数的边。保证每个单位参加人数不超过上限，每个餐桌容量不超过上限。 $A$集合中的每一个点向$B$集合中的每一个点连一条容量为$1$的点，保证了 “ 希望从同一个单位来的代表不在同一个餐桌就餐 “ 这个条件成立。若可以匹配多次则可以通过改变容量实现。 跑一边最大流$ans = maxFlow(s, t)$，若$ans$小于每个单位人数之和则没有解，否则存在并输出答案。 二分图最大匹配中，每个点最多只能和一条匹配边相关联，然而，我们像以上这类问题，即二分图匹配中一个点可以和多条匹配边相关联，可以参考以上的建模方法。 「网络流 24 题」最长递增子序列 - 6首先第一问可以用动态规划在 $\\Theta(n^{2})$ 做的，令 $f[i]$ 表示以第 $i$ 为结尾的最长上升序列的长度，最后取 $max$ $f[i]$即可。 第二问，问最多可取同时出多少个长度为 $s$ 的递增子序列。每个数只能用一次，因此考虑拆点来限制每个点只能用一次这个条件 把序列第$i$位拆成两个点$i_{a}$和$i_{b}$，从$i_{a}$到$i_{b}$连接一条容量为1的有向边 建立超级源点$s$和超级汇点$t$，如果序列第 $i$ 位有 $f[i] = 1$，从 $s$ 到 $i_{a}$ 连接一条容量为 $1$ 的边 如果有 $f[i]=1$，从 $i_{b}$ 到 $t$ 连接一条容量为1的有向边。 如果$i &lt; j$且$A[i] &lt; A[j]$且$f[j] + 1 = f[i]$，从$i_{b}$到$j_{a}$连接一条容量为$1$边 简要分析一下，因为最上升子序列有明显的阶段性，$f[i]$的值为阶段，那么$f[i] = 1$相当与阶段的开始，而$f[i] = k$相当于阶段的结束，一束流量为$1$的流，只有经过 $k - 1$次转移，才能到从源点到达汇点，而每一束到达汇点的流，均对应一个 最长上升子序列，因此第二问的答案就是本图最大流。 会求第二问了，那么第三问也是一样的，只需要将边$(1_{a}, 1_{b})$，$(n_{a}, n_{b})$，$(s, 1_{a})$，$(n_{b}, t) (f[n] == k)$的容量修改为$\\infty$，再求一次网络最大流，就是第三问结果。 调的有点久，因为位运算没有写括号进入了死循环 ??? 「网络流 24 题」试题库 - 7还是二分图多重匹配，题意描述的很玄妙呀QAQ大概就是一张试卷需要含有$k$种属性的试题，每种属性的试题需要$k_{i}$道，现在题库中一共有$n$道试题，每道试题有$p$种属性，输出满足第$k$道试题的试卷选取情况。建图方法同 “ 「网络流 24 题」圆桌聚餐 “ 。 每一道试题当成$A$集合中的一个元素，试卷中所需的每种试题当做$B$集合中的一个元素。 建立超级源点$s$向$A$集合连一条容量$1$; 建立超级汇点$t$，$B$集合中的每一个点向$t$连一条容量为每种试题需要数量。 $A$集合中的每一个点根据这道试题的类型向$B$集合中的代表此种类型的点连一条容量为$1$的点。 跑一边最大流$ans = maxFlow(s, t)$，若$ans$小于每各种类的题所需数量之和则没有解，否则存在并输出答案。 「网络流 24 题」机器人路径规划问题 - 8真 $\\cdot$ 不会做，有没有大佬可以教我呀QAQ 代码「网络流 24 题」搭配飞行员 - 112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Created by ZJYelizaveta on 2017年08月17日 星期四 09时27分02秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int INF = 0x3f3f3f3f;int n, m;int s, t;int a[MAX_N], b[MAX_N];int ans;namespace dinic &#123; struct Edge &#123; int to, cap, rev; Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N]; int iter[MAX_N], level[MAX_N]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; queue&lt;int&gt; q; memset(level, -1, sizeof level); q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if(u == t) return flow;// for (int &amp;i = iter[u]; i &lt; G[u].size(); i++) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(flow, e.cap)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int flow = 0, d = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while(d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace dinic;int main()&#123; n = readIn(), m = readIn();// printf(\"%d %d\\n\", n, m); s = 0, t = n + 1; for (int i = 1; i &lt;= m; ++i) addEdge(s, i, 1);// for (int i = m + 1; i &lt;= n; ++i) addEdge(i, t, 1);// int a, b; while (scanf(\"%d%d\", &amp;a, &amp;b) != EOF) &#123; if (a &gt; b) swap(a, b); addEdge(a, b, 1); &#125; ans = maxFlow(s, t); printf(\"%d\\n\", ans); return 0;&#125; 「网络流 24 题」太空飞行计划 - 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// Created by ZJYelizaveta on Wednesday, September 20, 2017 PM02:14:25 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int INF = 0x3f3f3f3f;int m, n;int s, t;int c[MAX_N];int ans, sum;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge (int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N]; int iter[MAX_N], level[MAX_N]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(e.cap, flow)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int d = 0, flow = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;int vis[MAX_N &lt;&lt; 1];void dfs(int u) &#123; vis[u] = true; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; !vis[e.to]) dfs(e.to); &#125;&#125;inline void printPath() &#123; memset(vis, 0, sizeof vis); dfs(0); for (int i = 1; i &lt;= n; ++i) if (vis[i]) printf(\"%d \", i); printf(\"\\n\"); for (int i = 1; i &lt;= m; ++i) if (vis[n + i]) printf(\"%d \", i); printf(\"\\n\");&#125;int main()&#123; n = readIn(), m = readIn();// printf(\"%d %d\\n\", n, m); s = 0, t = m + n + 1; sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; int num = readIn(); sum += num; addEdge(s, i, num); string s; int a; getline(cin, s); stringstream ss(s); while (ss &gt;&gt; a) addEdge(i, a + n, INF); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int x = readIn(); addEdge(i + n, t, x); &#125;// printf(\"%d\\n\", sum);// printf(\"%d\\n\", maxFlow(s, t)); ans = sum - maxFlow(s, t); printPath(); printf(\"%d\\n\", ans); return 0;&#125; 「网络流 24 题」最小路径覆盖 - 3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// Created by ZJYelizaveta on 2017年08月17日 星期四 10时02分56秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 300 + 3;const int INF = 0x3f3f3f3f;int n, m;int s, t;int ans;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1]; int iter[MAX_N &lt;&lt; 1], level[MAX_N &lt;&lt; 1]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(e.cap, flow));// if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int flow = 0, d = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;int vis[MAX_N &lt;&lt; 1], fa[MAX_N &lt;&lt; 1], next[MAX_N &lt;&lt; 1];void dfs(int u) &#123; vis[u] = true; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.to &gt; n &amp;&amp; e.to &lt;= 2 * n &amp;&amp; e.cap &lt;= 0 &amp;&amp; !vis[e.to]) &#123; next[u] = (e.to - n); fa[e.to - n] = fa[u]; dfs(e.to - n); &#125; &#125;&#125;inline void printPath() &#123; memset(vis, 0, sizeof vis); memset(next, 0, sizeof next); for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i);// for (int i = 1; i &lt;= n; ++i) printf(\"%d %d\\n\", fa[i], i); for (int i = 1; i &lt;= n; ++i) if (fa[i] == i) &#123; for (int j = i; j; j = next[j]) printf(\"%d \", j); printf(\"\\n\"); &#125;&#125;int main()&#123; n = readIn(), m = readIn();// printf(\"%d %d\\n\", n, m); s = 0, t = 2 * n + 1; for (int i = 1; i &lt;= n; ++i) addEdge(s, i, 1); for (int i = 1; i &lt;= n; ++i) addEdge(i + n, t, 1); for (int i = 1; i &lt;= m; ++i) &#123; int u = readIn(), v = readIn(); addEdge(u, v + n, 1); &#125; ans = n - maxFlow(s, t); printPath(); printf(\"%d\\n\", ans); return 0;&#125; 「网络流 24 题」魔术球 - 4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// Created by ZJYelizaveta on 2017年08月19日 星期六 18时59分06秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100000 + 3;const int MAX_M = 1000000 + 3;const int INF = 0x3f3f3f3f;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge (int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1]; int iter[MAX_N &lt;&lt; 1], level[MAX_N]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs(int s, int t) &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int t, int flow) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, t, min(e.cap, flow)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; int s = _s, t = _t; int d = 0, flow = 0; while (bfs(s, t)) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, t, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;int vis[MAX_N], next[MAX_N];inline void printPath(int n) &#123; memset(vis, 0, sizeof vis); memset(next, 0, sizeof next); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; (int)G[i].size(); ++j) &#123; Edge &amp;e = G[i][j]; if (e.to &amp;&amp; e.cap &lt;= 0) next[i] = e.to - 5000;// &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (vis[i]) continue; int x = i; while (x) &#123; printf(\"%d \", x); x = next[x]; vis[x] = 1; &#125; printf(\"\\n\"); &#125;&#125;set&lt;int&gt; S;int main()&#123; for (int i = 1; i &lt;= 100; ++i) S.insert(i * i); int n = readIn(); int st = 0, ed = 100000, m = 5000, ans = 0, cnt = 0; for (int i = 1; ; ++i) &#123; addEdge(st, i, 1); addEdge(i + m, ed, 1); for (int j = 1; j &lt; i; ++j) if (S.count(i + j)) addEdge(j, i + m, 1); ans += maxFlow(st, ed); if (i - ans &gt; n) &#123; printf(\"%d\\n\", i - 1); cnt = i - 1; break; &#125; &#125;// printf(\"%d\\n\", cnt); printPath(cnt); return 0;&#125; 「网络流 24 题」圆桌聚餐 - 5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118// Created by ZJYelizaveta on 2017年08月17日 星期四 21时08分55秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 270 + 3;const int MAX_M = 150 + 3;const int INF = 0x3f3f3f3f;int n, m;int s, t;int ans, sum;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1]; int iter[MAX_N &lt;&lt; 1], level[MAX_N &lt;&lt; 1]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(e.cap, flow)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int flow = 0, d = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;inline void printPath() &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; (int)G[i].size(); ++j) &#123; Edge &amp;e = G[i][j]; if (e.to &gt; n &amp;&amp; e.to &lt;= n + m &amp;&amp; !e.cap) printf(\"%d \", e.to - n); &#125; printf(\"\\n\"); &#125;&#125;int main()&#123; n = readIn(), m = readIn(); s = 0, t = n + m + 1; sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; int num = readIn(); sum += num; addEdge(s, i, num); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int num = readIn(); addEdge(i + n, t, num); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; addEdge(i, j + n, 1); &#125; &#125; ans = maxFlow(s, t); if (ans &lt; sum) printf(\"%d\\n\", 0); else &#123; printf(\"%d\\n\", 1); printPath(); &#125; return 0;&#125; 「网络流 24 题」最长递增子序列 - 6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149// Created by ZJYelizaveta on 2017年08月24日 星期四 20时02分04秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 500 + 3;const int MAXNODE = 1000 + 3;const int INF = 0x3f3f3f3f;int n;int a[MAX_N];int f[MAX_N];int maxLength;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge (int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAXNODE]; int level[MAXNODE], iter[MAXNODE]; inline void clear() &#123; for (int i = 0; i &lt; MAXNODE; ++i) G[i].clear(); &#125; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs(int s, int t) &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow, int t) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(flow, e.cap), t); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; int s = _s, t = _t; int d = 0, flow = 0; while (bfs(s, t)) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, INF, t), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;inline int solve1() &#123; int ans = -INF; memset(f, 0, sizeof f); for (register int i = 1; i &lt;= n; ++i) &#123; f[i] = 1; for (register int j = 1; j &lt; i; ++j) &#123; if (a[i] &gt;= a[j]) f[i] = max(f[i], f[j] + 1); &#125; ans = max(ans, f[i]); &#125; return ans;&#125;inline void solve2() &#123; int s = 0, t = (n &lt;&lt; 1) + 1; for (register int i = 1; i &lt;= n; ++i) &#123; addEdge(i, i + n, 1); if (f[i] == 1) addEdge(s, i, 1); if (f[i] == maxLength) addEdge(i + n, t, 1); for (register int j = 1; j &lt; i; ++j) &#123; if (a[j] &lt;= a[i] &amp;&amp; f[j] + 1 == f[i]) addEdge(j + n, i, 1); &#125; &#125; int ans = maxFlow(s, t); printf(\"%d\\n\", ans);&#125;inline void solve3() &#123; clear(); int s = 0, t = (n &lt;&lt; 1) + 1; for (register int i = 1; i &lt;= n; ++i) &#123; int cap = 1; if (i == 1 || i == n) cap = INF;// addEdge(i, i + n, cap); if (f[i] == 1) addEdge(s, i, cap); if (f[i] == maxLength) addEdge(i + n, t, cap); for (register int j = 1; j &lt; i; ++j) &#123; if (a[j] &lt;= a[i] &amp;&amp; f[j] + 1 == f[i]) addEdge(j + n, i, 1); &#125; &#125; int ans = maxFlow(s, t); printf(\"%d\\n\", ans);&#125;int main()&#123; freopen(\"alis.in\", \"r\", stdin); freopen(\"alis.out\", \"w\", stdout); n = readIn(); for (register int i = 1; i &lt;= n; ++i) a[i] = readIn(); maxLength = solve1(); printf(\"%d\\n\", maxLength); if (maxLength == 1) printf(\"%d\\n%d\\n\", n, n); else &#123; solve2(); solve3(); &#125;// fprintf(stderr, \"Time used : %.3f\\n\", (double)clock() / CLOCKS_PER_SEC); return 0;&#125; 「网络流 24 题」试题库 - 7123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// Created by ZJYelizaveta on 2017年08月17日 星期四 22时27分08秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int INF = 0x3f3f3f3f;int k, n;int s, t;int ans, sum;namespace Dinic &#123; struct Edge &#123; int to, cap, rev; Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N &lt;&lt; 1]; int iter[MAX_N &lt;&lt; 1], level[MAX_N &lt;&lt; 1]; inline void addEdge(int from, int to, int cap) &#123; G[from].push_back(Edge(to, cap, G[to].size())); G[to].push_back(Edge(from, 0, G[from].size() - 1)); &#125; bool bfs() &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &gt; 0 &amp;&amp; level[e.to] == -1) &#123; level[e.to] = level[u] + 1; q.push(e.to); &#125; &#125; &#125; return ~level[t]; &#125; int dfs(int u, int flow) &#123; if (u == t) return flow; for (int &amp;i = iter[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (e.cap &amp;&amp; level[e.to] == level[u] + 1) &#123; int d = dfs(e.to, min(e.cap, flow)); if (d) &#123; e.cap -= d; G[e.to][e.rev].cap += d; return d; &#125; &#125; &#125; return 0; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int flow = 0, d = 0; while (bfs()) &#123; memset(iter, 0, sizeof iter); while (d = dfs(s, INF), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;inline void printSolution() &#123; for (int i = n + 1; i &lt;= n + k; ++i) &#123; printf(\"%d:\", i - n); for (int j = 0; j &lt; (int)G[i].size(); ++j) &#123; Edge &amp;e = G[i][j]; if (e.to &lt;= n &amp;&amp; e.to &gt;= 1 &amp;&amp; e.cap) printf(\" %d\", e.to); &#125; printf(\"\\n\"); &#125;&#125;int main()&#123; k = readIn(), n = readIn(); s = 0, t = k + n + 1; sum = 0; for (int i = 1; i &lt;= k; ++i) &#123; int num = readIn(); sum += num; addEdge(i + n, t, num); &#125; for (int i = 1; i &lt;= n; ++i) &#123; int cnt = readIn(); addEdge(s, i, 1); for (int j = 1; j &lt;= cnt; ++j) &#123; int type = readIn(); addEdge(i, type + n, 1); &#125; &#125; ans = maxFlow(s, t);// printf(\"%d %d\\n\", ans, sum); if (ans &lt; sum) printf(\"No Solution!\\n\"); else printSolution(); return 0;&#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/费用流/"},{"name":"最大权闭合图","slug":"最大权闭合图","permalink":"http://yoursite.com/tags/最大权闭合图/"},{"name":"最小割","slug":"最小割","permalink":"http://yoursite.com/tags/最小割/"},{"name":"二分图匹配","slug":"二分图匹配","permalink":"http://yoursite.com/tags/二分图匹配/"},{"name":"二分图多重匹配","slug":"二分图多重匹配","permalink":"http://yoursite.com/tags/二分图多重匹配/"}]},{"title":"「BZOJ 2038」小Z的袜子","slug":"「BZOJ-2038」小Z的袜子","date":"2017-09-08T15:36:12.000Z","updated":"2017-09-21T06:50:17.048Z","comments":true,"path":"2017/09/08/「BZOJ-2038」小Z的袜子/","link":"","permalink":"http://yoursite.com/2017/09/08/「BZOJ-2038」小Z的袜子/","excerpt":"题目地址 描述作为一个生活散漫的人，小Z 每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……具体来说，小Z 把这 $N( 1\\leq N \\leq 500000)$ 只袜子从 $1$ 到 $N$ 编号，然后从编号 $L$ 到 $R$ 。尽管 小Z 并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。你的任务便是告诉 小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个 $(L,R)$ 以方便自己选择。","text":"题目地址 描述作为一个生活散漫的人，小Z 每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……具体来说，小Z 把这 $N( 1\\leq N \\leq 500000)$ 只袜子从 $1$ 到 $N$ 编号，然后从编号 $L$ 到 $R$ 。尽管 小Z 并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。你的任务便是告诉 小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个 $(L,R)$ 以方便自己选择。 分析我们可以把答案表示为 ans = \\frac{\\sum_{i = l}^{r}C_{cnt[c[a[i]]]}^{2}}{C_{r - l + 1}^{2}}其中 $cnt[i]$ 为颜色 $i$ 的个数，$c[i]$ 为 $i$ 的颜色，$a[i]$ 为原颜色序列 $a$ 第 $i$ 位的颜色，我们可以将原式化简一下，变为 : ans = \\frac{\\sum_{i = l}^{r}cnt[c[a[i]] \\cdot (cnt[c[a[i]] - 1)}{(r - l + 1) \\cdot (r - l)} \\\\ = \\frac{\\sum_{i = l}^{r}{cnt[c[a[i]]}^{2} - (r - l + 1)}{(r - l + 1) \\cdot (r - l)}这样一来，单个数字对答案的贡献可以简化为 ${cnt[c[a[i]]]}^{2}(l \\leq i\\leq r)$ ，每加进来或删去一个数字时，可以 $\\Theta(1)$ 重新计算单个数字对答案的贡献来得到新区间的答案。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// Created by ZJYelizaveta on 2017年09月03日 星期日 09时44分10秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 50000 + 3;const int INF = 0x3f3f3f3f;int n, m;int a[MAX_N];struct Interval &#123; int l, r, id, pos; bool operator &lt; (const Interval &amp;rhs) const &#123; if (pos == rhs.pos) return r &lt; rhs.r; return pos &lt; rhs.pos; &#125;&#125;q[MAX_N];ll cnt[MAX_N], ans[MAX_N][2], res;int blockSize, f[MAX_N];inline ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;inline void modify(int id, int w) &#123; res += (ll)2 * cnt[a[id]] * w + 1; cnt[a[id]] += w;&#125;inline void solve() &#123; memset(cnt, 0, sizeof cnt); int l = 1, r = 0; res = 0; for (int i = 1; i &lt;= m; ++i) &#123; const Interval &amp;b = q[i]; while (b.l &lt; l) &#123;--l; modify(l, 1);&#125; while (r &lt; b.r) &#123;++r; modify(r, 1);&#125; while (l &lt; b.l) &#123;modify(l, -1); ++l;&#125; while (b.r &lt; r) &#123;modify(r, -1); --r;&#125; if (b.l == b.r) &#123;ans[i][0] = 0; ans[i][1] = 1; continue;&#125; ans[i][0] = (ll)res - (b.r - b.l + 1); ans[i][1] = (ll)(b.r - b.l + 1) * (b.r - b.l); ll cur = gcd(ans[i][0], ans[i][1]); ans[i][0] = ans[i][0] / cur, ans[i][1] = ans[i][1] / cur; f[b.id] = i; &#125;&#125;int main()&#123; n = readIn(), m = readIn(); blockSize = (int)(sqrt(n)); for (int i = 1; i &lt;= n; ++i) a[i] = readIn(); for (int i = 1; i &lt;= m; ++i) &#123; q[i].l = readIn(), q[i].r = readIn(), q[i].id = i; q[i].pos = (q[i].l - 1) / blockSize + 1; &#125; sort(q + 1, q + m + 1); solve(); for (int i = 1; i &lt;= m; ++i) printf(\"%lld/%lld\\n\", ans[f[i]][0], ans[f[i]][1]); return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/莫队/"}]},{"title":"「BZOJ 1878」HH 的项链","slug":"「BZOJ-1878」HH-的项链","date":"2017-09-08T15:34:53.000Z","updated":"2017-10-21T08:19:08.032Z","comments":true,"path":"2017/09/08/「BZOJ-1878」HH-的项链/","link":"","permalink":"http://yoursite.com/2017/09/08/「BZOJ-1878」HH-的项链/","excerpt":"题目地址 描述HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。$1 \\leq n \\leq 50000, 1 \\leq m \\leq 200000$","text":"题目地址 描述HH 有一串由各种漂亮的贝壳组成的项链。HH 相信不同的贝壳会带来好运，所以每次散步完后，他都会随意取出一段贝壳，思考它们所表达的含义。HH 不断地收集新的贝壳，因此他的项链变得越来越长。有一天，他突然提出了一个问题：某一段贝壳中，包含了多少种不同的贝壳？这个问题很难回答……因为项链实在是太长了。于是，他只好求助睿智的你，来解决这个问题。$1 \\leq n \\leq 50000, 1 \\leq m \\leq 200000$ 分析莫队的模板题呀QAQ考虑从 $[l, r]$ 扩展到 $[l - 1, r], [l, r + 1]$，此时边界的贝壳种类是否未出现过，是未出现的种类则答案加一，并将此种贝壳种类的个数加一。考虑从 $[l, r]$ 扩展到 $[l + 1, r], [l, r - 1]$，此时边界的贝壳中类是否只出现过一次，是只出现过一次则答案减一，并将此种贝壳种类的个数减一。剩下的直接套模板，时间复杂度 $\\Theta(n \\sqrt n)$。 这道题目还可以用树状数组来解决，时间复杂度为 $\\Theta(n log n)$，参考博客。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// Created by ZJYelizaveta on Monday, September 04, 2017 PM02:12:50 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000000 + 3;const int MAX_M = 200000 + 3;const int INF = 0x3f3f3f3f;int n, m;int a[MAX_N];struct Interval &#123; int l, r, id, pos; bool operator &lt; (const Interval &amp;rhs) const &#123; if (pos == rhs.pos) return r &lt; rhs.r; return pos &lt; rhs.pos; &#125;&#125;q[MAX_M];int ans[MAX_M], blockSize, res;int cnt[MAX_N];inline int insert(int id) &#123; return ++cnt[a[id]] == 1 ? 1 : 0;&#125;inline int remove(int id) &#123; return --cnt[a[id]] == 0 ? -1 : 0;&#125;inline void solve() &#123; memset(cnt, 0, sizeof cnt); int l = 1, r = 0; res = 0; for (int i = 1; i &lt;= m; ++i) &#123; const Interval &amp;b = q[i]; while (r &lt; b.r) &#123;++r; res += insert(r);&#125; while (b.r &lt; r) &#123;res += remove(r); --r;&#125; while (b.l &lt; l) &#123;--l; res += insert(l);&#125; while (l &lt; b.l) &#123;res += remove(l); ++l;&#125; ans[b.id] = res; &#125;&#125;int main()&#123; n = readIn(); blockSize = ceil(sqrt(n)); for (int i = 1; i &lt;= n; ++i) a[i] = readIn(); m = readIn(); for (int i = 1; i &lt;= m; ++i) &#123; q[i].l = readIn(), q[i].r = readIn(), q[i].id = i; q[i].pos = (q[i].l - 1) / blockSize + 1; &#125; sort(q + 1, q + m + 1); solve(); for (int i = 1; i &lt;= m; ++i) printf(\"%d\\n\", ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"莫队","slug":"莫队","permalink":"http://yoursite.com/tags/莫队/"}]},{"title":"UVa 11825 - Hackers' Crackdown","slug":"UVa-11825-Hackers-Crackdown","date":"2017-08-28T02:26:32.000Z","updated":"2017-08-28T02:26:59.836Z","comments":true,"path":"2017/08/28/UVa-11825-Hackers-Crackdown/","link":"","permalink":"http://yoursite.com/2017/08/28/UVa-11825-Hackers-Crackdown/","excerpt":"题目地址 描述一个黑客入侵一个有 $n$ 台计算机 $(1, 2, \\cdots n - 1)$ 的网络，一共有 $n(1 \\leq n \\leq 16)$ 种任务，每台计算机都运行这所有的任务。对于每台计算机可以选择一项服务，终止这台计算机与其相邻计算机之间的这种服务，你需要让尽量多的服务瘫痪。","text":"题目地址 描述一个黑客入侵一个有 $n$ 台计算机 $(1, 2, \\cdots n - 1)$ 的网络，一共有 $n(1 \\leq n \\leq 16)$ 种任务，每台计算机都运行这所有的任务。对于每台计算机可以选择一项服务，终止这台计算机与其相邻计算机之间的这种服务，你需要让尽量多的服务瘫痪。 分析我们尝试把题意抽象一下，一共有 $n$ 个集合 $sub_{1}, sub_{2}, \\cdots, sub_{n}$，将这些集合分成尽量分成多组，使得每组的集合的并集等于全集。因为 $n$ 很小，所以考虑状态压缩，我们用二进制来表示这些集合。 如果第 $i$ 台电脑与第 $j$ 台电脑相连，那么集合 $sub[i]$ 的第 $j$ 位为 $1$。12345678for (register int i = 0; i &lt; n; ++i) &#123; int num = readIn(); sub[i] = 1 &lt;&lt; i; for (register int j = 1; j &lt;= num; ++j) &#123; int cur = readIn(); sub[i] |= (1 &lt;&lt; cur); &#125;&#125; 接下来预处理 $2^{n}$ 种集合组合的并集123456for (register int S = 0; S &lt; (1 &lt;&lt; n); ++S) &#123; cover[S] = 0; for (register int i = 0; i &lt; n; ++i) if (S &amp; (1 &lt;&lt; i)) &#123; cover[S] |= sub[i]; &#125;&#125; 令 $f[S]$ 为子集 $S$ 最多可以分为多少可以覆盖全集的组合，有转移f[S] = max(f[S], (f[S - S0 \\mid S0为S的子集, cover[S0]等于全集) + 1)枚举集合的子集的小技巧 :12345678f[0] = 0;int sum = (1 &lt;&lt; n) - 1;for (register int S = 1; S &lt; (1 &lt;&lt; n); ++S) &#123;// f[S] = 0; for (register int S0 = S; S0; S0 = (S0 - 1) &amp; S) &#123; if (cover[S0] == sum) f[S] = max(f[S], f[S ^ S0] + 1); &#125;&#125; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// Created by ZJYelizaveta on 2017年08月27日 星期日 20时34分04秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 16 + 3;const int MAXNODE = 1 &lt;&lt; MAX_N;const int INF = 0x3f3f3f3f;int testCase;int n;int sub[MAXNODE], f[MAXNODE], cover[MAXNODE];inline void solve() &#123; for (register int S = 0; S &lt; (1 &lt;&lt; n); ++S) &#123; cover[S] = 0; for (register int i = 0; i &lt; n; ++i) if (S &amp; (1 &lt;&lt; i)) &#123; cover[S] |= sub[i]; &#125; &#125; f[0] = 0; int sum = (1 &lt;&lt; n) - 1; for (register int S = 1; S &lt; (1 &lt;&lt; n); ++S) &#123;// f[S] = 0; for (register int S0 = S; S0; S0 = (S0 - 1) &amp; S) &#123; if (cover[S0] == sum) f[S] = max(f[S], f[S ^ S0] + 1); &#125; &#125;&#125;int main()&#123; testCase = 0; while (scanf(\"%d\", &amp;n) &amp;&amp; n != 0) &#123; for (register int i = 0; i &lt; n; ++i) &#123; int num = readIn(); sub[i] = 1 &lt;&lt; i; for (register int j = 1; j &lt;= num; ++j) &#123; int cur = readIn(); sub[i] |= (1 &lt;&lt; cur); &#125; &#125;// for (int i = 0; i &lt; n; ++i) printf(\"%d\\n\", sub[i]); solve(); printf(\"Case %d: %d\\n\", ++testCase, f[(1 &lt;&lt; n) - 1]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"状压DP","slug":"状压DP","permalink":"http://yoursite.com/tags/状压DP/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"}]},{"title":"UVa 10891 - Game of Sum","slug":"UVa-10891-Game-of-Sum","date":"2017-08-28T02:23:33.000Z","updated":"2017-08-29T13:10:24.563Z","comments":true,"path":"2017/08/28/UVa-10891-Game-of-Sum/","link":"","permalink":"http://yoursite.com/2017/08/28/UVa-10891-Game-of-Sum/","excerpt":"题目地址 描述长度为 $n(1 \\leq n \\leq 100)$ 的整数序列，两个玩家 $\\text{A}$ 和 $\\text{B}$ 轮流取数。 $\\text{A}$ 先取，每次每一个玩家只能从序列的一端开始取若干个数，但不能在序列的两端同时取。所有数都被取走后，统计 $\\text{A}, \\text{B}$ 玩家手上的数字的和作为各自的得分。我们假定 $\\text{A}, \\text{B}$ 两个人都很聪明且采用对自己最优的策略，求 $\\text{A}$ 的得分减去 $\\text{B}$ 的得分的结果。","text":"题目地址 描述长度为 $n(1 \\leq n \\leq 100)$ 的整数序列，两个玩家 $\\text{A}$ 和 $\\text{B}$ 轮流取数。 $\\text{A}$ 先取，每次每一个玩家只能从序列的一端开始取若干个数，但不能在序列的两端同时取。所有数都被取走后，统计 $\\text{A}, \\text{B}$ 玩家手上的数字的和作为各自的得分。我们假定 $\\text{A}, \\text{B}$ 两个人都很聪明且采用对自己最优的策略，求 $\\text{A}$ 的得分减去 $\\text{B}$ 的得分的结果。 分析首先我们分析得到不管 $\\text{A}, \\text{B}$ 玩家怎样取，当前的序列一定会是原来的序列的一个连续的子序列。自然而然的我们想到用 $dp[i][j]$ 来表示对于序列 $a[i \\cdots j]$ 在双方都采用最优策略的时候先手能获得的最多的分数。 那么我们转移状态就要枚举是在序列的左边取还是在序列的右边取，分别是这样的 : 从左边开始取，那么剩下的序列为 $a[k \\cdots j] (i &lt; k \\leq j)$ 从右边开始取，那么生鲜的序列为 $a[i \\cdots k] (i \\leq k &lt; j)$ 我们要最小化剩下的序列以保证先手尽量获得更多的分数，那么有转移 : dp[i][j] = \\sum_{l = i}^{l = j}a[l] - min(dp[i + 1][j], dp[i + 1][j], \\cdots, dp[j][j], dp[i][j - 1], dp[i][j - 2], \\cdots, dp[i][i], 0)括号里的 $0$ 表示把序列全部取完，这里不用每次 $\\Theta(n)$ 扫一遍数组，只需要在读入序列 $a[]$ 的时候顺便计算一下前缀和，那么 \\sum_{l = i}^{l = j}a[l] = sum[j] - sum[i - 1] 一共有 $\\Theta(n^{2})$ 的状态，每一个状态有 $\\Theta(n)$ 的转移，所以这样直接枚举转移时间复杂度为 $\\Theta(n^{3})$，时间复杂度尚在接受范围内但是怎样能够更加优化呢？ 考虑状态转移方程dp[i][j] = \\sum_{l = i}^{l = j}a[l] - min(dp[i + 1][j], dp[i + 1][j], \\cdots, dp[j][j], dp[i][j - 1], dp[i][j - 2], \\cdots, dp[i][i], 0) 我们完全可以把最小化的部分分为三部分来计算 : 令 $f[i][j] = min(dp[i][j], dp[i + 1][j], dp[i + 1][j], \\cdots, dp[j][j])$ 令 $g[i][j] = min(dp[i][j], dp[i][j - 1], dp[i][j - 2], \\cdots, dp[i][i])$ 以及 $0$ 那么状态转移方程可以改写为dp[i][j] = \\sum_{l = i}^{l = j}a[l] - min(f[i + 1][j], g[i][j - 1], 0)其中f[i][j] = min(dp[i][j], f[i + 1][j])\\\\ g[i][j] = min(dp[i][j], g[i][j - 1])至此，我们可以在 $\\Theta(1)$ 的时间复杂度内枚举转移，总时间复杂度降为 $\\Theta(n^{2})$ 动态规划的优化，不仅仅可以用单调队列，斜率优化这类数据结构或算法来优化，有时候不妨从动态规划的本质出发。 代码时间复杂度$\\Theta(n^{3})$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Created by ZJYelizaveta on 2017年08月27日 星期日 18时26分39秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int INF = 0x3f3f3f3f;int testCase;int n;int a[MAX_N], sum[MAX_N];int dp[MAX_N][MAX_N], vis[MAX_N][MAX_N];inline int solve(int i, int j) &#123; if (vis[i][j]) return dp[i][j]; vis[i][j] = 1;// int minPart = 0; for (int k = i + 1; k &lt;= j; ++k) minPart = min(minPart, solve(k, j)); for (int k = i; k &lt; j; ++k) minPart = min(minPart, solve(i, k)); dp[i][j] = sum[j] - sum[i - 1] - minPart; return dp[i][j];&#125;int main()&#123;// freopen(\"test.in\", \"r\", stdin); while (scanf(\"%d\", &amp;n) &amp;&amp; n) &#123; memset(sum, 0, sizeof sum); sum[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = readIn(); sum[i] = sum[i - 1] + a[i]; &#125;// for (int i = 1; i &lt;= n; ++i) printf(\"%d \", sum[i]); printf(\"\\n\"); memset(vis, 0, sizeof vis); memset(dp, 0, sizeof dp); printf(\"%d\\n\", 2 * solve(1, n) - sum[n]); &#125; return 0;&#125; 时间复杂度$\\Theta(n^{2})$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Created by ZJYelizaveta on 2017年08月27日 星期日 19时06分10秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int INF = 0x3f3f3f3f;int n;int a[MAX_N], sum[MAX_N];int dp[MAX_N][MAX_N], g[MAX_N][MAX_N], f[MAX_N][MAX_N];int main()&#123; while (scanf(\"%d\", &amp;n) &amp;&amp; n) &#123; memset(sum, 0, sizeof sum); sum[0] = 0; for (register int i = 1; i &lt;= n; ++i) &#123; a[i] = readIn(); sum[i] = sum[i - 1] + a[i]; &#125; memset(dp, 0, sizeof dp); memset(g, 0, sizeof g); memset(f, 0, sizeof f); for (register int i = 1; i &lt;= n; ++i) dp[i][i] = g[i][i] = f[i][i] = a[i]; for (register int l = 1; l &lt; n; ++l) &#123; for (register int i = 1; i + l &lt;= n; ++i) &#123; int j = i + l, minPart = 0; minPart = min(minPart, f[i + 1][j]); minPart = min(minPart, g[i][j - 1]); dp[i][j] = sum[j] - sum[i - 1] - minPart; f[i][j] = min(dp[i][j], f[i + 1][j]); g[i][j] = min(dp[i][j], g[i][j - 1]);// &#125; &#125; printf(\"%d\\n\", 2 * dp[1][n] - sum[n]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"},{"name":"博弈论","slug":"博弈论","permalink":"http://yoursite.com/tags/博弈论/"},{"name":"区间DP","slug":"区间DP","permalink":"http://yoursite.com/tags/区间DP/"}]},{"title":"UVa 10635 - Prince and Princess","slug":"UVa-10635-Prince-and-Princess","date":"2017-08-28T02:21:44.000Z","updated":"2017-08-29T13:10:04.452Z","comments":true,"path":"2017/08/28/UVa-10635-Prince-and-Princess/","link":"","permalink":"http://yoursite.com/2017/08/28/UVa-10635-Prince-and-Princess/","excerpt":"题目地址 描述两个长度为$p + 1$的序列$\\text{A}$和$q + 1$的序列$\\text{B}$，每个序列中的元素各不相同，且都是$1 \\sim n^{2}$之间的整数 $(2 \\leq n \\leq 250)$。两个序列开始的第一个元素都是$1$，求$A$和$B$的最长公共子序列。","text":"题目地址 描述两个长度为$p + 1$的序列$\\text{A}$和$q + 1$的序列$\\text{B}$，每个序列中的元素各不相同，且都是$1 \\sim n^{2}$之间的整数 $(2 \\leq n \\leq 250)$。两个序列开始的第一个元素都是$1$，求$A$和$B$的最长公共子序列。 分析这道题的思想很棒棒呀QAQ就是LCS问题，但是$\\Theta(pq)$的时间复杂度承受不了，要考虑如何来优化。仔细看一遍体面我们发现有描述 :” 每个序列中的元素各不相同 “ 。我们考虑用$1 \\sim p + 1$的数字来对$\\text{A}$重新标号，举一个例子: - 1 2 3 4 5 6 7 A 1 7 5 4 8 3 9 A’ 1 2 3 4 5 6 7 那么原来的序列$\\text{A}$相当于映射到序列$\\text{A’}$，然后我们用序列$\\text{B’}$表示原序列$\\text{B}$通过已知的映射关系解出的新序列，如下: - 1 2 3 4 5 6 7 8 B 1 4 3 5 6 2 8 9 B’ 1 4 6 3 0 0 5 7 那么我们相当于将原来的求最长公共子序列的问题转化成为了求序列$\\text{B’}$的最长上升子序列的长度，而最长上升子序列问题是可以在$\\Theta(nlogn)$的时间复杂度求出来的。 令$dp[i]$为前$i$个数中最大的数的位置，那么把$dp$数组先初始化为$\\infty$。每次在$dp$数组中查询第一个大于等于$a[i]$的位置$(pos)$，然后令$dp[pos] = a[i]$，并更新答案$ans = max(ans, pos)$。 因为这里的$dp$数组保证递增，那么我们可以用二分查找来找位置，复杂度为$\\Theta(logn)$，扫一遍数组$a$的时间复杂度为$\\Theta(n)$，所以时间复杂度为$\\Theta(nlogn)$。 注意: 子序列与子串的区别在于子序列不要求在原字符串中是连续的，而子串要求在原字符串中的连续的。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// Created by ZJYelizaveta on 2017年08月26日 星期六 10时47分50秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 250 + 3;const int MAXNODE = MAX_N * MAX_N;const int INF = 0x3f3f3f3f;int testCase;int n, p, q;int a[MAXNODE];map&lt;int, int&gt; M;int dp[MAXNODE];int main()&#123; testCase = readIn(); for (int num = 1; num &lt;= testCase; ++num) &#123; M.clear(); n = readIn(), p = readIn(), q = readIn(); for (int i = 1; i &lt;= p + 1; ++i) &#123; M[readIn()] = i; &#125; memset(a, 0, sizeof a); for (int i = 1; i &lt;= q + 1; ++i) &#123; int num = readIn(); a[i] = M[num]; &#125;// for (int i = 1; i &lt;= q + 1; ++i) printf(\"%d \", a[i]); printf(\"\\n\"); int cnt = q + 1, ans = 0; memset(dp, INF, sizeof dp); for (int i = 1; i &lt;= cnt; ++i) &#123; int pos = lower_bound(dp + 1, dp + cnt + 1, a[i]) - dp; dp[pos] = a[i]; ans = max(ans, pos); &#125; printf(\"Case %d: %d\\n\", num, ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"最长公共子序列","slug":"最长公共子序列","permalink":"http://yoursite.com/tags/最长公共子序列/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"最长上升子序列","slug":"最长上升子序列","permalink":"http://yoursite.com/tags/最长上升子序列/"}]},{"title":"BZOJ 1579: [Usaco2009 Feb]Revamping Trails 道路升级","slug":"BZOJ-1579-Usaco2009-Feb-Revamping-Trails-道路升级","date":"2017-08-09T12:48:52.000Z","updated":"2017-08-09T12:58:29.742Z","comments":true,"path":"2017/08/09/BZOJ-1579-Usaco2009-Feb-Revamping-Trails-道路升级/","link":"","permalink":"http://yoursite.com/2017/08/09/BZOJ-1579-Usaco2009-Feb-Revamping-Trails-道路升级/","excerpt":"题目地址 描述每天，农夫 John 需要经过一些道路去检查牛棚 $N$ 里面的牛。农场上有$M(1 \\leq M \\leq 50,000)$条双向泥土道路，编号为$1 \\cdots M$， 道路 $i$ 连接牛棚$P1_{i}$和$P2_{i}$ $(1 \\leq P1_{i} \\leq N; 1 \\leq P2_{i} \\leq N)$。John 需要$T_{i} (1 \\leq T_{i} \\leq 1,000,000)$ 时间单位用道路 $i$ 从$P1_{i}$走到$P2_{i}$或者从$P2_{i}$ 走到$P1_{i}$ 他想更新一些路经来减少每天花在路上的时间。具体地说，他想更新 $K (1 \\leq K \\leq 20)$ 条路经，将它们所须时间减为$0$。帮助 FJ 选择哪些路经需要更新使得从 $1$ 到 $N$ 的时间尽量少。","text":"题目地址 描述每天，农夫 John 需要经过一些道路去检查牛棚 $N$ 里面的牛。农场上有$M(1 \\leq M \\leq 50,000)$条双向泥土道路，编号为$1 \\cdots M$， 道路 $i$ 连接牛棚$P1_{i}$和$P2_{i}$ $(1 \\leq P1_{i} \\leq N; 1 \\leq P2_{i} \\leq N)$。John 需要$T_{i} (1 \\leq T_{i} \\leq 1,000,000)$ 时间单位用道路 $i$ 从$P1_{i}$走到$P2_{i}$或者从$P2_{i}$ 走到$P1_{i}$ 他想更新一些路经来减少每天花在路上的时间。具体地说，他想更新 $K (1 \\leq K \\leq 20)$ 条路经，将它们所须时间减为$0$。帮助 FJ 选择哪些路经需要更新使得从 $1$ 到 $N$ 的时间尽量少。 分析跟“BZOJ 2763: [JLOI2011]飞行路线”这道题目套路一样，都是分层图最短路，不过数据加强了一下。还有听说会卡 SPFA ，最好还是写堆优化的 Dijkstra 吧QAQ如果不是很理解分层图最短路的话可以看一下我上一篇博客BZOJ 2763解题报告 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 1579: [Usaco2009 Feb]Revamping Trails 道路升级// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int MAX_M = 50000 + 3;const int MAX_K = 20 + 3;const int INF = 0x3f3f3f3f;int n, m, k;struct Edge &#123; int to, next, dist, rest; Edge (int to = 0, int dist = 0, int rest = 0) : to(to), next(next), dist(dist), rest(rest)&#123;&#125; bool operator &lt; (const Edge &amp;rhs) const &#123; return dist &gt; rhs.dist; &#125;&#125;edge[MAX_M &lt;&lt; 1];int head[MAX_M], cnt = 0;int dp[MAX_N][MAX_K], ans;inline void addEdge(int from, int to, int cost) &#123; edge[++cnt].to = from; edge[cnt].dist = cost; edge[cnt].next = head[to]; head[to] = cnt; edge[++cnt].to = to; edge[cnt].dist = cost; edge[cnt].next = head[from]; head[from] = cnt;&#125;inline void dijkstra(int s) &#123; priority_queue&lt;Edge&gt; q; memset(dp, INF, sizeof dp); dp[0][k] = 0; q.push(Edge(0, 0, k)); while (!q.empty()) &#123; Edge cur = q.top(); q.pop(); int u = cur.to, dist = cur.dist, rest = cur.rest; if (dp[u][rest] &lt; dist) continue; dp[u][rest] = dist; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (dp[u][rest] + edge[i].dist &lt; dp[v][rest]) q.push(Edge(v, dp[u][rest] + edge[i].dist, rest)); if (rest &amp;&amp; dp[u][rest] &lt; dp[v][rest - 1]) q.push(Edge(v, dp[u][rest], rest - 1)); &#125; &#125;&#125;int main()&#123; n = readIn(), m = readIn(), k = readIn(); memset(head, -1, sizeof head); for (int i = 0; i &lt; m; ++i) &#123; int u = readIn(), v = readIn(), w = readIn(); --u; --v; addEdge(u, v, w); &#125; dijkstra(0); ans = INF; for (int i = 0; i &lt;= k; ++i) ans = min(ans, dp[n - 1][i]); printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://yoursite.com/tags/Dijkstra/"},{"name":"分层图最短路","slug":"分层图最短路","permalink":"http://yoursite.com/tags/分层图最短路/"}]},{"title":"BZOJ 2763: [JLOI2011]飞行路线","slug":"BZOJ-2763-JLOI2011-飞行路线","date":"2017-08-08T14:31:19.000Z","updated":"2017-08-09T13:00:31.918Z","comments":true,"path":"2017/08/08/BZOJ-2763-JLOI2011-飞行路线/","link":"","permalink":"http://yoursite.com/2017/08/08/BZOJ-2763-JLOI2011-飞行路线/","excerpt":"题目地址 描述Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 $n$ 个城市设有业务，设这些城市分别标记为 $0$ 到 $n-1$ ，一共有 $m$ 种航线，每种航线连接两个城市，并且航线有一定的价格。Alice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 $k$ 种航线上搭乘飞机。那么 Alice 和 Bob 这次出行最少花费多少？","text":"题目地址 描述Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 $n$ 个城市设有业务，设这些城市分别标记为 $0$ 到 $n-1$ ，一共有 $m$ 种航线，每种航线连接两个城市，并且航线有一定的价格。Alice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 $k$ 种航线上搭乘飞机。那么 Alice 和 Bob 这次出行最少花费多少？ 对于$30 \\%$的数据，$2 \\leq n \\leq 50$，$1 \\leq m \\leq 300$，$k = 0$对于$50 \\%$的数据，$2 \\leq n \\leq 600$，$1 \\leq m \\leq 6000$，$0 \\leq k \\leq 1$对于$100 \\%$的数据，$2 \\leq n \\leq 10000$，$1 \\leq m \\leq 50000$，$0 \\leq k \\leq 10$ 分析刚开始做这道题目的时候一点思路都没有，好像只会$50 \\%$的数据的算法，无奈，去查了一下题解，可能这道题目太简单了，题解都很简洁但是我实在太蒻了看不懂呀，于是我仔细研究了一下，好像是这样的QAQ一篇比较好的题解是这样的 $dp[i][j]$ 表示到达 $i$ 点时还有 $j$ 次边权置 $0$ 机会的最小花费，初始时 $dp[s][k]=0$，其余置为正无穷，然后随$Dijkstra$或$SPFA$转移即可，最终答案为$max (dp[t][i] \\mid 0 \\leq i \\leq k )$。 首先，其实这道题目问的就是“有$n$个点$m$条边，可以把$k$条边的边权置为$0$，求$s$到$t$的最短路”。 我们观察数据范围发现$k$比较小，我们可以通过$k$来划分阶段，那么最多有$11$个阶段，每个阶段分别为已经将$m$条边中的$k$条边的边权置为$0$的最短路。有明显的阶段性，我们考虑$DP$来转移每一层到下一层的状态。那么我们只要$DP$一下把每一层的最短路都求出来，再扫一遍$DP$数组，取一下$minAns$就可以了。 这里虽然说求的是分层图的最短路，但是实际上我们是不用把每一层的都建出来的。 对于每一条边考虑是否要将这一条边权置为$0$，（$u$为$v$的父亲结点）： 如果考虑将这一条边权置为$0$，考虑是否还有剩余机会若有则转移到下一层（向下一层的连边边权为$0$）；再考虑$dp[u][rest]是否小于dp[v][rest - 1]$，若成立则$q.push(Node(v, dp[u][rest], rest - 1))$。 若不考虑将边权置为$0$，那么更新当前答案：若$if (dp[u][rest] + edge[i].dist &lt; dp[v][rest])$成立，则$q.push(Node(v, dp[u][rest] + edge[i].dist, rest))$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// BZOJ 2763 [JLOI2011]飞行路线// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef pair&lt;int, int&gt; pii;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int MAX_M = 50000 + 3;const int MAX_K = 10 + 3;const int INF = 0x3f3f3f3f;int n, m, k;int s, t;struct Edge &#123; int to, next, dist, rest; Edge (int to = 0, int dist = 0, int rest = 0) : to(to), dist(dist), rest(rest)&#123;&#125;; bool operator &lt; (const Edge &amp;rhs) const &#123; return dist &gt; rhs.dist;//注意定义QAQ &#125;&#125;edge[MAX_M &lt;&lt; 1];typedef Edge Node;int head[MAX_N], cnt = 0;int dp[MAX_N][MAX_K];inline void addEdge(int from, int to, int cost) &#123; edge[++cnt].to = to; edge[cnt].dist = cost; edge[cnt].next = head[from]; head[from] = cnt; edge[++cnt].to = from; edge[cnt].dist = cost; edge[cnt].next = head[to]; head[to] = cnt;&#125;inline void dijkstra(int s) &#123; priority_queue&lt;Edge&gt; q; memset(dp, INF, sizeof dp); dp[s][k] = 0; q.push(Node(s, 0, k)); while (!q.empty()) &#123; Node cur = q.top(); q.pop(); int u = cur.to, dist = cur.dist, rest = cur.rest; if (dp[u][rest] &lt; dist) continue; dp[u][rest] = dist; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (dp[u][rest] + edge[i].dist &lt; dp[v][rest]) q.push(Node(v, dp[u][rest] + edge[i].dist, rest)); if (rest &amp;&amp; dp[u][rest] &lt; dp[v][rest - 1]) q.push(Node(v, dp[u][rest], rest - 1)); &#125; &#125;&#125;int main()&#123; n = readIn(), m = readIn(), k = readIn(); s = readIn(), t = readIn(); memset(head, -1, sizeof head); for (int i = 0; i &lt; m; ++i) &#123; int u = readIn(), v = readIn(), w = readIn(); addEdge(u, v, w); &#125; dijkstra(s); int ans = INF; for (int i = 0; i &lt;= k; ++i) ans = min(ans, dp[t][i]); printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://yoursite.com/tags/Dijkstra/"},{"name":"分层图最短路","slug":"分层图最短路","permalink":"http://yoursite.com/tags/分层图最短路/"}]},{"title":"[模板]哈夫曼树","slug":"模板-哈夫曼树","date":"2017-08-08T05:24:12.000Z","updated":"2017-08-08T05:25:00.140Z","comments":true,"path":"2017/08/08/模板-哈夫曼树/","link":"","permalink":"http://yoursite.com/2017/08/08/模板-哈夫曼树/","excerpt":"定义哈夫曼树（Huffman Tree）是一种带权路径长度最短的二叉树，也称为最优二叉树。","text":"定义哈夫曼树（Huffman Tree）是一种带权路径长度最短的二叉树，也称为最优二叉树。 树的带权路径长度：如果树中每个叶子上都带有一个权值，则把树中所有叶子的带权路径长度之和称为树的带权路径长度。 结点的带权路径长度：在一棵树中，如果其结点上附带有一个权值，通常把该结点到根结点的路径长度与该结点上的权值之积称为该结点的带权路径长度。 对一棵有$n$个叶子结点的二叉树，这棵树的带权路径长度len = \\sum_{i = 1}^{n}w_{i}l_{i}其中$w_{i}$为第$i$个叶子结点的权值，$l_{i}$为第$i$个叶子结点的路径长度。 而哈夫曼树可以最小化$\\sum_{i = 1}^{n}w_{i}l_{i}$这个式子，举一个栗子吧，如图所示 构造如果我们要构造一棵哈夫曼树，那么我们怎样来构造呢QAQ根据哈弗曼树的定义，一棵二叉树要使其带权路径长度最小，必须使权值越大的叶子结点越靠近根结点，而权值越小的叶子结点越远离根结点。 如果只要求求出最小化这个式子$\\sum_{i = 1}^{n}w_{i}l_{i}$的值： 我们可以用优先队列维护一个小根堆，先将所有的叶子结点放入小根堆。 当堆中元素个数大于$1$时，每次取出堆中两个最小元素，它们同为一个结点的左右儿子，且它们的父亲结点（非叶结点）的权值为两个元素之和 将两个叶子结点的父亲结点（非叶结点）的权值放回堆中 循环往复，直至堆中元素个数小于等于$1$ 实际上构建一棵哈夫曼树的思想和上述的差不多，具体如下： 将所有左，右子树都为空的点作为根结点。 在森林中选出两棵根结点的权值最小的树作为一棵新树的左、右子树，且令新树的新增加的根结点的权值为其左、右子树上根结点的权值之和。注意，左子树的权值应小于右子树的权值。 从森林中删除这两棵树，同时把新树加入到森林中。 重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。 哈夫曼编码哈夫曼编码（Huffman Coding）是可变字长编码(VLC)的一种，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码。我们把哈夫曼编码放在哈夫曼树上来理解，其实就是将每个二叉树的左边指定为$0$，右边指定为$1$。如图所示：一般我们所说的哈夫曼编码一般都是最有效的二进制编码，当然那么也会有最优的$k$进制编码QAQ 哈夫曼编码还有一个神奇的性质： Huffman编码使得每一个字符的编码都与另一个字符编码的前一部分不同，也就是说现在有字符$Str_{i},Str{j}$且$i &lt; j$，那么一定不存在$Str_{i}$为$Str_{j}$的前缀。 例题「NOIP 2004」 合并果子相信阅读以上之后，这道题目对你而言是一道很水的题目，相信你不看题解也能做出来哟QAQ，当然还是放上解题报告来骗流量=w=解题报告QAQ 「NOI 2015」 荷马史诗这其实维护的是一棵$k$叉的哈夫曼树具体的还是看解题报告里面吧，我觉得我写的挺清楚了QAQ解题报告QAQ","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"哈夫曼树","slug":"哈夫曼树","permalink":"http://yoursite.com/tags/哈夫曼树/"},{"name":"哈夫曼编码","slug":"哈夫曼编码","permalink":"http://yoursite.com/tags/哈夫曼编码/"}]},{"title":"「NOI 2015」 荷马史诗","slug":"「NOI-2015」-荷马史诗","date":"2017-08-08T05:19:13.000Z","updated":"2017-08-08T05:21:02.598Z","comments":true,"path":"2017/08/08/「NOI-2015」-荷马史诗/","link":"","permalink":"http://yoursite.com/2017/08/08/「NOI-2015」-荷马史诗/","excerpt":"题目地址 描述 追逐影子的人，自己就是影子。 ——荷马 Allison 最近迷上了文学。她喜欢在一个慵懒的午后，细细地品上一杯卡布奇诺，静静地阅读她爱不释手的《荷马史诗》。《荷马史诗》实在是太长了，Allison 想通过一种编码方式使得它变得短一些。 一部《荷马史诗》中有 $n$ 种不同的单词，从 $1$ 到 $n$ 进行编号。其中第 $i$ 种单词出现的总次数为 $w_{i}$。Allison 想要用 $k$ 进制串 $s_{i}$ 来替换第 $i$ 种单词，使得其满足如下要求: 对于任意的 $1 \\leq i,j \\leq n$，$i \\neq j$，都有：$s_{i}$ 不是 $s_{j}$ 的前缀。 现在 Allison 想要知道，如何选择 $s_{i}$，才能使替换以后得到的新的《荷马史诗》长度最小。在确保总长度最小的情况下，Allison 还想知道最长的 $s_{i}$ 的最短长度是多少？","text":"题目地址 描述 追逐影子的人，自己就是影子。 ——荷马 Allison 最近迷上了文学。她喜欢在一个慵懒的午后，细细地品上一杯卡布奇诺，静静地阅读她爱不释手的《荷马史诗》。《荷马史诗》实在是太长了，Allison 想通过一种编码方式使得它变得短一些。 一部《荷马史诗》中有 $n$ 种不同的单词，从 $1$ 到 $n$ 进行编号。其中第 $i$ 种单词出现的总次数为 $w_{i}$。Allison 想要用 $k$ 进制串 $s_{i}$ 来替换第 $i$ 种单词，使得其满足如下要求: 对于任意的 $1 \\leq i,j \\leq n$，$i \\neq j$，都有：$s_{i}$ 不是 $s_{j}$ 的前缀。 现在 Allison 想要知道，如何选择 $s_{i}$，才能使替换以后得到的新的《荷马史诗》长度最小。在确保总长度最小的情况下，Allison 还想知道最长的 $s_{i}$ 的最短长度是多少？ 分析我们仔细分析一下发现好像和合并果子有一点像呀QAQ $n$种不同的单词相当于树上的$n$个结点，我们可以把单词的出现次数$(w_{i}为第i个单词的出现次数)$当成该结点的权值，而结点到树的根结点的路径长度（也可以说是深度）就是$k$进制串$s_{i}$的长度$(l_{i}为第i个单词的长度)$，那么我们要最小化的就是 len = \\sum_{i = 1}^{n} w_{i}l_{i}我们发现这和之前让我们最小化的哈夫曼树的$len$形式上是一样的，我们考虑哈夫曼树的构造过程其实就是“使权值越大的叶子结点越靠近根结点，而权值越小的叶子结点越远离根结点”，那么这里也是一样的。 那么这其实就是最小化一棵$k$叉的哈夫曼树的带权路径长度。 刚开始我一直不明白为什么一定是一棵$k$叉哈夫曼树，其实很好理解，我们可以从哈夫曼编码的方面来思考： 其实我们就是每次贪心使得出现次数最多的单词用$k$ 进制串 $s_{i}$替换后的$s_{i}$长度最小 而$k$进制串$s_{i}$的长度相当于结点到树的根结点的路径长度（也可以说是深度），那么我们要最小化深度 也就是我们要尽量将哈夫曼树中每一层$k$进制在当前层对应的$k$个结点尽量填满 那么也就是说一个满$k$叉的哈夫曼树一定会更优一些 在$k$叉哈夫曼树每回都满叉的情况下，我们像维护一棵普通的二叉哈夫曼树一样用一个优先队列来维护。 但是若存在哈夫曼树的某一层的上，哈夫曼树并不能满$k$叉呢QAQ和我们构造最优二叉哈夫曼树一样每次合并引入虚拟结点令其权值为左右儿子权值之和，这里我们一样引入虚拟结点的概念，我们让权值为$0$的虚拟结点来填补使得$k$叉哈夫曼树是满$k$叉的。我们每次更新$n = n - k + 1$，然后判断$(n - 1) % (k - 1)$如果等于$0$就是满$k$叉；否则要用虚拟结点来填补，一共需要$(k - 1) - ((n - 1) \\% (k - 1))$个虚拟结点。 然而此题还要求$s_{i}$的最大值最小，那么我们让$k$叉哈夫曼树的结点代表一个二元组$(val，len)$，表示这个结点的权值和结点到根结点的路径长度。在求最小$k$个点时，把$val$作为第一比较条件，如果$val$值相等，则把$len$小的放在前面，这样在每次合并的时候，长度小的点都会被优先合并，保证了根到叶子的最长链的长度尽量小。 所以，可以得到此题的算法： 用优先队列把$(val,len = 0)$$Push$进去，处理虚拟点$(val = 0, len = 0)$。 每次用优先队列弹出前$k$小的点，求它们的$val$之和$sum$，求它们的$len$的最大值$length$，那么将结点$(sum,length+1)$加入优先队列，且$ans+=sum$。 当容器内只有一个点时，输出$ans$和这个点的$len$值。 最终时间复杂度是$\\Theta (nlogn)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 「NOI 2015」 荷马史诗// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline ll readIn() &#123; ll x = 0; int f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return (ll)x * f;&#125;const int MAX_N = 100000 + 3;const int INF = 0x3f3f3f3f;ll n, k;struct Node &#123; ll val, len; Node (const ll val, const ll len) : val(val), len(len)&#123;&#125; bool operator &lt; (const Node &amp;rhs) const &#123; if (val == rhs.val) return len &gt; rhs.len;//注意定义 return val &gt; rhs.val;// &#125;&#125;;priority_queue&lt;Node&gt; q;ll ans, sum, maxLen, cnt;int main()&#123; n = readIn(), k = readIn(); while (!q.empty()) q.pop(); for (int i = 1; i &lt;= n; ++i) &#123; ll val = readIn(); q.push(Node(val, 0)); &#125; cnt = n; if ((n - 1) % (k - 1)) cnt += ((k - 1) - ((n - 1) % (k - 1))); for (int i = n + 1; i &lt;= cnt; ++i) q.push(Node(0, 0));/* for (int i = 1; i &lt;= n; ++i) &#123; Node cur = q.top(); q.pop(); printf(\"%lld %lld\\n\", cur.val, cur.len); &#125;*/ ans = 0; while (q.size() &gt; 1) &#123; sum = 0, maxLen = 0; for (int i = 1; i &lt;= k; ++i) &#123; Node cur = q.top(); q.pop(); sum += cur.val; maxLen = max(maxLen, cur.len); &#125; ans += sum; q.push(Node(sum, maxLen + 1)); &#125; printf(\"%lld\\n%lld\\n\", ans, q.top().len); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"哈夫曼树","slug":"哈夫曼树","permalink":"http://yoursite.com/tags/哈夫曼树/"},{"name":"哈夫曼编码","slug":"哈夫曼编码","permalink":"http://yoursite.com/tags/哈夫曼编码/"},{"name":"NOI","slug":"NOI","permalink":"http://yoursite.com/tags/NOI/"}]},{"title":"「NOIP 2004」 合并果子","slug":"「NOIP-2004」-合并果子","date":"2017-08-07T16:14:34.000Z","updated":"2017-08-07T16:17:21.309Z","comments":true,"path":"2017/08/08/「NOIP-2004」-合并果子/","link":"","permalink":"http://yoursite.com/2017/08/08/「NOIP-2004」-合并果子/","excerpt":"题目地址 描述在一个果园里，多多按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过$n-1$次合并之后，就只剩下一堆了，多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。多多在合并果子时要尽可能地节省体力。假定每个果子重量都为$1$，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。$1 \\leq n \\leq 10000$","text":"题目地址 描述在一个果园里，多多按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过$n-1$次合并之后，就只剩下一堆了，多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。多多在合并果子时要尽可能地节省体力。假定每个果子重量都为$1$，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。$1 \\leq n \\leq 10000$ 分析其实是一道哈夫曼树的裸题QAQ我们仔细分析冗长的题面后发现，题目其实就是让我们最小化这个式子$\\sum_{i = 1}^{n}w_{i}l_{i}$的值，我们可以进行如下的操作： 我们可以用优先队列维护一个小根堆，先将所有的叶子结点放入小根堆。 当堆中元素个数大于$1$时，每次取出堆中两个最小元素，它们同为一个结点的左右儿子，且它们的父亲结点（非叶结点）的权值为两个元素之和。 将两个叶子结点的父亲结点（非叶结点）的权值放回堆中。 循环往复，直至堆中元素个数小于等于$1$。 时间复杂度为$\\Theta(n)$ 代码1234567891011121314151617181920212223242526272829303132333435363738// NOIP 2004 合并果子// Copyright (c) 2017年 ZJYelizaveta. All rights reserved;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int INF = 0x3f3f3f3f;int n;priority_queue&lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;int ans;int main()&#123; n = readIn(); while (!q.empty()) q.pop(); for (int i = 0; i &lt; n; ++i) &#123; int num = readIn(); q.push(num); &#125; ans = 0; while (q.size() &gt; 1) &#123; int a = q.top(); q.pop(); int b = q.top(); q.pop(); ans += (a + b); q.push(a + b); &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"NOIP","slug":"NOIP","permalink":"http://yoursite.com/tags/NOIP/"},{"name":"哈夫曼树","slug":"哈夫曼树","permalink":"http://yoursite.com/tags/哈夫曼树/"}]},{"title":"BZOJ 1578: [Usaco2009 Feb]Stock Market 股票市场","slug":"BZOJ-1578-Usaco2009-Feb-Stock-Market-股票市场","date":"2017-08-02T15:32:50.000Z","updated":"2017-08-08T07:31:07.891Z","comments":true,"path":"2017/08/02/BZOJ-1578-Usaco2009-Feb-Stock-Market-股票市场/","link":"","permalink":"http://yoursite.com/2017/08/02/BZOJ-1578-Usaco2009-Feb-Stock-Market-股票市场/","excerpt":"题目地址 描述尽管奶牛们天生谨慎，她们仍然在住房抵押信贷市场中受到打击，现在她们开始着手于股市。 Bessie很有先见之明，她不仅知道今天$S (2 \\leq S \\leq 50)$只股票的价格，还知道接下来一共$D(2 \\leq D \\leq 10)$天的（包括今天）。给定一个$D$天的股票价格矩阵$（1 \\leq 价格 \\leq 1000）$以及初始资金$M(1 \\leq M \\leq 200,000)$，求一个最优买卖策略使得最大化总获利。每次必须购买股票价格的整数倍，同时你不需要花光所有的钱（甚至可以不花）。这里约定你的获利不可能超过$500,000$。","text":"题目地址 描述尽管奶牛们天生谨慎，她们仍然在住房抵押信贷市场中受到打击，现在她们开始着手于股市。 Bessie很有先见之明，她不仅知道今天$S (2 \\leq S \\leq 50)$只股票的价格，还知道接下来一共$D(2 \\leq D \\leq 10)$天的（包括今天）。给定一个$D$天的股票价格矩阵$（1 \\leq 价格 \\leq 1000）$以及初始资金$M(1 \\leq M \\leq 200,000)$，求一个最优买卖策略使得最大化总获利。每次必须购买股票价格的整数倍，同时你不需要花光所有的钱（甚至可以不花）。这里约定你的获利不可能超过$500,000$。 分析是一道想法还是挺妙的一道题目看这道题目的时候总觉得有一点熟悉的感觉，怎么这么像背包DP，事实上这就是一个背包DP QAQ 但是还是有一个挺奇妙的想法就是“不用考虑一支买进的股票在哪一天卖出，我们只需要今天买进明天卖出就可以了” 有了这个结论那么就好做了，我们把每一天当做一个完全背包来做，背包的体积为手中持有的资金，背包有两个状态： 一个是不买进，也不卖出 还有一个是买进当前的一只股票，并在明天卖出 那么我们有状态$dp[k]$为手中持有资金为$k$时能获利最多的钱转移方程为dp[k] = max(dp[k], dp[k - w[i][j]] + w[i][j + 1] - w[i][j])(k为持有资金, i为第i支股票, j为第j天)每天做一次完全背包并更新手中持有资金，然后做出来了QAQ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243// BZOJ 1578 [Usaco2009 Feb]Stock Market 股票市场// Copyright (c) 2017年 ZJYelizaveta. All rights reserved;#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_S = 50 + 3;const int MAX_D = 10 + 3;const int MAX_M = 500000 + 3;const int INF = 0x3f3f3f3f;int s, d, m;int w[MAX_S][MAX_D];int dp[MAX_M], ans;int main()&#123; s = readIn(), d = readIn(), m = readIn(); for (int i = 0; i &lt; s; ++i) &#123; for (int j = 0; j &lt; d; ++j) w[i][j] = readIn(); &#125; ans = m; memset(dp, 0, sizeof dp); for (int i = 0; i &lt; d; ++i) &#123; memset(dp, 0, sizeof dp); for (int j = 0; j &lt; s; ++j) &#123; for (int k = w[j][i]; k &lt;= ans; ++k) &#123; dp[k] = max(dp[k], dp[k - w[j][i]] + w[j][i + 1] - w[j][i]); &#125; &#125; ans += dp[ans]; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"[模板]传递闭包","slug":"模板-传递闭包","date":"2017-08-02T06:35:27.000Z","updated":"2017-08-02T06:36:50.877Z","comments":true,"path":"2017/08/02/模板-传递闭包/","link":"","permalink":"http://yoursite.com/2017/08/02/模板-传递闭包/","excerpt":"很久之前听说过，今天学习一下QAQ 简介传递闭包，在数学中表示为在集合 $X$ 上的二元关系 $R$ 的传递闭包是包含 $R$ 的 $X$ 上的最小的传递关系。","text":"很久之前听说过，今天学习一下QAQ 简介传递闭包，在数学中表示为在集合 $X$ 上的二元关系 $R$ 的传递闭包是包含 $R$ 的 $X$ 上的最小的传递关系。 而在图论中就是如果$u \\rightarrow v$有一条边，$v \\rightarrow t$有一条边，那么$u$能到达$t$。而我们求传递闭包，就是把图中所有满足这样传递性的结点都枚举出来，计算完成后，我们就知道任意两个结点之间是否相连。 应该就是这样理解的，如果有理解不当的地方欢迎指出QAQ 代码$n$个点$m$条边，用$Floyd$求传递闭包，代码应该比较好理解就不解释了QAQ12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int INF = 0x3f3f3f3f;int n, m;bool con[MAX_N][MAX_N];int main()&#123; n = readIn(), m = readIn(); memset(con, 0, sizeof con); for (int i = 0; i &lt; m; ++i) &#123; int u = readIn() - 1, v = readIn() - 1; con[u][v] = 1; &#125; for (int k = 0; k &lt; n; ++k) &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; con[i][j] = con[i][j] || (con[i][k] &amp;&amp; con[k][j]); // 判断两个点联通的两个情况 &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"传递闭包","slug":"传递闭包","permalink":"http://yoursite.com/tags/传递闭包/"}]},{"title":"BZOJ 1577: [Usaco2009 Feb]庙会捷运Fair Shuttle","slug":"BZOJ-1577-Usaco2009-Feb-庙会捷运Fair-Shuttle","date":"2017-08-01T14:42:35.000Z","updated":"2017-08-01T14:43:32.216Z","comments":true,"path":"2017/08/01/BZOJ-1577-Usaco2009-Feb-庙会捷运Fair-Shuttle/","link":"","permalink":"http://yoursite.com/2017/08/01/BZOJ-1577-Usaco2009-Feb-庙会捷运Fair-Shuttle/","excerpt":"题目地址 描述公交车一共经过$N(1 \\leq N \\leq 20000)$个站点，从站点$1$一直驶到站点$N$。$K(1\\leq K \\leq 50000)$群奶牛希望搭乘这辆公交车，第$i$群牛一共$M_{i}(1\\leq M_{i} \\leq N)$只，他们希望从$S_{i}$到$E_{i}$去。公交车只能坐$C(1\\leq C \\leq 100)$只奶牛，而且不走重复路线，请计算这辆车最多能满足多少奶牛听要求。注意：对于每一群奶牛，可以部分满足，也可以全部满足，也可以全部不满足。","text":"题目地址 描述公交车一共经过$N(1 \\leq N \\leq 20000)$个站点，从站点$1$一直驶到站点$N$。$K(1\\leq K \\leq 50000)$群奶牛希望搭乘这辆公交车，第$i$群牛一共$M_{i}(1\\leq M_{i} \\leq N)$只，他们希望从$S_{i}$到$E_{i}$去。公交车只能坐$C(1\\leq C \\leq 100)$只奶牛，而且不走重复路线，请计算这辆车最多能满足多少奶牛听要求。注意：对于每一群奶牛，可以部分满足，也可以全部满足，也可以全部不满足。 分析蒟蒻日常一水QAQ看到这个题目很容易想到贪心，实际上这道题目本质就是一道贪心的经典题目“活动安排问题”。 首先我们按照每一群奶牛的终点排序，若终点相同则按照起点排序。然后用一个数组$b[]$来维护$1 \\sim n$每个结点上的最多奶牛数量。然后$1 \\sim k$只奶牛从前到后扫一遍，对于每一只奶牛$i$若$b[i] &lt; c$则可以继续考虑，否则考虑下一只奶牛。对于每一只被考虑的奶牛，记一只奶牛从$s$到$e$中最少能够再加入的奶牛只数$temp$（相当于维护了每一个结点奶牛数量尽可能多），然后对于奶牛所处的$s$到$e$的结点扫一遍更新$temp$。然后考虑$temp$大于等于当前奶牛群只数的情况以及小于的情况，更新$b[]$以及$ans$。 在数据范围较小的时候，这样做是可以水过去的，但是在数据范围较大的时候还是需要用线段树来维护区间的最大值，所以我明天再来补一下用线段树维护的版本吧QAQ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// BZOJ 1577 [Usaco2009 Feb]庙会捷运Fair Shuttle// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 20000 + 3;const int MAX_K = 50000 + 3;const int INF = 0x3f3f3f3f;int k, n, c;// cows, points, containstruct Node &#123; int s, e, m; bool operator &lt; (const Node &amp;rhs) const &#123; if (e == rhs.e) return s &lt; rhs.s; return e &lt; rhs.e; &#125;&#125;a[MAX_K];int b[MAX_N], ans, temp;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif k = readIn(), n = readIn(), c = readIn(); for (int i = 0; i &lt; k; ++i) a[i].s = readIn(), a[i].e = readIn(), a[i].m = readIn(); sort(a, a + k); ans = 0, temp = 0; memset(b, 0, sizeof b); for (int i = 0; i &lt; k; ++i) &#123; temp = INF; if (b[a[i].s] &lt; c) &#123; for (int j = a[i].s; j &lt; a[i].e; ++j) &#123; temp = min(temp, c - b[j]); if (temp == 0) break; &#125; if (temp != 0) &#123; if (temp &gt;= a[i].m) &#123; for (int j = a[i].s; j &lt; a[i].e; ++j) b[j] += a[i].m; ans += a[i].m; &#125; else &#123; for (int j = a[i].s; j &lt; a[i].e; ++j) b[j] += temp; ans += temp; &#125; &#125; &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}]},{"title":"[Codeforces 19D] Points","slug":"Codeforces-19D-Points","date":"2017-07-30T03:29:41.000Z","updated":"2017-07-31T05:06:54.370Z","comments":true,"path":"2017/07/30/Codeforces-19D-Points/","link":"","permalink":"http://yoursite.com/2017/07/30/Codeforces-19D-Points/","excerpt":"题目地址 描述在二维平面上内进行$n (1 \\leq n \\leq 2 \\cdot 10^{5})$次操作，一共有三种种类的操作： $add$ $x,y$ 将点$(x,y)$加入二维平面坐标系内。 $remove$ $x,y$ 将点$(x,y)$从二维平面坐标系内删除。 $find$ $x,y$ 找到点$(x,y)$右上角的点集$(x_{i} &gt; x, y_{i} &gt; y)$。如果有多个输出$x$最小的，若还是存在多个输出$y$最小的。 每次操作满足$x,y$均为非负数，且操作合法。","text":"题目地址 描述在二维平面上内进行$n (1 \\leq n \\leq 2 \\cdot 10^{5})$次操作，一共有三种种类的操作： $add$ $x,y$ 将点$(x,y)$加入二维平面坐标系内。 $remove$ $x,y$ 将点$(x,y)$从二维平面坐标系内删除。 $find$ $x,y$ 找到点$(x,y)$右上角的点集$(x_{i} &gt; x, y_{i} &gt; y)$。如果有多个输出$x$最小的，若还是存在多个输出$y$最小的。 每次操作满足$x,y$均为非负数，且操作合法。 分析是一道很有趣的题目QAQ首先我们考虑在可以完成前两个操作的前提下，如何能够快速的找到在$(x, y)$右上角中满足条件的最小的点的坐标。 显而易见我们会想到对于$x$的不同取值维护一个$set$ ( 每一个$set$中维护$x’ = val$时$y’$的取值 ) ，只要我们能快速找到满足条件的最小的$x$，那么我们就可以用$set$中的upper_bound快速查询在$x’$取最小值的时候第一个大于$y$的$y’$的取值。 那么我们现在只用实现快速查询大于$x$的第一个$x’$的值即可 ，我们可以用一棵线段树来维护和支持查询满足条件的最小的$x$。 由于$1 \\leq x_{i}, y_{i} \\leq 10^{9}$，所以我们考虑将坐标$x$离散化那么线段树上最多$2n$个结点，然后我们尝试构造一棵线段树，线段树的每个叶子节点维护一个$set$，$set$里面维护的就是我们前面说的 “ 坐标为$x’ = val$的点的$y$坐标的集合 ”，而线段树维护区间内所有点能达到的$y$的最大值。 每次插入删除点的时候就在线段树上单点更新。 查询的时候看区间$[x+1, m]$内$node[o].maxy$是否大于$y$，若不存在则返回$-1$，否则返回最左边满足集合内存在$y$坐标大于查询的值的下标，然后在下标所在的集合二分查询最小的大于$y$的$y’$值即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// Created by ZJYelizaveta on 2017年07月31日 星期一 08时09分18秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 200000 + 3;const int INF = 0x3f3f3f3f;int n, m;struct Operations &#123; char str[10]; int x, y;&#125;op[MAX_N];int a[MAX_N];set&lt;int&gt; s[MAX_N];namespace segmentTree &#123; #define ls ((o) &lt;&lt; 1) #define rs (((o) &lt;&lt; 1) + 1) #define mid (((l) + (r)) &gt;&gt; 1) struct Node &#123; int maxy; &#125;node[MAX_N * 4]; inline void build(int o, int l, int r) &#123; node[o].maxy = -1; if (l == r) return;// printf(\"%d %d %d %d %d %d\\n\", o, l, r, ls, rs, mid); build(ls, l, mid); build(rs, mid + 1, r); &#125; void modify(int o, int l, int r, int pos) &#123; if (l == r) &#123; if (s[pos].size()) node[o].maxy = *(--s[pos].end()); else node[o].maxy = -1; return; &#125; if (pos &lt;= mid) modify(ls, l, mid, pos); else modify(rs, mid + 1, r, pos); node[o].maxy = max(node[ls].maxy, node[rs].maxy); &#125; int query(int o, int l, int r, int lc, int rc, int val) &#123; if (node[o].maxy &lt;= val || lc &gt; rc) return -1;// if (l == r) return l;// if (rc &lt;= mid) return query(ls, l, mid, lc, rc, val); else if (lc &gt; mid) return query(rs, mid + 1, r, lc, rc, val);// else &#123; int temp = query(ls, l, mid, lc, rc, val); if (temp != -1) return temp; else return query(rs, mid + 1, r, lc, rc, val); &#125; &#125;&#125;using namespace segmentTree;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%s\", op[i].str); a[i] = op[i].x = readIn(), op[i].y = readIn();// printf(\"\\n\");// printf(\"%s %d %d\\n\", op[i].str, op[i].x, op[i].y); &#125; sort(a + 1, a + n + 1); m = unique(a + 1, a + n + 1) - a - 1; build(1, 1, m);// printf(\"%d\\n\", m); for (int i = 1; i &lt;= m; ++i) s[i].clear(); for (int i = 1; i &lt;= n; ++i) &#123; int x = lower_bound(a + 1, a + m + 1, op[i].x) - a;// printf(\"%d\\n\", x); if (op[i].str[0] == 'a') &#123; s[x].insert(op[i].y); modify(1, 1, m, x); &#125; else if (op[i].str[0] == 'r') &#123; s[x].erase(op[i].y); modify(1, 1, m, x); &#125; else if (op[i].str[0] == 'f') &#123; int pos = query(1, 1, m, x + 1, m, op[i].y);// printf(\"%d\\n\", pos); if (pos == -1) printf(\"%d\\n\", -1); else printf(\"%d %d\\n\", a[pos], *s[pos].upper_bound(op[i].y)); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://yoursite.com/tags/Codeforces/"},{"name":"离散化","slug":"离散化","permalink":"http://yoursite.com/tags/离散化/"}]},{"title":"[CTSC 1999]补丁VS错误","slug":"CTSC-1999-补丁VS错误","date":"2017-07-30T03:20:50.000Z","updated":"2017-07-30T03:24:54.662Z","comments":true,"path":"2017/07/30/CTSC-1999-补丁VS错误/","link":"","permalink":"http://yoursite.com/2017/07/30/CTSC-1999-补丁VS错误/","excerpt":"题目地址 描述题面比较长而且有些晦涩，这里就不贴了。简要的描述一下：你现在有一个包含$n$种$bug$、$m$个补丁的软件，每一个补丁有五个参数，补丁的运行时间$t$，此补丁能够运行当且仅当补丁所在的软件包含$B_{i}+$中的所有$bug$而不包含$B_{i}-$中的任何$bug$，应用此补丁之后软件将修复$F_{i}-$个$bug$同时产生$F_{i}+$个新$bug$。每一个补丁可以安装多次，求修复完所有$bug$的最短的时间；如果问题有解，输出总耗时，否则输出$0$。$1 \\leq n \\leq 15, 1 \\leq m \\leq 100$","text":"题目地址 描述题面比较长而且有些晦涩，这里就不贴了。简要的描述一下：你现在有一个包含$n$种$bug$、$m$个补丁的软件，每一个补丁有五个参数，补丁的运行时间$t$，此补丁能够运行当且仅当补丁所在的软件包含$B_{i}+$中的所有$bug$而不包含$B_{i}-$中的任何$bug$，应用此补丁之后软件将修复$F_{i}-$个$bug$同时产生$F_{i}+$个新$bug$。每一个补丁可以安装多次，求修复完所有$bug$的最短的时间；如果问题有解，输出总耗时，否则输出$0$。$1 \\leq n \\leq 15, 1 \\leq m \\leq 100$ 分析题意理解了好久QAQ我们可以肯定最多只有$2^{n}$种错误情况，初始状态为$2^{n} - 1$， 最后要求达到的状态是$0$。进一步我们发现$n$实际上很小，可以状压，那么可以想到用二进制来表示出所有的错误情况。 接下来我们可以枚举所有的错误情况和当前所有的补丁，若存在当前软件的错误情况可以使用补丁$i$，那么就从当前状态添加一条指向当前状态使用完此补丁后的状态的有向边，这条有向边的权值为使用补丁$i$的运行时间。显而易见，我们只用求初始状态$s$到最终状态$t$的最短路即可。 其实，这道题目还有一个解法，就是每一次判断当前的补丁是否可用，然后对于当前状态用Hash判重+DFS也可以水过去的QAQ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// Created by ZJYelizaveta on 2017年07月29日 星期六 22时12分38秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = (1 &lt;&lt; (15 + 3));const int INF = 0x3f3f3f3f;int n, m, s, t;int w[MAX_N];char str1[MAX_N], str2[MAX_N];struct Limited &#123; int s1[MAX_N], s2[MAX_N], t1[MAX_N], t2[MAX_N]; //b+, b-, f+, f-&#125;lim;struct Edge &#123; int to, w; Edge(int to = 0, int w = 0) : to(to), w(w)&#123;&#125;&#125;;vector&lt;Edge&gt; G[MAX_N];int dist[MAX_N];bool inq[MAX_N];inline void addEdge(int from, int to, int w) &#123; G[from].push_back(Edge(to, w));&#125;inline void SPFA() &#123; memset(inq, false, sizeof inq); memset(dist, INF, sizeof dist); queue&lt;int&gt; q; q.push(s); inq[s] = true; dist[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = 0; i &lt; (int)G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (dist[e.to] &gt; dist[u] + e.w) &#123; dist[e.to] = dist[u] + e.w; if (!inq[e.to]) &#123; q.push(e.to); inq[e.to] = 1; &#125; &#125; &#125; &#125; if (dist[t] == INF) printf(\"%d\\n\", 0); else printf(\"%d\\n\", dist[t]);&#125;int main()&#123; n = readIn(), m = readIn(); s = (1 &lt;&lt; n) - 1, t = 0; for (int i = 0; i &lt; m; ++i) &#123; w[i] = readIn(); scanf(\"%s\", str1); for (int j = 0; j &lt; n; ++j) &#123; if (str1[j] == '+') lim.s1[i] |= (1 &lt;&lt; j); else if (str1[j] == '-') lim.s2[i] |= (1 &lt;&lt; j); &#125; scanf(\"%s\", str2); for (int j = 0; j &lt; n; ++j) &#123; if (str2[j] == '+') lim.t1[i] |= (1 &lt;&lt; j); else if (str2[j] == '-') lim.t2[i] |= (1 &lt;&lt; j); &#125; &#125;// for (int i = 0; i &lt; m; ++i) printf(\"%d \", lim.s1[i]); printf(\"\\n\");// for (int i = 0; i &lt; m; ++i) printf(\"%d \", lim.s2[i]); printf(\"\\n\");// for (int i = 0; i &lt; m; ++i) printf(\"%d \", lim.t1[i]); printf(\"\\n\");// for (int i = 0; i &lt; m; ++i) printf(\"%d \", lim.t2[i]); printf(\"\\n\"); for (int i = s; i &gt;= t; --i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (((i &amp; lim.s1[j]) == lim.s1[j]) &amp;&amp; ((i &amp; lim.s2[j]) == 0)) &#123; addEdge(i, ((i &amp; (~lim.t2[j])) | lim.t1[j]), w[j]);// printf(\"%d %d %d\\n\", i, (i &amp; (~lim.t2[j]) | lim.t1[j]), w[j]); &#125; &#125; &#125; SPFA(); return 0;&#125;","categories":[],"tags":[{"name":"位运算","slug":"位运算","permalink":"http://yoursite.com/tags/位运算/"},{"name":"最短路","slug":"最短路","permalink":"http://yoursite.com/tags/最短路/"},{"name":"SPFA","slug":"SPFA","permalink":"http://yoursite.com/tags/SPFA/"}]},{"title":"[IOI1999]花店橱窗布置","slug":"IOI1999-花店橱窗布置","date":"2017-07-30T03:19:20.000Z","updated":"2017-07-30T03:23:44.237Z","comments":true,"path":"2017/07/30/IOI1999-花店橱窗布置/","link":"","permalink":"http://yoursite.com/2017/07/30/IOI1999-花店橱窗布置/","excerpt":"描述某花店现有$F$束花，每一束花的品种都不一样，同时至少有同样数量的花瓶，被按顺序摆成一行，花瓶的位置是固定的，从左到右按$1$到$V$顺序编号，$V$是花瓶的数目。花束可以移动，并且每束花用$1$到$F$的整数标识。如$i &lt; j$，则花束$i$必须放在花束$j$左边的花瓶中。例如，假设杜鹃花的标识数为$1$，秋海棠的标识数为$2$，康乃馨的标识数为$3$，所有花束在放入花瓶时必须保持其标识数的顺序，即杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。如果花瓶的数目大于花束的数目，则多余的花瓶必须空，即每个花瓶只能放一束花。","text":"描述某花店现有$F$束花，每一束花的品种都不一样，同时至少有同样数量的花瓶，被按顺序摆成一行，花瓶的位置是固定的，从左到右按$1$到$V$顺序编号，$V$是花瓶的数目。花束可以移动，并且每束花用$1$到$F$的整数标识。如$i &lt; j$，则花束$i$必须放在花束$j$左边的花瓶中。例如，假设杜鹃花的标识数为$1$，秋海棠的标识数为$2$，康乃馨的标识数为$3$，所有花束在放入花瓶时必须保持其标识数的顺序，即杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。如果花瓶的数目大于花束的数目，则多余的花瓶必须空，即每个花瓶只能放一束花。 每个花瓶的形状和颜色也不相同，因此，当各个花瓶中放入不同的花束时，会产生不同的美学效果，并以美学值（一个整数）来表示，空置花瓶的美学值为$0$。在上述的例子中，花瓶与花束的不同搭配所具有的美学值，可以用如下的表格来表示： - 花瓶1 花瓶2 花瓶3 花瓶4 花瓶5 杜鹃花 7 23 -5 -24 16 秋海棠 5 21 -4 10 23 康乃馨 -21 5 -4 -20 20 根据表格，杜鹃花放在花瓶$2$中，会显得非常好看，但若放在花瓶$4$中，则显得很难看。为了取得最佳的美学效果，必须在保持花束顺序的前提下，使花的摆放取得最大的美学值，如果具有最大美学值的摆放方式不止一种，则输出任何一种方案即可。 分析很容易发现这道题目有很明显的阶段性且$n$也比较小可以接受$\\Theta(n^{2})$，所以我们可以往动态规划的方面来想。考虑以花朵的数目来划分阶段，那么定义$dp[i][j]$为前$i$朵花放在前$j$个花瓶李。那么我们就有规划方程dp[i][j] = max(dp[i - 1][j - 1] + w[i][j], dp[i][j - 1])方程很容易理解，我们考虑第$i$朵花应该如何放置： 选择将第$i$朵花放在第$j$个瓶子中，那么此时的美学值为$dp[i - 1][j - 1] + w[i][j]$，$w[i][j]$为将第$i$朵花放入第$j$个瓶子的美学值。 选择不将第$i$朵花放在第$j$个瓶子中，那么此时的美学值为$dp[i][j - 1]$最后递归打印路径就可以了。其实也可以选择以花瓶数为阶段来划分，这里就不写了QAQ代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Created by ZJYelizaveta on 2017年07月28日 星期五 10时49分36秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int INF = 0x3f3f3f3f;int n, m;int w[MAX_N][MAX_N];int dp[MAX_N][MAX_N];bool vis[MAX_N][MAX_N];inline void printPath(int x, int y) &#123; if (x == 0) return; else if (vis[x][y] == 1)&#123; printPath(x - 1, y - 1); printf(\"%d \", y); &#125; else printPath(x, y - 1);&#125;int main()&#123; n = readIn(), m = readIn(); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) w[i][j] = readIn(); &#125;/* for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) printf(\"%d \", w[i][j]); printf(\"\\n\"); &#125; return 0;*/ memset(vis, 0, sizeof vis); memset(dp, -INF, sizeof dp); for (int i = 0; i &lt;= m; ++i) dp[0][i] = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = i; j &lt;= m &amp;&amp; i &lt;= i + n; ++j) &#123; if (dp[i - 1][j - 1] + w[i][j] &lt;= dp[i][j - 1]) dp[i][j] = dp[i][j - 1]; else &#123; dp[i][j] = dp[i - 1][j - 1] + w[i][j]; vis[i][j] = 1; &#125; &#125; &#125; printf(\"%d\\n\", dp[n][m]); printPath(n, m); printf(\"\\n\"); return 0;&#125;","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"[IOI 1994]北京2008的挂钟","slug":"IOI-1994-北京2008的挂钟","date":"2017-07-30T03:17:39.000Z","updated":"2017-07-30T03:18:43.784Z","comments":true,"path":"2017/07/30/IOI-1994-北京2008的挂钟/","link":"","permalink":"http://yoursite.com/2017/07/30/IOI-1994-北京2008的挂钟/","excerpt":"题目地址 描述在$2008$北京奥运会雄伟的主会场的墙上，挂着如上图所示的$3 \\times 3$的九个挂钟（一开始指针即时针指向的位置请根据输入数据调整）。然而此次奥运会给与了大家一个机会，去用最少的移动操作改变上面的挂钟的时间全部为$12$点正（我们只考虑时针）。然而每一次操作并不是任意的，我们必须按照下面给出的列表对于挂钟进行改变。每一次操作我们给而且必须给指定的操作挂钟进行，每一个挂钟顺时针转动$90$度。","text":"题目地址 描述在$2008$北京奥运会雄伟的主会场的墙上，挂着如上图所示的$3 \\times 3$的九个挂钟（一开始指针即时针指向的位置请根据输入数据调整）。然而此次奥运会给与了大家一个机会，去用最少的移动操作改变上面的挂钟的时间全部为$12$点正（我们只考虑时针）。然而每一次操作并不是任意的，我们必须按照下面给出的列表对于挂钟进行改变。每一次操作我们给而且必须给指定的操作挂钟进行，每一个挂钟顺时针转动$90$度。 列表给出九种操作，如下： ABDE ABC BCEF ADG BDEFH CFI DEGH GHI EFHI 分析我们我们可以发现对于一个钟表它所需的操作次数为$0 \\sim 3$次，那么也就是说对于一个序列我们最多只会调用同一个序列$3$次。那么我们可以枚举每一次操作调用的序列，如果已经调用过$3$次这个序列则这个序列不会再调用。然后判断当前状态是否满足挂钟的时间全部为$12$点正，如果满足那么输出解，否则进入下一层搜索。然后每一次搜索的时候枚举这个操作进行了几次，并用一个$cnt$数组记录下来，这样就可以不重不漏的枚举到所有的情况。听说九重循环也可以水过去QAQ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// Created by ZJYelizaveta on 2017年07月29日 星期六 09时33分38秒// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int MOD = 4;int a[MAX_N];const int step[10][10] = &#123; &#123;1, 1, 0, 1, 1, 0, 0, 0, 0&#125;, &#123;1, 1, 1, 0, 0, 0, 0, 0, 0&#125;, &#123;0, 1, 1, 0, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 0, 1, 0, 0, 1, 0, 0&#125;, &#123;0, 1, 0, 1, 1, 1, 0, 1, 0&#125;, &#123;0, 0, 1, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 0, 1, 1, 0&#125;, &#123;0, 0, 0, 0, 0, 0, 1, 1, 1&#125;, &#123;0, 0, 0, 0, 1, 1, 0, 1, 1&#125;&#125;;int temp[MAX_N], cnt[MAX_N];void dfs(int depth) &#123; for (int i = 0; i &lt; 9; ++i) temp[i] = a[i];// for (int i = 0; i &lt; 9; ++i) printf(\"%d \", temp[i]); printf(\"\\n\"); for (int j = 0; j &lt; 9; ++j) &#123;//每个操作中对应的钟表1~9 for (int i = 0; i &lt; 9; ++i) &#123;//操作1~9 temp[j] = (temp[j] + step[i][j] * cnt[i]) % MOD; &#125; &#125;// for (int i = 0; i &lt; 9; ++i) printf(\"%d \", temp[i]); printf(\"\\n\"); bool flag = true; for (int i = 0; i &lt; 9; ++i) if (temp[i]) &#123;flag = false; break;&#125; if (flag) &#123; for (int i = 0; i &lt; 9; ++i) &#123; for (int j = 0; j &lt; cnt[i]; ++j) &#123; printf(\"%d \", i + 1); &#125; &#125; printf(\"\\n\"); return; &#125; if (depth == 9) return; for (int i = 0; i &lt; 4; ++i) &#123; cnt[depth] = i; dfs(depth + 1); &#125;&#125;int main()&#123; for (int i = 0; i &lt; 9; ++i) a[i] = readIn(); dfs(0); return 0;&#125;","categories":[],"tags":[{"name":"DFS及BFS","slug":"DFS及BFS","permalink":"http://yoursite.com/tags/DFS及BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"}]},{"title":"BZOJ 1233 [Usaco2009Open]干草堆tower","slug":"BZOJ-1233-Usaco2009Open-干草堆tower","date":"2017-07-24T11:45:35.000Z","updated":"2017-07-24T11:47:57.950Z","comments":true,"path":"2017/07/24/BZOJ-1233-Usaco2009Open-干草堆tower/","link":"","permalink":"http://yoursite.com/2017/07/24/BZOJ-1233-Usaco2009Open-干草堆tower/","excerpt":"题目地址 描述奶牛们讨厌黑暗。 为了调整牛棚顶的电灯的亮度，Bessie必须建一座干草堆使得她能够爬上去够到灯泡。一共有$N$大包的干草$(1 \\leq N \\leq 100000)$(从$1$到$N$编号)依靠传送带连续的传输进牛棚来。第$i$包干草有一个 宽度$W_{i}(1 \\leq w_{i} \\leq 10000)$。所有的干草包的厚度和高度都为$1$。","text":"题目地址 描述奶牛们讨厌黑暗。 为了调整牛棚顶的电灯的亮度，Bessie必须建一座干草堆使得她能够爬上去够到灯泡。一共有$N$大包的干草$(1 \\leq N \\leq 100000)$(从$1$到$N$编号)依靠传送带连续的传输进牛棚来。第$i$包干草有一个 宽度$W_{i}(1 \\leq w_{i} \\leq 10000)$。所有的干草包的厚度和高度都为$1$。 Bessie必须利用所有$N$包干草来建立起干草堆，并且按照他们进牛棚的顺序摆放。她可以相放多少包就放多少包来建立起tower的地基（当然是紧紧的放在一行中）。接下来他可以放置下一个草包放在之前一级的上方来建立新的一级。注意：每一级不能比下面的一级宽。她持续的这么放置，直到所有的草包都被安 置完成。她必须按顺序堆放，按照草包进入牛棚的顺序。说得更清楚一些：一旦她将一个草包放在第二级，她不能将接下来的草包放在地基上。Bessie的目标是建立起最高的草包堆。 分析这道题目很妙呀QAQ首先肯定可以写出一个$\\Theta (n^{3})$的DP，定义$dp[i, j]$为当前层的干草是由第$[i, j)$包堆得，那么就有转移$dp[i, j] = dpj - 1, k$ 这道题目有一个很妙的结论：在许多干草堆之中，如果有一堆干草堆最下面的一段干草宽度最短，那么这一堆干草堆最高。 刚开始不会做，上网看了一下题解，结果全是“转自zkw” QAQ，然后看得我一脸懵逼 在善良的学长学姐的教导下好像明白了怎么推导，其实并不复杂。有两种方案，第一种是最下面一段干草是最短的，第二种最下面一段干草不是最短的那么我们经过一系列贪心的调整，能够将第二种转化成为第一种，那么转化后第二种的高度要么增加要么不变，可以感性的理解一下 所以问题就从维护当前干草堆最高变成了维护当前干草的宽度最短。设$f[i]$为由$i \\sim n$堆成的干草堆中最底层最短的长度。$g[i]$为处于状态$f[i]$时的最高高度。 那么有转移： f[i] = min \\{sum[j - 1] - sum[i - 1] \\}(i < j \\leq n, f[j] \\leq sum[j - 1] - sum[i - 1]) \\\\ g[i] = g[j] + 1这样我们运用结论将$\\Theta (n^{3})$的DP成功降至$\\Theta (n^{2})$，可是$1 \\leq N \\leq 100000$，$\\Theta (n^{2})$好像也不行呢，至少也得$\\Theta (nlogn)$或者$\\Theta (n)$才行呢？ 然后打表观察[滑稽.jpg]，把转移条件移一下项f[j] \\leq sum[j - 1] - sum[i - 1] \\Rightarrow sum[i - 1] = sum[j - 1] - f[j]我们发现当存在两个决策点$j, k$且$j &lt; k , sum[k - 1] - f[k] \\leq sum[j - 1] - f[j]$的时候选择$k$显然没有选择$j$优，所以我们维护$sum[i - 1] - f[i]$的单调队列即可，那么时间复杂度降至$\\Theta (n)$。如叙述不清请指出QAQ 代码123456789101112131415161718192021222324252627282930313233343536373839404142//2017/06/12 14:25:03//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1233: [Usaco2009Open]干草堆tower#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int INF = 0x3f3f3f3f;const int MAX = 100000 + 3;int n;int w[MAX];int q[MAX], sum[MAX];int f[MAX], g[MAX];int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(); for(int i = 1; i &lt;= n; ++i) w[i] = readIn(); sum[0] = 0; for(int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + w[i]; int l = 1, r = 1; q[r] = n + 1; for(int i = n; i &gt;= 1; --i)&#123; while(l &lt; r &amp;&amp; sum[q[l + 1] - 1] - sum[i - 1] &gt;= f[q[l + 1]]) l++; f[i] = sum[q[l] - 1] - sum[i - 1]; g[i] = g[q[l]] + 1; while(l &lt; r &amp;&amp; f[i] - sum[i - 1] &lt; f[q[r]] - sum[q[r] - 1]) r--; q[++r] = i; &#125; printf(\"%d\\n\", g[1]); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"单调队列","slug":"单调队列","permalink":"http://yoursite.com/tags/单调队列/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}]},{"title":"BZOJ 1001: [BeiJing2006]狼抓兔子","slug":"BZOJ-1001-BeiJing2006-狼抓兔子","date":"2017-07-24T02:15:14.000Z","updated":"2017-07-24T09:09:38.192Z","comments":true,"path":"2017/07/24/BZOJ-1001-BeiJing2006-狼抓兔子/","link":"","permalink":"http://yoursite.com/2017/07/24/BZOJ-1001-BeiJing2006-狼抓兔子/","excerpt":"题目地址 描述现在小朋友们最喜欢的“喜羊羊与灰太狼”，话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：左上角点为$(1,1)$，右下角点为$(N,M)$(上图中$N=3,M=4$)，有以下三种类型的道路： $(x,y) \\Leftrightarrow (x+1,y)$ $(x,y) \\Leftrightarrow (x,y+1)$ $(x,y) \\Leftrightarrow (x+1,y+1)$","text":"题目地址 描述现在小朋友们最喜欢的“喜羊羊与灰太狼”，话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：左上角点为$(1,1)$，右下角点为$(N,M)$(上图中$N=3,M=4$)，有以下三种类型的道路： $(x,y) \\Leftrightarrow (x+1,y)$ $(x,y) \\Leftrightarrow (x,y+1)$ $(x,y) \\Leftrightarrow (x+1,y+1)$ 道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。 左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角$(1,1)$的窝里，现在它们要跑到右下角$(N,M)$的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为$K$，狼王需要安排同样数量的$K$只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。$(1 \\leq N, M \\leq 1000)$ 分析算法一：最小割转最大流菜啊，现在才做这道题目。首先看这道题目首先可以想到最小割，以前一直以为一定要转化为对偶图然后做最短路，后来发现把最小割转化为最大流写一发Dinic再加一点优化就可以卡过去了QAQ然后时间复杂度为$\\Theta(m \\cdot n^{2} + 3m \\cdot n)$，如果时间复杂度错了，请在评论中指出蟹蟹QAQ然后一定要注意这是一个无向图啊QAQ 算法二：平面图最小割转对偶图最短路附参考资料地址：浅析最大最小定理在信息学竞赛中的应用简单解释一下： 首先根据定义我们知道这是一个s-t平面图 而根据平面图的性质：每个平面图$G$都有一个与其对偶的平面图$G’$ $G’$中的每个点对应$G$中的一个面 对于$G$中的每条边$e$，$e$属于两个面$f_{1’},f_{2’}$，加入边$(f_{1}, f_{2})$；$e$只属于一个面$f$，加入回边$(f’,f’)$。 对于平面图$G$与其对偶图$G’$存在如下的关系： $G$的面数等于$G’$的点数，$G’$的点数等于$G$的面数，$G$与$G’$边数相同 $G’$中的环对应$G$中的割一一对应。 如图， 我们进一步发现，如果我们令每条边的长度等于它的容量，那么最小割的容量就等于最短路的长度，也就是说求原图s-t图的最小割等于求其对偶图的最短路，那么我们可以在$\\Theta (mn)$内求出答案QAQ，是这个时间复杂度吧（SPFA的复杂度玄学） 那么样例中的如我们可以表示为这样：值得注意的是这道题目比较良心在于他已经给出了这道题目的样子所以我们可以直接在原来s-t图上建立出他的对偶图，当然如果有的题目中没有给出图的样子那么就先要找出原图中的所有面并标号，然后建图（还没有见过类似的题目QAQ） 代码 算法一这是一个无向图呀QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// BZOJ 1001 [BeiJing2006]狼抓兔子// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.// 网络流#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt;'0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000000 + 3;const int MAX_M = 6000000 + 3;const int INF = 0x3f3f3f3f;int n, m, s, t;namespace Dinic &#123; struct Edge &#123; int to, next, cap; &#125;edge[MAX_M]; int head[MAX_N], cnt = 0; int iter[MAX_N], level[MAX_N]; inline void addEdge(int from, int to, int cap) &#123; edge[++cnt].to = to; edge[cnt].cap = cap; edge[cnt].next = head[from]; head[from] = cnt; edge[++cnt].to = from; edge[cnt].cap = cap; edge[cnt].next = head[to]; head[to] = cnt; &#125; bool bfs() &#123; memset(level, -1, sizeof level); queue&lt;int&gt; q; q.push(s), level[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; i; i = edge[i].next) &#123; if (edge[i].cap &amp;&amp; level[edge[i].to] == -1) &#123; level[edge[i].to] = level[u] + 1; q.push(edge[i].to); &#125; &#125; &#125; return level[t] != -1; &#125; int dfs(int u, int flow) &#123; if (u == t) return flow; int used = 0; for (int i = head[u]; i &amp;&amp; flow &gt; used; i = edge[i].next) &#123;// Edge &amp;e = G[u][i]; if (edge[i].cap &amp;&amp; level[edge[i].to] == level[u] + 1) &#123; int d = dfs(edge[i].to, min(flow - used, edge[i].cap));// printf(\"%d\\n\", d); used += d; edge[i].cap -= d; edge[i^1].cap += d; &#125; &#125; if (!used) level[u] = -1; return used; &#125; int maxFlow(int _s, int _t) &#123; s = _s, t = _t; int flow = 0, d = 0; while (bfs()) &#123;// memset(iter, 0, sizeof iter); while (d = dfs(s, INT_MAX), d) flow += d; &#125; return flow; &#125;&#125;using namespace Dinic;int main()&#123; n = readIn(), m = readIn(); s = 1, t = n * m;// printf(\"%d %d\\n\", s, t); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; m; ++j) &#123; int w = readIn();// printf(\"%d %d %d\\n\", (i - 1) * m + j, (i - 1) * m + j + 1, w); addEdge((i - 1) * m + j, (i - 1) * m + j + 1, w); &#125; &#125; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; int w = readIn();// printf(\"%d %d %d\\n\", (i - 1) * m + j, i * m + j, w); addEdge((i - 1) * m + j, i * m + j, w); &#125; &#125; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt; m; ++j) &#123; int w = readIn();// printf(\"%d %d %d\\n\", (i - 1) * m + j, i * m + j + 1, w); addEdge((i - 1) * m + j, i * m + j + 1, w); &#125; &#125; printf(\"%d\\n\", maxFlow(s, t)); return 0;&#125; 算法二当$i = 1 || i == m || j == 1 || j == m$的时候特判一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// BZOJ 1001 [BeiJing2006]狼抓兔子// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.// 对偶图 + 最短路#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn() &#123; int x = 0, f = 1; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') &#123;if (ch == '-') f = -1; ch = getchar();&#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 2000000 + 3;const int MAX_M = 8000000 + 3;const int INF = 0x3f3f3f3f;int n, m, s, t;namespace SPFA &#123; struct Edge &#123; int to, next, w; &#125;edge[MAX_M]; int head[MAX_N], cnt = 0; typedef pair&lt;int, int&gt; P; int dis[MAX_N]; bool inq[MAX_N]; inline void addEdge(int from, int to, int cost) &#123; edge[++cnt].to = to; edge[cnt].w = cost; edge[cnt].next = head[from]; head[from] = cnt; edge[++cnt].to = from; edge[cnt].w = cost; edge[cnt].next = head[to]; head[to] = cnt; &#125; void spfa() &#123; memset(dis, INF, sizeof dis); memset(inq, 0, sizeof inq); deque&lt;int&gt; q; q.push_front(s), dis[s] = 0, inq[s] = true; while (!q.empty()) &#123; int u = q.front(); q.pop_front(); inq[u] = false; for (int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (dis[v] &gt; dis[u] + edge[i].w) &#123; dis[v] = dis[u] + edge[i].w; if (!inq[u]) &#123; inq[v] = true; if (q.empty() || dis[v] &gt; dis[q.front()]) q.push_back(v); else q.push_front(v); &#125; &#125; &#125; &#125; &#125;&#125;using namespace SPFA;int main()&#123; n = readIn(), m = readIn(); s = 0, t = (((n - 1) * (m - 1)) &lt;&lt; 1) + 1;// printf(\"%d %d %d %d\\n\", n, m, s, t); memset(head, -1, sizeof head); for (register int i = 1; i &lt;= n; ++i) &#123; for (register int j = 1; j &lt; m; ++j) &#123; int w = readIn(); if (i == 1) addEdge(j &lt;&lt; 1, t, w); //printf(\"%d %d %d\\n\", j &lt;&lt; 1, t, w); else if (i == n) addEdge((((n - 2) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1) - 1, s, w); //printf(\"%d %d %d\\n\", (((n - 2) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1) - 1, s, w); else addEdge((((i - 2) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1) - 1, (((i - 1) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1), w);// printf(\"%d %d %d\\n\", (((i - 2) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1) - 1, (((i - 1) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1), w); &#125; &#125; for (register int i = 1; i &lt; n; ++i) &#123; for (register int j = 1; j &lt;= m; ++j) &#123; int w = readIn(); if (j == 1) addEdge(s, (((i - 1) * (m - 1)) &lt;&lt; 1) + 1, w); //printf(\"%d %d %d\\n\", s, (((i - 1) * (m - 1)) &lt;&lt; 1) + 1, w); else if (j == m) addEdge(t, (i * (m - 1)) &lt;&lt; 1, w); //printf(\"%d %d %d\\n\", t, (i * (m - 1)) &lt;&lt; 1, w); else addEdge((((i - 1) * (m - 1)) &lt;&lt; 1) + ((j - 1) &lt;&lt; 1), (((i - 1) * (m - 1)) &lt;&lt; 1) + ((j - 1) &lt;&lt; 1) + 1, w); //printf(\"%d %d %d\\n\", (((i - 1) * (m - 1)) &lt;&lt; 1) + ((j - 1) &lt;&lt; 1), (((i - 1) * (m - 1)) &lt;&lt; 1) + ((j - 1) &lt;&lt; 1) + 1, w); &#125; &#125; for (register int i = 1; i &lt; n; ++i) &#123; for (register int j = 1; j &lt; m; ++j) &#123; int w = readIn(); addEdge((((i - 1) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1) - 1, (((i - 1) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1), w); //printf(\"%d %d %d\\n\", (((i - 1) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1) - 1, (((i - 1) * (m - 1)) &lt;&lt; 1) + (j &lt;&lt; 1), w); &#125; &#125; spfa();// for (int i = s; i &lt;= t; ++i) printf(\"%d\\n\", dist[i]); printf(\"%d\\n\", dis[t]); return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"http://yoursite.com/tags/最大流/"},{"name":"对偶图","slug":"对偶图","permalink":"http://yoursite.com/tags/对偶图/"}]},{"title":"「雅礼集训 2017 Day2」C","slug":"「雅礼集训-2017-Day2」C","date":"2017-07-05T14:34:30.000Z","updated":"2017-07-05T14:57:15.681Z","comments":true,"path":"2017/07/05/「雅礼集训-2017-Day2」C/","link":"","permalink":"http://yoursite.com/2017/07/05/「雅礼集训-2017-Day2」C/","excerpt":"一如既往没有题目地址0w0 描述有一棵$n$个结点的树，对于点$i(i &gt; 1)$，它的父亲结点编号为$\\left \\lfloor \\frac{i}{2} \\right \\rfloor$。现在有$m$只鸟，每只鸟有初始位置$p_{i}$。树上每个结点有最大容量$c_{i}$，表示这个结点最多能容纳的鸟的数量。定义移动一只鸟的代价为树上的距离。现在询问，对于$k$从$1 \\sim m$，将前$k$只鸟移动位置使得满足每个结点上的鸟的个数不大于最大容纳量的最小代价。","text":"一如既往没有题目地址0w0 描述有一棵$n$个结点的树，对于点$i(i &gt; 1)$，它的父亲结点编号为$\\left \\lfloor \\frac{i}{2} \\right \\rfloor$。现在有$m$只鸟，每只鸟有初始位置$p_{i}$。树上每个结点有最大容量$c_{i}$，表示这个结点最多能容纳的鸟的数量。定义移动一只鸟的代价为树上的距离。现在询问，对于$k$从$1 \\sim m$，将前$k$只鸟移动位置使得满足每个结点上的鸟的个数不大于最大容纳量的最小代价。 从$0 \\sim 1$个数据：$n, m \\leq 7$从$2 \\sim 7$个数据：$n, m \\leq 100 \\times i$，其中$i$标书数据编号从$8$个数据：只有一个$c_{i} &gt; 0$从$9 \\sim 10$个数据：只有两个$c_{i} &gt; 0$从$11$个数据：$p_{i}$只有一种取值从$12 \\sim 13$个数据：$p_{i}$只有两种取值从$14 \\sim 19$个数据：$n, m \\leq 3 \\times 10^{5}$ 分析大神们都说是一眼费用流，好吧QAQ 前8个数据点大概估计一下直接见图跑费用流大概可过前$8$个数据点，那么怎么建图呢？ 首先建立超级源点$s，$以及超级汇点$t$。 将每一个点，连接汇点$t$，将点上的容量转化为边上的容量，那么每一个点到汇点$t$的边上的容量相当于这个点的容量，为费用为$0$。 对于树上的每一条边建立双向边，每条边的容量为$INF$费用为$1$。 那么对于初始条件存在鸟的结点，将这些节点连向超级源点$s$，其中每一条边上的容量为$1$，费用为$0$。 至此我们就建好图了，那么接下来从源点到汇点跑一边费用流就可以啦！跑费用流的时候要限制让鸟根据编号顺序一只一只的跑，如果存在鸟$1$没有跑而鸟$2$跑了费用流，那么这时候会存在负环。 进阶满分第一次听说手动增广[新奇.jpg]直接跑费用流的话虽然可以跑过前$8$个点，但是后面的测试点好像会T飞QAQ 因为问题中要求“将前$k$只鸟移动位置使得满足每个结点上的鸟的个数不大于最大容纳量的最小代价”，也就是说我们求费用流的过程相当于到达当前容量不为$0$的点的最短路，那么也就是说我们的增广路径一定是在最短路上的。 因为这是一棵二叉树，所以高度只有$\\Theta (logn)$。如果用SPFA跑费用流的找最短路的话在$\\Theta(nm)$可以找到，而利用这是一棵二叉树的特性则可以在$\\Theta (logn)$内找到最短路。 所以我们就先在$\\Theta (logn)$的时间复杂度内找到最短路，再模拟费用流的增广过程即可。 每跑玩一次费用流之后在上一次的残量网络上，再按最短路增广是正确的。（我不会证明呀，哪个大佬能教我一下QAQ）手动模拟费用流，新加入一只鸟，就从它的初始位置开始，找一条最短路增广。也就是找一个容量大于$0$，且距离当前鸟所在的结点最近的结点。如果走向和边上的流向相同，或边上的流为 $0$，费用为 $+1$； 否则，费用为 $-1$。学习了一下Sengxian学长的代码，表示好妙呀QAQ 代码 前8个数据点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// Created by ZJYelizaveta on Tuesday, July 04, 2017 PM04:34:04 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int INF = 0x3f3f3f3f;int n, m, s, t;int sum[MAX_N], cost;namespace MCMF&#123; struct Edge&#123; int to, cap, cost, rev; Edge(int to, int cap, int cost, int rev) : to(to), cap(cap), cost(cost), rev(rev)&#123;&#125; &#125;; vector&lt;Edge&gt; G[MAX_N]; int dist[MAX_N], flow[MAX_N]; int prevE[MAX_N], prevV[MAX_N]; bool inq[MAX_N]; inline void addEdge(int from, int to, int cap, int cost)&#123; G[from].push_back(Edge(to, cap, cost, G[to].size())); G[to].push_back(Edge(from, 0, -cost, G[from].size() - 1)); &#125; bool minCostMaxFlow(int s, int t)&#123; memset(dist, INF, sizeof dist); memset(inq, false, sizeof inq); queue&lt;int&gt; q; q.push(s), inq[s] = true, dist[s] = 0, flow[s] = INF; while(!q.empty())&#123; int u = q.front(); q.pop(); if(u == t) continue; inq[u] = false; for(int i = 0; i &lt; (int)G[u].size(); ++i)&#123; Edge &amp;e = G[u][i]; if(e.cap &amp;&amp; dist[e.to] &gt; dist[u] + e.cost)&#123; if(e.to == s) continue; dist[e.to] = dist[u] + e.cost; prevV[e.to] = u; prevE[e.to] = i; flow[e.to] = min(flow[u], e.cap); if(!inq[e.to]) q.push(e.to), inq[e.to] = true; &#125; &#125; &#125; if(dist[t] == INF) return false; for(int i = t; i != s; i = prevV[i])&#123; Edge &amp; e = G[prevV[i]][prevE[i]]; e.cap -= flow[t]; G[e.to][e.rev].cap += flow[t]; &#125; cost += flow[t] * dist[t]; return true; &#125;&#125;using namespace MCMF;int main()&#123; n = readIn(), m = readIn();// printf(\"%d %d\\n\", n, m);// return 0; s = n + 1, t = n + 2; for(int i = 1; i &lt;= n * 4; ++i)G[i].clear(); for(int i = 1; i &lt;= n; ++i)&#123; int c = readIn(); addEdge(i, t, c, 0); &#125; for(int i = 1; i &lt;= n; ++i)&#123; addEdge(i, i &gt;&gt; 1, INF, 1); addEdge(i &gt;&gt; 1, i, INF, 1); &#125; for(int i = 1; i &lt;= m; ++i)&#123; int pos = readIn(); addEdge(s, pos, 1, 0); while(minCostMaxFlow(s, t)) sum[i] = cost; &#125; for(int i = 1; i &lt;= m; ++i) printf(\"%d%c\", sum[i], i + 1 == m + 1 ? '\\n' : ' '); return 0;&#125; 对于$100 \\%$的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// Created by ZJYelizaveta on Wednesday, July 05, 2017 PM02:56:43 CST// Copyright (c) 2017年 ZJYelizaveta. All rights reserved.#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 300000 + 3;const int INF = 0x3f3f3f3f;int n, m;int cap[MAX_N], pos[MAX_N];int dist[MAX_N], idx[MAX_N], flow[MAX_N];int ans;#define ls ((o) &lt;&lt; 1)#define rs (((o) &lt;&lt; 1) + 1)inline void update(int o)&#123; if(cap[o]) dist[o] = 0, idx[o] = o; else dist[o] = INF, idx[o] = 0; if(ls &lt;= n &amp;&amp; dist[o] &gt; dist[ls] + (flow[ls] &gt; 0 ? -1 : 1))&#123; dist[o] = dist[ls] + (flow[ls] &gt; 0 ? -1 : 1); idx[o] = idx[ls]; &#125; if(rs &lt;= n &amp;&amp; dist[o] &gt; dist[rs] + (flow[rs] &gt; 0 ? -1 : 1))&#123; dist[o] = dist[rs] + (flow[rs] &gt; 0 ? -1 : 1); idx[o] = idx[rs]; &#125;&#125;int main()&#123;#ifdef DEBUG freopen(\"C00.in\", \"r\", stdin);// freopen(\"test.out\", \"w\", stdout);#endif n = readIn(), m = readIn(); for(int i = 1; i &lt;= n; ++i) cap[i] = readIn(); for(int i = n; i &gt;= 1; --i) update(i); for(int i = 1; i &lt;= m; ++i) pos[i] = readIn(); ans = 0; for(int i = 1; i &lt;= m; ++i)&#123; int u = pos[i], now = 0, d = INF, id = 0; while(1)&#123; if(d &gt; now + dist[u])&#123; d = now + dist[u]; id = u; &#125; if (u == 1) break; now += (flow[u] &gt;= 0 ? 1 : -1); u &gt;&gt;= 1; &#125; ans += d, --cap[idx[id]];//记录最短路终止的结点编号，终点容量-- //LCA分别从最短路的终点和起点开始往上跳并更新，跳到LCA之后再一起跳到根并更新 for(int v = idx[id]; v != id; v &gt;&gt;= 1) flow[v]--, update(v); for(int v = pos[i]; v != id; v &gt;&gt;= 1) flow[v]++, update(v); for(int v = id; v != 1; v &gt;&gt;= 1) update(v); update(1); printf(\"%d%c\", ans, i + 1 == m + 1 ? '\\n' : ' '); &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"费用流","slug":"费用流","permalink":"http://yoursite.com/tags/费用流/"}]},{"title":"「雅礼集训 2017 Day2」B","slug":"「雅礼集训-2017-Day2」B","date":"2017-07-04T10:56:17.000Z","updated":"2017-07-05T14:52:20.434Z","comments":true,"path":"2017/07/04/「雅礼集训-2017-Day2」B/","link":"","permalink":"http://yoursite.com/2017/07/04/「雅礼集训-2017-Day2」B/","excerpt":"当然还是没有题目地址呀QAQ我太弱了，表示这道题目想了很久才想明白题解中的方法呀，真的很巧妙呀QAQ；在chrt学姐的帮助下终于明白了，大概这次写的有点多，中间可能有描述不恰当和错误的地方，欢迎捉虫QAQSkipher和Sengxian学长写的十一个很妙的做法，好像还可以扩展到有$3$个$1$的情况，但是我好像忘了是怎么推的了[绝望.jpg]考试的时候写了一个$\\Theta(n^{2})$的DP，然后水了70分 描述考虑一个$n \\times n$的$01$矩阵，计算出所有满足每一行和每一列$1$的个数都是$2$的矩阵个数。设对于$n$的答案为$f_{n}$，你需要输出$\\sum_{i = 1}^{n}f_{i}$，答案对$998244353$取模。","text":"当然还是没有题目地址呀QAQ我太弱了，表示这道题目想了很久才想明白题解中的方法呀，真的很巧妙呀QAQ；在chrt学姐的帮助下终于明白了，大概这次写的有点多，中间可能有描述不恰当和错误的地方，欢迎捉虫QAQSkipher和Sengxian学长写的十一个很妙的做法，好像还可以扩展到有$3$个$1$的情况，但是我好像忘了是怎么推的了[绝望.jpg]考试的时候写了一个$\\Theta(n^{2})$的DP，然后水了70分 描述考虑一个$n \\times n$的$01$矩阵，计算出所有满足每一行和每一列$1$的个数都是$2$的矩阵个数。设对于$n$的答案为$f_{n}$，你需要输出$\\sum_{i = 1}^{n}f_{i}$，答案对$998244353$取模。 对于$10 \\%$的数据，满足：$n \\leq 7$对于$20 \\%$的数据，满足：$n \\leq 50$对于$30 \\%$的数据，满足：$n \\leq 150$对于$40 \\%$的数据，满足：$n \\leq 500$对于$70 \\%$的数据，满足：$n \\leq 10000$对于$100 \\%$的数据，满足：$n \\leq 10^{7}$ 分析对于$70 \\%$的数据看数据范围就知道大概要写一个DP，Orz坐我旁边的大爷DP的思路大概是这样的：我们定义$dp[i][j]$为还剩$i$列没有填过$1$，$j$列只填了一个$1$。那么我们有转移方程 dp[0][0] = 1 \\\\ dp[i][j] = \\binom{2}{i} \\cdot dp[i - 2][j + 2] + i \\cdot j \\cdot dp[i - 1][j] + \\binom{2}{j}dp[i][j - 2]这三种转移都是在一行中选两个，其实可以用滚动数组来滚动一下。 $\\binom{2}{i} \\cdot dp[i - 2][j + 2]$表示在$i$个没有填过$1$的列中选两个，然后$i$少了两个$j$多了两个 $i \\cdot j \\cdot dp[i - 1][j]$表示在$i$个没用的列中选一个，在$j$个填过一个$1$的列中选一个，那么$i$减少了一个$j$增加了一个又减少了一个没变 $\\binom{2}{j}dp[i][j - 2]$相当于在$j$个填过一个$1$的列中选两个，所以$j$少了两个而$i$没有变 因为这是一个自上而下的DP，而$dp[i][0]$表示的是”目前到达这个状态,把它填完的方案数”，而不是”到达这个状态的方案数”，所以最后答案可表示为： ans = \\sum_{i = 1}^{n}dp[i][0]对于$100 \\%$的数据其实这道题目的本质大概就是OEIS A001499题解中满分的思路大概是这样的：题解中是这样描述的将同一行和同一列之间的$1$连边，那么我们将$01$矩阵转化为一个二分图，如图所示：转化为二分图之后，考虑一个左边和右边各有$n$个点的二分图，如上图的合法方案中，左边和右边的任意两点之间有边，也就是说原题的合法方案相当于这个二分图中的多重完美最大匹配，那么也就是说原题中的答案转化成为了求二分图中多重完美最大匹配的数量。而这个多重完美最大匹配长什么样呢？ 是一堆分离的环。 于是我们枚举$1$号点所在的环的大小，删掉这个环，然后我们得到了一个更小的二分图，就这样我们得到了比原问题更小的子问题，然后建立递推关系: 我们令$f_{n}$为在$n \\times n$的矩阵中满足题目条件的方案数，因为最后是要计算所有方案的和，与其最后在相加一遍，不如现在直接计入答案中，那么，我们有递推式： f_{n} = \\sum_{i = 2}^{n}A_{i} \\cdot \\binom{i}{n}\\binom{n - 1}{i - 1} \\cdot f_{n - i}这个递推式怎么来理解呢QAQ，大概是这样的：我们把二分图中一个大小为$2i$的环分为几部分来看待：$1$号点 + 左边剩下的$(i - 1)$个点 + 右边的$i$个点。所以选出一个环有$\\binom{i}{n}\\cdot \\binom{n - 1}{i - 1} $种方法；那么$A_{n}$是什么呢，就是这个环的连边方法。那么到此为左边和右边都只剩下$(n - i)$个点了，那么这就是一个子问题$f_{n - i}$。把它们乘起来那么我们就得到了$1$号点所在的环的大小为$2i$的所有方案数了。 $A_{n}$是这个环的连边方法，我们可以把这个问题等价为：对于一个$n \\times n$的矩阵中有且仅有一个环的方案数我们称之为$A_{n}$，那么有: A_{n} = \\frac{n! \\times (n - 1)!}{2}这一部分其实比较好理解，就是先将每一行每一列放置一个$1$的方案数为$n!$，令$p_{i}$为第$i$行所在的$1$所在的列编号，那么在$p_{1}$列放的第二个$1$的方案数就为$n - 1$；令$p_{1}$列第二个$1$所在的行编号为$q_{i}$，那么在$p_{q_{i}}$列放置第$2$个$1$的方案数为$n - 2$，然后$n - 3 \\cdots$。可以自己换画一个$4 \\times 4$的图意会一下，因为这个过程被计算了两次（逆过程也被计算了一次），所以最后除以$2$。 仅仅有递推式也是很难得到满分的，$n = 10^{7}$意味着我们最好在$\\Theta(n)$的时间复杂度中算出来，$\\Theta(nlogn)$一样会超时，那么我们对式子进行如下的变换： \\because A_{n} = \\frac{n! \\times (n - 1)!}{2} \\\\ \\begin{equation}\\begin{split} f_{n} & = \\sum_{i = 2}^{n} \\frac{i! \\cdot (i - 1)!}{2} \\binom{i}{n}\\binom{n - 1}{i - 1} \\cdot f_{n - i}\\\\ & = \\sum_{i = 2}^{n} \\frac{i! \\cdot (i - 1)!}{2} \\frac{n!}{i! \\cdot (n - i)!} \\frac{(n - 1)!}{(i - 1)! \\cdot (n - i)!}\\cdot f_{n - i}\\\\ & = \\sum_{i = 2}^{n} \\frac{1}{2} \\cdot \\frac{n! \\cdot (n - 1)!}{(n - i)! \\cdot (n - i)!} \\cdot f_{n - i}\\\\ & = \\frac{n! \\cdot (n - 1)!}{2} \\sum_{i = 2}^{n} \\frac{1}{((n - i)!)^{2}} \\cdot f_{n - i} \\end{split}\\end{equation}现在等式两边同时除以$(n!)^{2}$，那么有： \\frac{f_{n}}{(n!)^{2}} = \\frac{1}{2n}\\sum_{i = 2}^{n} \\frac{1}{((n - i)!)^{2}} \\cdot f_{n - i}令$g_{n} = \\frac{f_{n}}{(n!)^{2}}$，那么$f_{n} = g_{n} \\cdot (n!)^{2}$，所以原式变为： g_{n} = \\frac{1}{2n} \\sum_{i = 2}^{n}g_{n - i}那么我们现在只需要处理出逆元然后维护$g_{n}$的前缀和，线性扫一遍就可以了，时间复杂度$\\Theta(n)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//「雅礼集训 2017 Day2」B//2017/7/4#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000000 + 3;const int MOD = 998244353;const int INF = 0x3f3f3f3f;int n;ll fac[MAX_N], inv[MAX_N];//阶层，阶层的逆元ll ans;inline ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)&#123; if(b == 0) &#123;x = 1, y = 0;&#125; else&#123; exgcd(b, a % b, y, x); y -= (a / b) * x; &#125;&#125;inline ll calculate(ll a, ll b)&#123;//计算逆元 ll x = 0, y = 0; exgcd(a, b, x, y); return (x % b + b) % b;&#125;inline void prepare()&#123;// printf(\"%d\\n\", n); fac[0] = 1; for(int i = 1; i &lt;= n; ++i) fac[i] = (ll)fac[i - 1] * i % MOD;// for(int i = 1; i &lt;= n; ++i) printf(\"f[%d] = %lld\\n\", i, fac[i]); inv[n] =calculate(fac[n], MOD);// printf(\"%lld\\n\", inv[n]); for(int i = n - 1; i &gt;= 0; --i) inv[i] = (ll)inv[i + 1] * (i + 1) % MOD;// for(int i = 1; i &lt;= n; ++i) printf(\"inv[%d] = %lld\\n\", i, inv[i]);&#125;int main()&#123; n = readIn();// printf(\"%d\\n\", n); prepare(); ans = 0; ll preg = 1, lastg = 0, divided = calculate(2, MOD); for(int i = 2; i &lt;= n; ++i)&#123; ll tmpg = (ll)preg * divided % MOD * inv[i] % MOD * fac[i -1] % MOD; (ans += (ll)tmpg * fac[i] % MOD * fac[i] % MOD) %= MOD; (preg += lastg) %= MOD; lastg = tmpg; &#125; printf(\"%lld\\n\", (ans % MOD + MOD) % MOD); return 0;&#125; 参考chrt学姐的博客一如既往的很赞呀","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"},{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"},{"name":"逆元","slug":"逆元","permalink":"http://yoursite.com/tags/逆元/"}]},{"title":"常系数线性齐次递推关系学习笔记","slug":"常系数线性齐次递推关系学习笔记","date":"2017-07-02T14:12:19.000Z","updated":"2017-07-03T03:39:29.486Z","comments":true,"path":"2017/07/02/常系数线性齐次递推关系学习笔记/","link":"","permalink":"http://yoursite.com/2017/07/02/常系数线性齐次递推关系学习笔记/","excerpt":"初中的班主任好像生病了，本来准备和同学一起去看望老师，但是好像去不了QAQ真的很想见一见初中的同学，好想他们呀QAQ 阅读这篇文章你所需要的前置技能大概有：基础的线性代数，以及看懂渣叙述的深厚语文功底QAQ可能有表述不清或者错误的地方，欢迎指正！","text":"初中的班主任好像生病了，本来准备和同学一起去看望老师，但是好像去不了QAQ真的很想见一见初中的同学，好想他们呀QAQ 阅读这篇文章你所需要的前置技能大概有：基础的线性代数，以及看懂渣叙述的深厚语文功底QAQ可能有表述不清或者错误的地方，欢迎指正！ 定义$h_{1}, h_{2}, \\cdots , h_{n}, \\cdots $是一个数列，称这个数列满足k阶线性递推关系是指存在量$a_{1}, a_{2}, \\cdots , a_{k}(a_{k} \\neq 0)$和量$b_{n}$(这些量$a_{1}, a_{2}, \\cdots a_{k}, b_{n}$可能依赖于$n$)，使得h_{n} = a_{1}h_{n - 1} + a_{2}h_{n - 2} + \\cdots + a_{k}h_{n - k} + b_{n}(n \\geq k) 例如斐波那契数列，就是一个典型的满足2阶递推关系的递推式。 如同栗子中所示，我们称线性递推关系是齐次的，如果$b_{n}$是常数0；而我们称它是常系数的，如果量$a_{1}, a_{2}, \\cdots , a_{k}$是常数，形如：h_{n} = a_{1}h_{n - 1} + a_{2}h_{n - 2} + \\cdots + a_{k}h_{n - k}(n \\geq k) 求解我们求解常系数线性齐次递推关系要依赖于是否能找到与$h_{n}$相关的某个多项式方程的根。其实求解常系数线性齐次递推关系和微分方程求解的方法极其相似。我们求解常系数线性齐次递推关系需要依赖一下几个定理。 定理1定义设$q$是一个非$0$的数，则$h_{n} = q^{n}$是下面常系数线性齐次递推关系$h_{n} = a_{1}h_{n - 1} + a_{2}h_{n - 2} + \\cdots + a_{k}h_{n - k}(n \\geq k, a_{k} \\neq 0)$的解，当且仅当$q$是下面这个多项式方程$x^{k} - a_{1}x^{k - 1} - a_{2}x^{k - 2} - \\cdots - a_{k} = 0$的根。 证明如果$h_{n} = q^{n}$是下面常系数线性齐次递推关系$h_{n} = a_{1}h_{n - 1} + a_{2}h_{n - 2} + \\cdots + a_{k}h_{n - k}(n \\geq k, a_{k} \\neq 0)$的解，那么我们将$h_{n} = q^{n}$带入以上常系数线性递推关系，可以得到 q^{n} - a_{1}q^{n - 1} - a_{2}q^{n - 2} - \\cdots - a_{k}q^{n - k} = 0若对于所有$n \\geq k$，$q^{n} - a_{1}q^{n - 1} - a_{2}q^{n - 2} - \\cdots - a_{k}q^{n - k} = 0$都有解（$q$有解），则$h_{n} = q^{n}$为常系数线性齐次递推关系的解。 假设$q \\neq 0$，我们可以将等式两边同时消去$q^{n - k}$，因此对于每一个$n \\geq k$都有一个的方程最后都会化为： q^{k} - a_{1}q^{k - 1} - a_{2}q^{k - 2} - \\cdots - a_{k} = 0那我们现在得出了结论若要得出$h_{n} = q^{n}$为递推式的解，当且仅当$q$为多项式方程的解。 现在只需证明$q$为多项式方程的根即可。因为假设$a_{k} \\neq 0$，所以$0$不是多项式方程的根。因此，一定存在$k$个不等于$0$的根$q_{1}, q_{2}, \\cdots , q_{k}$（这些根可以是复数，我也不知道为什么QAQ）。现在假设这$k$个根互不相同，那么h_{n} = q_{1}^{n}, h_{2} = q_{2}^{n}, \\cdots , h_{k} = q_{k}^{n}为递推式$k$个不同的解。而递推关系的线性性和齐次性意味着对于任意选定的常数$c_{1}, c_{2}, \\cdots, c_{k}$存在，h_{n} = c_{1}q_{1}^{n} + c_{2}q_{2}^{n} + \\cdots + c_{k}q_{k}^{n}使得其也为常系数齐次线性递推式的解。 定理2定义若多项式方程存在$k$个不同的根$q_{1}, q_{2}, \\cdots, q_{k}$，则$h_{n} = c_{1}q_{1}^{n} + c_{2}q_{2}^{n} + \\cdots + c_{k}q_{k}^{n}$在下述意义下是$h_{n} = a_{1}h_{n - 1} + a_{2}h_{n - 2} + \\cdots + a_{k}h_{n - k}(n \\geq k, a_{k} \\neq 0)$的通解：无论给定怎样的初始值$h_{0}, h_{1}, \\cdots, h_{k - 1}$，都存在常数$c_{1}, c_{2}, \\cdots, c_{k}$，使得$h_{n} = c_{1}q_{1}^{n} + c_{2}q_{2}^{n} + \\cdots + c_{k}q_{k}^{n}$是满足$h_{n} = a_{1}h_{n - 1} + a_{2}h_{n - 2} + \\cdots + a_{k}h_{n - k}(n \\geq k, a_{k} \\neq 0)$和初始条件的唯一数列。 证明好了定理1证明完了，那么现在只需要证明$h_{n} = c_{1}q_{1}^{n} + c_{2}q_{2}^{n} + \\cdots + c_{k}q_{k}^{n}$在下述意义下是$h_{n} = a_{1}h_{n - 1} + a_{2}h_{n - 2} + \\cdots + a_{k}h_{n - k}(n \\geq k, a_{k} \\neq 0)$的通解。 我们假设指定初始值： h_{0} = b_{0}, h_{1} = b_{1}， \\cdots, h_{k - 1} = b_{k - 1}我们是否能都选出常数$c_{1}, c_{2}, \\cdots, c_{k}$（$c$在这里相当于未知数）使得$h_{n} = c_{1}q_{1}^{n} + c_{2}q_{2}^{n} + \\cdots + c_{k}q_{k}^{n}$中的$h_{n}$满足上述初始条件，等价于，无论选择怎样的$b_{0}, b_{1}, \\cdots , b_{k - 1}$使得下列方程组有解： 我们把方程的系数矩阵表示出来是这样的： \\begin{bmatrix} 1 & 1 & \\cdots & 1\\\\ q_{1} & q_{2} & \\cdots & q_{k}\\\\ q_{1}^{2} & q_{2}^{2} & \\cdots & q_{k}^{2}\\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ q_{1}^{k - 1} & q_{2}^{k - 1} & \\cdots & q_{k}^{k - 1} \\end{bmatrix}觉不觉得这个矩阵很熟悉，对呀，不就是范德蒙矩阵吗QWQ，而范德蒙矩阵的行列式可表示为（这个就不证明啦）\\prod_{1 \\leq i < j \\leq k}(q_{j} - q_{i})当且仅当$q_{1}, q_{2}, \\cdots, q_{k}$两两之间互不相同的时候，系数矩阵才不为$0$。而系数矩阵才不为$0$，这也意味着方程组对于$b_{0}, b_{1}, \\cdots, b_{k - 1}$的每一种选择都有唯一解（方程有唯一解（克莱姆法则））。如果想进一步了解的话可以看n阶行列式 应用有常系数线性齐次递推式如下，求递推关系 首先我们可以得出递推式的特征方程： x^{3} - 2x^{2} - x + 2 = 0解得： x_{1} = -1, x_{2} = 1, x_{3} = 2因此h_{n} = c_{1}(-1)^{n} + c_{2}1^{n} + c_{3}2^{n}为常系数线性齐次递推关系的通解。 现在只需要求出常系数$c_{1}, c_{2}, c_{3}$使得方程组成立即可： 解得: c_{1} = -\\frac{2}{3}, c_{2} = 2, c_{3} = -\\frac{1}{3}因此， h_{n} = -\\frac{2}{3}\\cdot (-1)^{n} + 2 - \\frac{1}{3}\\cdot 2^{n}为原常系数线性齐次递推式的解，相当于原递推式的封闭形式。 参考资料 《组合数学》 原书第5版 P142","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"},{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"}]},{"title":"BZOJ 1575: [Usaco2009 Jan]气象牛Baric","slug":"BZOJ-1575-Usaco2009-Jan-气象牛Baric","date":"2017-06-29T13:11:43.000Z","updated":"2017-06-29T15:16:10.435Z","comments":true,"path":"2017/06/29/BZOJ-1575-Usaco2009-Jan-气象牛Baric/","link":"","permalink":"http://yoursite.com/2017/06/29/BZOJ-1575-Usaco2009-Jan-气象牛Baric/","excerpt":"题目地址 描述为了研究农场的气候，Betsy帮助农夫John做了$N(1 \\leq N \\leq 100)$次气压测量并按顺序记录了结果$M_{1} \\cdots M_{N}(1 \\leq M_{i} \\leq 1,000,000)$，Betsy想找出一部分测量结果来总结整天的气压分布，她想用$K(1 \\leq K \\leq N)$个数$s_{j} (1 \\leq s_{1} &lt; s_{2} &lt; \\cdots &lt; s_{K} \\leq N)$来概括所有测量结果。她想限制如下的误差： 对于任何测量结果子集，每一个非此子集中的结果都会产生误差，总误差是所有测量结果的误差之和。更明确第说,对于每一个和所有$s_{j}$都不同的$i$： 如果 $i$ 小于 $s_{1}$, 误差是: $2 \\times | M_{i} - M_{s_{1}} |$ 如果$i$在$s_{j}$和$s_{j+1}$之间，误差是: $| 2 \\times M_{i} - Sum(s_{j}, s_{j+1}) |$ $\\cdots$ $Sum(x, y) = M_{x} + M_{y}$；$(M_{x} 和 M_{y} 之和)$ 如果$i$大于$s_{K}$，误差为: $2 \\times | M_{i} - M_{s_{K}} |$ Besty给了最大允许的误差$E (1 \\leq E \\leq 1,000,000)$，找出最小的一部分结果使得误差最多为$E$。","text":"题目地址 描述为了研究农场的气候，Betsy帮助农夫John做了$N(1 \\leq N \\leq 100)$次气压测量并按顺序记录了结果$M_{1} \\cdots M_{N}(1 \\leq M_{i} \\leq 1,000,000)$，Betsy想找出一部分测量结果来总结整天的气压分布，她想用$K(1 \\leq K \\leq N)$个数$s_{j} (1 \\leq s_{1} &lt; s_{2} &lt; \\cdots &lt; s_{K} \\leq N)$来概括所有测量结果。她想限制如下的误差： 对于任何测量结果子集，每一个非此子集中的结果都会产生误差，总误差是所有测量结果的误差之和。更明确第说,对于每一个和所有$s_{j}$都不同的$i$： 如果 $i$ 小于 $s_{1}$, 误差是: $2 \\times | M_{i} - M_{s_{1}} |$ 如果$i$在$s_{j}$和$s_{j+1}$之间，误差是: $| 2 \\times M_{i} - Sum(s_{j}, s_{j+1}) |$ $\\cdots$ $Sum(x, y) = M_{x} + M_{y}$；$(M_{x} 和 M_{y} 之和)$ 如果$i$大于$s_{K}$，误差为: $2 \\times | M_{i} - M_{s_{K}} |$ Besty给了最大允许的误差$E (1 \\leq E \\leq 1,000,000)$，找出最小的一部分结果使得误差最多为$E$。 分析比较平常的动态规划首先我们需要预处理出所有测量结果的误差，用一个二维数组$w[i][j]$存储，这是显然的$dp$的状态定义为$dp[i][j]$为选第$i$个数，当前(在前i个数中)一共选取了$j$个数的最小误差。我们可以得出一个跟背包差不多的$\\Theta(n^{3})$的转移方程，具体见代码预处理$\\Theta(n^{3})$，转移$\\Theta(n^{3})$，但是因为$n$比较小，所以还是能够水过去的QAQ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//2017/06/14 15:55:59//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1575: [Usaco2009 Jan]气象牛Baric#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int INF = 0x3f3f3f3f;const int MAX_N = 100 + 3;const int MAX_M = 1000000 + 3;int n, e;int m[MAX_N];ll w[MAX_N][MAX_N], dp[MAX_N][MAX_N];inline void prepare()&#123; memset(w, 0, sizeof w); for(int i = 0; i &lt;= n + 1; ++i)&#123; for(int j = i + 1; j &lt;= n + 1; ++j)&#123; for(int k = i + 1; k &lt;= j - 1; ++k)&#123; if(i == 0) w[i][j] = w[i][j] + 2 * abs(m[j] - m[k]);// else if(j == n + 1) w[i][j] = w[i][j] + 2 * abs(m[k] - m[i]); else w[i][j] = w[i][j] + abs(2 * m[k] - m[i] - m[j]); &#125; &#125; &#125;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(), e = readIn(); for(int i = 1; i &lt;= n; ++i) m[i] = readIn(); m[0] = m[n + 1] = 0; prepare(); memset(dp, INF, sizeof dp); w[0][n + 1] = INF, dp[0][1] = 0; for(int i = 1; i &lt;= n + 1; ++i)&#123; for(int j = 1; j &lt;= i + 1; ++j)&#123; for(int k = 0; k &lt; i; ++k)&#123; if((j - 1) &lt;= k + 1) dp[i][j] = min(dp[i][j], dp[k][j - 1] + w[k][i]); &#125; &#125; &#125; for(int i = 1; i &lt;= n + 2; ++i)&#123; if(dp[n + 1][i] &lt;= (ll)e)&#123; printf(\"%d %lld\\n\", i - 2, dp[n + 1][i]); return 0; &#125; &#125; /* for(int i = 0; i &lt;= n + 1; ++i)&#123; for(int j = 0; j &lt;= n + 1; ++j)&#123; printf(\"%lld \", dp[i][j]); &#125; printf(\"\\n\"); &#125; */ return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"}]},{"title":"「雅礼集训 2017 Day1」say","slug":"「雅礼集训 2017 Day1」say","date":"2017-06-17T16:11:21.000Z","updated":"2017-07-04T11:06:55.997Z","comments":true,"path":"2017/06/18/「雅礼集训 2017 Day1」say/","link":"","permalink":"http://yoursite.com/2017/06/18/「雅礼集训 2017 Day1」say/","excerpt":"题目地址，可能不会放上来啦！前言，这几天集训，蒟蒻表示被虐的[生无可恋.jpg]，不过认识到了自己的许多不足和需要努力的地方，至少不像以前对自己的处境毫无头绪；认识了一些很厉害的人，Orz 人生赢家xch，以及我那个超级厉害的室友，还有学长们；每天都是坐看学长和学姐们AK，然后很努力的点亮技能树，期望不被虐QAQ也许会陆陆续续的把博客补上吧，这几天还是学到了挺多东西的 描述 “What’s left to say when every word’s been spoken?”“若沉默再无休止，是否已经话无可说？”","text":"题目地址，可能不会放上来啦！前言，这几天集训，蒟蒻表示被虐的[生无可恋.jpg]，不过认识到了自己的许多不足和需要努力的地方，至少不像以前对自己的处境毫无头绪；认识了一些很厉害的人，Orz 人生赢家xch，以及我那个超级厉害的室友，还有学长们；每天都是坐看学长和学姐们AK，然后很努力的点亮技能树，期望不被虐QAQ也许会陆陆续续的把博客补上吧，这几天还是学到了挺多东西的 描述 “What’s left to say when every word’s been spoken?”“若沉默再无休止，是否已经话无可说？” 沉默之中，我已不懂言语。幻觉之中，有人在轻声低吟。我听见，那人说了$n$句话，好多话都是重复或类似的，每句话是由若干个小写字母组成的字符串。字符串$A$和$B$的相似度定义如下：字符串$A$通过以下三种操作： 插入一个字符 删除一个字符 替换一个字符 从而使字符串$A$变换成字符串$B$的最少操作次数。 对于$10 \\%$的数据，$1 \\leq n \\leq 20$，$1 \\leq 每个字符串的长度 \\leq 12$对于$30 \\%$的数据，字符串的总长度$ \\leq 5000$对于$30 \\%$的数据，字符串的总长度$ \\leq 12000$对于$30 \\%$的数据，字符串的总长度$ \\leq 100000$对于另外$10 \\%$的数据，$1 \\leq n \\leq 70$对于$100 \\%$的数据，$1 \\leq n \\leq 200$， 字符串的总长度$\\leq 1000000$每个测试点时间$3s$，内存限制$512M$。 分析对于大部分人来说肯定能一眼AC，我比较蒻显然对于$30 \\% \\sim 40 \\%$的数据$\\Theta (n^{2})$的DP可以水过去，然而我还是太菜QAQ 现在考虑$100 \\%$的数据，我们考虑用LCS来跳过字符串中相同的位置，那么如何比较字符串是否相等呢？暴力比较显然是不可做的，以前做 BZOJ 2795: [Poi2012]A Horrible Poem 学长讲过用哈希的方法比较两个字符串，那么我们这里就用哈希就可以了。有一个优化就是，如果两个字符串一开始长度差异大于$8$那么这两个字符串显然对于答案是没有贡献的，所以我们可以不用管这样的情况，直接跳过就可以了。 我写哈希用的自然溢出，听说用unsigned int比用unsigned long long更快，但是出错率是unsigned long long的两倍？ 那个回来以后才发现好像MLE了QAQ，我以前是怎么AC的[迷茫.jpg]，改成了用$vector$存储虽然过了，但是好像有些慢。然后学习了一下Sengxian学长的代码，Sengxian学长是动态分配内存，果然代码从用$vector$改成了动态分配内存之后快了$2000ms$，Orz Sengxian学长。 代码 $vector$存储 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//「雅礼集训 2017 Day1」say//2017/6/29//hash + 二分 + dfs + LCS + vector处理不定长数组#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') ch = getchar(); while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x;&#125;const int MAX_N = 200 + 3;const int MAX_LEN = 1000000 + 3;const int HASH_SIZE = 131;int n;char str[MAX_LEN];vector&lt;char&gt; S[MAX_N];vector&lt;ull&gt; hash[MAX_N];ull p[MAX_LEN];int len[MAX_N], ans[8 + 3];int cnt;void dfs(int a, int b, int cura, int curb, int step)&#123; if(step + abs(len[a] - cura - len[b] + curb) &gt;= cnt) return; else if(len[a] == cura)&#123; cnt = min(cnt, step + len[b] - curb); return; &#125; else if(len[b] == curb)&#123; cnt = min(cnt, step + len[a] - cura); return; &#125; if(S[a][cura] != S[b][curb])&#123; dfs(a, b, cura + 1, curb, step + 1); dfs(a, b, cura, curb + 1, step + 1); dfs(a, b, cura + 1, curb + 1, step + 1); &#125; else&#123; int l = 0, r = min(len[a] - cura, len[b] - curb); while(r - l &gt; 1)&#123; int mid = (l + r) &gt;&gt; 1; if(hash[a][cura + mid + 1] - hash[a][cura] * p[mid + 1] == hash[b][curb + mid + 1] - hash[b][curb] * p[mid + 1]) l = mid; else r = mid; &#125; dfs(a, b, cura + l + 1, curb + l + 1, step); &#125;&#125;int main()&#123;#ifndef DEBUG freopen(\"say0.in\", \"r\", stdin);#endif n = readIn(); //printf(\"%d\\n\", n); for(int i = 0; i &lt; n; ++i)&#123; scanf(\"%s\", str); //printf(\"%s\\n\", str); len[i] = strlen(str); for(int j = 0; j &lt; len[i]; ++j)&#123; S[i].push_back(str[j]); hash[i].push_back(S[i][0]); &#125; &#125; for(int i = 0; i &lt; n; ++i) for(int j = 1; j &lt; len[i]; ++j) hash[i][j] = hash[i][j - 1] * HASH_SIZE + S[i][j]; p[0] = 1; for(int i = 1; i &lt; MAX_LEN; ++i) p[i] = p[i - 1] * HASH_SIZE;// for(int i = 0; i &lt; n; ++i)&#123; for(int j = i + 1; j &lt; n; ++j)&#123; cnt = 9; if(abs(len[i] - len[j]) &gt;= cnt) continue; dfs(i, j, 0, 0, 0); if(cnt &lt;= 8) ++ans[cnt]; &#125; &#125; for(int i = 1; i &lt;= 8; ++i) printf(\"%d%c\", ans[i], i + 1 == 9 ? '\\n' : ' '); return 0;&#125; 动态分配内存 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//「雅礼集训 2017 Day1」say//2017/6/29//hash + 二分 + dfs + LCS + 动态分配内存#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int INF = 0x3f3f3f3f;const int MAX_N = 200 + 3;const int MAX_LEN = 1000000 + MAX_N + 3;const int HASH_SIZE = 131;int n;char poolStr[MAX_LEN], *pitStr = poolStr, *str[MAX_N];ull poolHash[MAX_LEN], *pitHash = poolHash, *hash[MAX_N];ull p[MAX_LEN];int len[MAX_N], ans[8 + 3];int cnt;inline bool check(int a, int cura, int b, int curb, int length)&#123; return hash[a][cura + length + 1] - hash[a][cura] * p[length + 1] == hash[b][curb + length + 1] - hash[b][curb] * p[length + 1];&#125;void dfs(int a, int b, int cura, int curb, int steps)&#123; if(steps + abs(len[a] - cura - len[b] + curb) &gt;= cnt) return; if(len[a] == cura)&#123; cnt = min(cnt, steps + len[b] - curb); return; &#125; if(len[b] == curb)&#123; cnt = min(cnt, steps + len[a] - cura); return; &#125; if(str[a][cura] != str[b][curb])&#123; dfs(a, b, cura + 1, curb + 1, steps + 1); dfs(a, b, cura + 1, curb, steps + 1); dfs(a, b, cura, curb + 1, steps + 1); &#125; else&#123; int l = 0, r = min((len[a] - cura), (len[b] - curb)); while(r - l &gt; 1)&#123; int mid = (l + r) &gt;&gt; 1; if(check(a, cura, b, curb, mid)) l = mid; else r = mid; &#125; dfs(a, b, cura + l + 1, curb + l + 1, steps); &#125;&#125;int main()&#123;#ifndef DEBUG freopen(\"say19.in\", \"r\", stdin);#endif n = readIn();// printf(\"%d\\n\", n); for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%s\", pitStr); str[i] = pitStr; len[i] = strlen(pitStr); pitStr += len[i] + 1; hash[i] = pitHash; pitHash += len[i] + 1; &#125; for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; len[i]; ++j) hash[i][j + 1] = hash[i][j] * HASH_SIZE + str[i][j]; p[0] = 1; for(int i = 1; i &lt; MAX_LEN; ++i) p[i] = p[i - 1] * HASH_SIZE;// return 0; for(int i = 0; i &lt; n; ++i)&#123; for(int j = i + 1; j &lt; n; ++j)&#123; cnt = 9; if(abs(len[i] - len[j]) &gt;= cnt) continue; dfs(i, j, 0, 0, 0); if(cnt &lt;= 8) ++ans[cnt]; &#125; &#125;// return 0; for (int i = 1; i &lt;= 8; ++i) printf(\"%d%c\", ans[i], i + 1 == 9 ? '\\n' : ' '); return 0;&#125;","categories":[],"tags":[{"name":"DFS及BFS","slug":"DFS及BFS","permalink":"http://yoursite.com/tags/DFS及BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"哈希","slug":"哈希","permalink":"http://yoursite.com/tags/哈希/"},{"name":"LCS","slug":"LCS","permalink":"http://yoursite.com/tags/LCS/"}]},{"title":"BZOJ 2440: [中山市选2011]完全平方数","slug":"BZOJ-2440-中山市选2011-完全平方数","date":"2017-06-14T13:29:58.000Z","updated":"2017-06-14T13:36:39.809Z","comments":true,"path":"2017/06/14/BZOJ-2440-中山市选2011-完全平方数/","link":"","permalink":"http://yoursite.com/2017/06/14/BZOJ-2440-中山市选2011-完全平方数/","excerpt":"题目地址 描述小 X 自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。这天是小X的生日，小 W 想送一个数给他作为生日礼物。当然他不能送一个小X讨厌的数。他列出了所有小X不讨厌的数，然后选取了第$K$个数送给了小X。小X很开心地收下了。然而现在小 W 却记不起送给小X的是哪个数了。你能帮他一下吗？$T$为数据组数，对于100%的数据有 $1 \\leq K_{i} \\leq 10^{9},T \\leq 50$。","text":"题目地址 描述小 X 自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。这天是小X的生日，小 W 想送一个数给他作为生日礼物。当然他不能送一个小X讨厌的数。他列出了所有小X不讨厌的数，然后选取了第$K$个数送给了小X。小X很开心地收下了。然而现在小 W 却记不起送给小X的是哪个数了。你能帮他一下吗？$T$为数据组数，对于100%的数据有 $1 \\leq K_{i} \\leq 10^{9},T \\leq 50$。 分析看到这个的时候很容易想到二分$n$，计算区间$[1, n]$有多少个无平方因子的数。 如果我们要计算区间$[1, n]$有无平方因子的数的个数就要用到容斥原理。 很明显我们的答案可表示为\\begin{equation} \\begin{split} ans & = n - 含一个质因子的平方的数的个数 + 含两个质因子之积的平方的数的个数 - \\cdots\\\\ & = n + \\frac{n}{1 \\cdot 1} - \\frac{n}{2 \\cdot 2} - \\frac{n}{3 \\cdot 3} + \\frac{n}{4 \\cdot 4} - \\frac{n}{5 \\cdot 5} + \\frac{n}{6 \\cdot 6} + \\cdots\\end{split} \\end{equation}，然后我们会发现每一个数前面的符号其实对应的就是它的莫比乌斯函数的值。 综上所述，我们可以整理一个区间$[1, n]$答案为：ans = \\sum_{i = 1}^{n} \\mu{(i)} \\cdot \\frac{n}{i \\cdot i} 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//2017/06/14 11:31:39//Copyright (c) 2017年 ZJYelizavtea. All rights reserved.//BZOJ 2440: [中山市选2011]完全平方数#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 1000000 + 3;const int INF = 0x3f3f3f3f;int testCase;int K;int prime[MAX + 3], mu[MAX + 3];bool isNotPrime[MAX + 3];inline void seive()&#123; memset(isNotPrime, false, sizeof isNotPrime); int cnt = 0; isNotPrime[1] = true, mu[1] = 1; for(int i = 2; i &lt;= MAX; ++i)&#123; if(!isNotPrime[i])&#123; prime[++cnt] = i; mu[i] = -1; &#125; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= MAX; ++j)&#123; isNotPrime[i * prime[j]] = true; if(i % prime[j] == 0)&#123; mu[i * prime[j]] = 0; break; &#125; else mu[i * prime[j]] = -mu[i]; &#125; &#125; //for(int i = 1; i &lt;= 12; ++i) printf(\"%d \", mu[i]); printf(\"\\n\");&#125;bool check(int n)&#123; int ans = 0; for(int i = 1; i * i &lt;= n; ++i)&#123; ans += mu[i] * n / (i * i); &#125; if(ans &lt; K) return true; else return false;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif seive(); testCase = readIn(); while(testCase--)&#123; K = readIn(); ll l = 0, r = K * 2; while(r - l &gt; 1)&#123; ll mid = (l + r) &gt;&gt; 1; if(check(mid)) l = mid; else r = mid; &#125; printf(\"%lld\\n\", l + 1); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"莫比乌斯函数","slug":"莫比乌斯函数","permalink":"http://yoursite.com/tags/莫比乌斯函数/"}]},{"title":"BZOJ 1574: [Usaco2009 Jan]地震损坏Damage","slug":"BZOJ-1574-Usaco2009-Jan-地震损坏Damage","date":"2017-06-12T13:42:38.000Z","updated":"2017-06-12T13:44:13.660Z","comments":true,"path":"2017/06/12/BZOJ-1574-Usaco2009-Jan-地震损坏Damage/","link":"","permalink":"http://yoursite.com/2017/06/12/BZOJ-1574-Usaco2009-Jan-地震损坏Damage/","excerpt":"题目地址 描述农夫John的农场遭受了一场地震，有一些牛棚遭到了损坏，但幸运地，所有牛棚间的路径都还能使用。FJ的农场有$P(1 \\leq P \\leq 30,000)$个牛棚，编号$1 \\cdots P$； $C(1 \\leq C \\leq 100,000)$条双向路经联接这些牛棚，编号为$1 \\cdots C$，路经$i$连接牛棚$a_{i}$和$b_{i} (1 \\leq a_{i} \\leq P; 1 \\leq b_{i} \\leq P)$，路经可能连接$a_{i}$到它自己，两个牛棚之间可能有多条路径。农庄在编号为$1$的牛棚， $N (1 \\leq N \\leq P)$头在不同牛棚的牛通过手机短信$report_{j}(2 \\leq report_{j} \\leq P)$告诉FJ它们的牛棚$(report_{j})$没有损坏，但是它们无法通过路经和没有损坏的牛棚回到到农场。 当FJ接到所有短信之后，找出最小的不可能回到农庄的牛棚数目。这个数目包括损坏的牛棚。 注意:前50次提交将提供在一些测试数据上的运行结果。","text":"题目地址 描述农夫John的农场遭受了一场地震，有一些牛棚遭到了损坏，但幸运地，所有牛棚间的路径都还能使用。FJ的农场有$P(1 \\leq P \\leq 30,000)$个牛棚，编号$1 \\cdots P$； $C(1 \\leq C \\leq 100,000)$条双向路经联接这些牛棚，编号为$1 \\cdots C$，路经$i$连接牛棚$a_{i}$和$b_{i} (1 \\leq a_{i} \\leq P; 1 \\leq b_{i} \\leq P)$，路经可能连接$a_{i}$到它自己，两个牛棚之间可能有多条路径。农庄在编号为$1$的牛棚， $N (1 \\leq N \\leq P)$头在不同牛棚的牛通过手机短信$report_{j}(2 \\leq report_{j} \\leq P)$告诉FJ它们的牛棚$(report_{j})$没有损坏，但是它们无法通过路经和没有损坏的牛棚回到到农场。 当FJ接到所有短信之后，找出最小的不可能回到农庄的牛棚数目。这个数目包括损坏的牛棚。 注意:前50次提交将提供在一些测试数据上的运行结果。 分析DFS，题意描述的有点奇怪，一开始没有看懂。其实就是在保证损坏的牛棚与农庄（编号为$1$的牛棚）不联通的情况下，求出最小的不可能回到农庄的牛棚数目。 保证损坏的牛棚与农庄（编号为$1$的牛棚）不联通，那么我们可以先预处理吧所有与损坏的牛棚联通的点先删去。然后DFS一遍求出从农庄（编号为$1$的牛棚）能到达的最多的点的数量$cnt$，$ans = P - cnt$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//2017/06/12 11:24:07//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1574: [Usaco2009 Jan]地震损坏Damage#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 30000 + 3;int P, C, N;vector&lt;int&gt; G[MAX];bool vis[MAX], del[MAX];int ans;void dfs(int u)&#123; ans++; vis[u] = 1; for(unsigned int i = 0; i &lt; G[u].size(); ++i)&#123; if(!vis[G[u][i]] &amp;&amp; !del[G[u][i]]) dfs(G[u][i]); &#125;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif P = readIn(), C = readIn(), N = readIn(); for(int i = 0; i &lt; C; ++i)&#123; int u = readIn(), v = readIn(); u--; v--; G[u].push_back(v); G[v].push_back(u); &#125; memset(vis, 0, sizeof vis); memset(del, 0, sizeof del); for(int i = 0; i &lt; N; ++i)&#123; int x = readIn(); x--; for(unsigned int i = 0; i &lt; G[x].size(); ++i) del[G[x][i]] = true; &#125; dfs(0); printf(\"%d\\n\", P - ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"DFS及BFS","slug":"DFS及BFS","permalink":"http://yoursite.com/tags/DFS及BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"}]},{"title":"BZOJ 1572: [Usaco2009 Open]工作安排Job","slug":"BZOJ-1572-Usaco2009-Open-工作安排Job","date":"2017-06-11T16:11:21.000Z","updated":"2017-06-12T11:19:47.683Z","comments":true,"path":"2017/06/12/BZOJ-1572-Usaco2009-Open-工作安排Job/","link":"","permalink":"http://yoursite.com/2017/06/12/BZOJ-1572-Usaco2009-Open-工作安排Job/","excerpt":"题目地址 描述Farmer John 有太多的工作要做啊！为了让农场高效运转，他必须靠他的工作赚钱，每项工作花一个单位时间。他的工作日从$0$时刻开始，有$1000000000$个单位时间。在任一时刻，他都可以选择编号$1 \\sim N$的$N(1 \\leq N \\leq 100000)$项工作中的任意一项工作来完成。因为他在每个单位时间里只能做一个工作，而每项工作又有一个截止日期，所以他很难有时间完成所有$N$个工作，虽然还是有可能。 对于第i个工作，有一个截止时间$D_{i}(1 \\leq D_{i} \\leq 1000000000)$，如果他可以完成这个工作，那么他可以获利$P_{i}( 1 \\leq P_{i} \\leq 1000000000 )$。在给定的工作利润和截止时间下，FJ能够获得的利润最大为多少呢？答案可能会超过32位整型。","text":"题目地址 描述Farmer John 有太多的工作要做啊！为了让农场高效运转，他必须靠他的工作赚钱，每项工作花一个单位时间。他的工作日从$0$时刻开始，有$1000000000$个单位时间。在任一时刻，他都可以选择编号$1 \\sim N$的$N(1 \\leq N \\leq 100000)$项工作中的任意一项工作来完成。因为他在每个单位时间里只能做一个工作，而每项工作又有一个截止日期，所以他很难有时间完成所有$N$个工作，虽然还是有可能。 对于第i个工作，有一个截止时间$D_{i}(1 \\leq D_{i} \\leq 1000000000)$，如果他可以完成这个工作，那么他可以获利$P_{i}( 1 \\leq P_{i} \\leq 1000000000 )$。在给定的工作利润和截止时间下，FJ能够获得的利润最大为多少呢？答案可能会超过32位整型。 分析很典型的贪心题。 首先还是按照时间顺序排序，若时间相同按照利润的大小从小到大排序。 首先先加上所有的工作的利润，然后用按照从小到大排序的优先队列筛去同一时间但是利润不是最大的那个工作，最后就可以得到答案。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//2017/6/11 23:43//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1572 [Usaco2009 Open]工作安排Job#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; ll x = 0; int f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return (ll)x * f;&#125;const int MAX = 100000 + 3;int n;struct Work&#123; ll dl, p;//deadline, profits; bool operator &lt; (const Work &amp;rhs) const&#123; if(dl == rhs.dl) return p &lt; rhs.p;dl &lt; rhs.dl; return dl &lt; rhs.dl; &#125;&#125;work[MAX];priority_queue&lt; ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; q;//按照从小到大的顺序排序int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(); for(int i = 0; i &lt; n; ++i) &#123; work[i].dl = readIn(), work[i].p = readIn(); &#125; sort(work, work + n); ll ans = 0, sum = 0; for(int i = 0; i &lt; n; ++i)&#123; ans += work[i].p; sum++; q.push(work[i].p); if(sum &gt; work[i].dl)&#123; ans -= q.top(); q.pop(); sum--; &#125; &#125; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}]},{"title":"BZOJ 1571: [Usaco2009 Open]滑雪课Ski","slug":"BZOJ-1571-Usaco2009-Open-滑雪课Ski","date":"2017-06-11T12:57:17.000Z","updated":"2017-06-11T16:13:12.978Z","comments":true,"path":"2017/06/11/BZOJ-1571-Usaco2009-Open-滑雪课Ski/","link":"","permalink":"http://yoursite.com/2017/06/11/BZOJ-1571-Usaco2009-Open-滑雪课Ski/","excerpt":"题目地址 描述Farmer John 想要带着Bessie一起在科罗拉多州一起滑雪。很不幸，Bessie滑雪技术并不精湛。Bessie了解到，在滑雪场里，每天会提供$S(0 \\leq S \\leq 100)$门滑雪课。第$i$节课始于$M_{i}(1 \\leq M_{i} \\leq 10000)$，上的时间为$L_{i}(1 \\leq L_{i} \\leq 10000)$。上完第$i$节课后，Bessie的滑雪能力会变成$A_{i}(1 \\leq A_{i} \\leq 100)$。 注意：这个能力是绝对的，不是能力的增长值。Bessie买了一张地图，地图上显示了$N(1 \\leq N \\leq 10,000)$个可供滑雪的斜坡，从第$i$个斜坡的顶端滑至底部所需的时长$D_{i}(1 \\leq D_{i} \\leq 10000)$，以及每个斜坡所需要的滑雪能力$C_{i}(1\\leq C_{i} \\leq 100)$，以保证滑雪的安全性。Bessie的能力必须大于等于这个等级，以使得她能够安全滑下。Bessie可以用她的时间来滑雪，上课，或者美美地喝上一杯可可汁，但是她必须在$T(1 \\leq T \\leq 10000)$时刻离开滑雪场。这意味着她必须在$T$时刻之前完成最后一次滑雪。 求Bessie在实现内最多可以完成多少次滑雪。这一天开始的时候，她的滑雪能力为$1$。","text":"题目地址 描述Farmer John 想要带着Bessie一起在科罗拉多州一起滑雪。很不幸，Bessie滑雪技术并不精湛。Bessie了解到，在滑雪场里，每天会提供$S(0 \\leq S \\leq 100)$门滑雪课。第$i$节课始于$M_{i}(1 \\leq M_{i} \\leq 10000)$，上的时间为$L_{i}(1 \\leq L_{i} \\leq 10000)$。上完第$i$节课后，Bessie的滑雪能力会变成$A_{i}(1 \\leq A_{i} \\leq 100)$。 注意：这个能力是绝对的，不是能力的增长值。Bessie买了一张地图，地图上显示了$N(1 \\leq N \\leq 10,000)$个可供滑雪的斜坡，从第$i$个斜坡的顶端滑至底部所需的时长$D_{i}(1 \\leq D_{i} \\leq 10000)$，以及每个斜坡所需要的滑雪能力$C_{i}(1\\leq C_{i} \\leq 100)$，以保证滑雪的安全性。Bessie的能力必须大于等于这个等级，以使得她能够安全滑下。Bessie可以用她的时间来滑雪，上课，或者美美地喝上一杯可可汁，但是她必须在$T(1 \\leq T \\leq 10000)$时刻离开滑雪场。这意味着她必须在$T$时刻之前完成最后一次滑雪。 求Bessie在实现内最多可以完成多少次滑雪。这一天开始的时候，她的滑雪能力为$1$。 分析动态规划水题，看到的第一眼感觉和[Hnoi2017]大佬有一点像，不过相比简单多了。 定义状态：$dp[i][j]$为在$i$时刻，上第$j$堂课能够滑雪的最多次数。（也可以定义为在时刻$i$能力为$j$，能够滑雪最多的次数）一共有$3$种转移的状态： 美美地喝上一杯可可汁，$dp[i][j] = max(dp[i][j, dp[i - 1][j]) \\cdots (i \\neq 0)$ 上课，$dp[i + lst[j]][j] = max(dp[i + lst[j]][j], dp[i][k]) \\cdots (st[j] = i, k为满足st[j] = i的可供选择的课程编号)$ 滑雪，$dp[i + a[j]][j] = max(dp[i + a[j]][j], dp[i][j] + 1) \\cdots (i + a[j] \\leq T)$ 数组$a[]$中储存的是预处理出的在同一能力下能够在最短时间完成一次滑雪的时间，这是我们贪心的出来的显而易见的结论。 然后就是各种需要注意的小细节，然后，没有了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//2017/6/11 20:47//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1571 [Usaco2009 Open]滑雪课Ski#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int INF = 0x3f3f3f3f;const int MAX_S = 100 + 3;const int MAX_N = 10000 + 3;int T, S, N;int st[MAX_S], lst[MAX_S], abt[MAX_S];//start, last, abilityint cap[MAX_N], t[MAX_N];//capacity, timeint dp[MAX_N][MAX_S], minTime[MAX_S];int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif T = readIn(), S = readIn(), N = readIn(); //printf(\"%d %d %d\\n\", T, S, N); for(int i = 1; i &lt;= S; ++i) st[i] = readIn(), lst[i] = readIn(), abt[i] = readIn(); //sort(abt, abt + S) abt[0] = 1;// memset(minTime, INF, sizeof minTime);// for(int i = 1; i &lt;= N; ++i)&#123; cap[i] = readIn(), t[i] = readIn(); for(int j = 0; j &lt;= S; ++j)&#123; if(cap[i] &lt;= abt[j]) minTime[j] = min(minTime[j], t[i]); &#125; &#125; memset(dp, -INF, sizeof dp); dp[0][0] = 0, st[0] = -1; for(int i = 0; i &lt;= T; ++i)&#123; for(int j = 0; j &lt;= S; ++j)&#123; if(i != 0) dp[i][j] = max(dp[i][j], dp[i - 1][j]); if(i == st[j])&#123; for(int k = 0; k &lt;= S; ++k) dp[i + lst[j]][j] = max(dp[i + lst[j]][j], dp[i][k]); &#125; if(i + minTime[j] &lt;= T) dp[i + minTime[j]][j] = max(dp[i][j] + 1, dp[i + minTime[j]][j]); &#125; &#125; int ans = 0; for(int i = 0; i &lt;= S; ++i) ans = max(ans, dp[T][i]); printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}]},{"title":"UVa 10883 - Supermean","slug":"UVa-10883-Supermean","date":"2017-06-10T09:10:46.000Z","updated":"2017-06-10T11:42:37.208Z","comments":true,"path":"2017/06/10/UVa-10883-Supermean/","link":"","permalink":"http://yoursite.com/2017/06/10/UVa-10883-Supermean/","excerpt":"题目地址 描述给出$n(n \\leq 50000)$个数，每相邻两个数求平均数，将得到$n - 1$个数。对这$n - 1$个数每相邻两个数求平均数，将得到$n - 2$个数。以此类推，最后得到$1$个数，求这个数。","text":"题目地址 描述给出$n(n \\leq 50000)$个数，每相邻两个数求平均数，将得到$n - 1$个数。对这$n - 1$个数每相邻两个数求平均数，将得到$n - 2$个数。以此类推，最后得到$1$个数，求这个数。 分析刚拿到这道题目的时候一点头绪都没有，然后就用$a, b, c, d$模拟了一下发现了一些好玩的东西。对$a, b, c, d$进行描述中所说的操作：$ = \\frac{a + b}{2} + \\frac{b + c}{2} + \\frac{c + d}{2}$$ = \\frac{a + 2b + c}{2} + \\frac{b + 2c + d}{2}$$ = \\frac{a + 3b + 3c + d}{8}$如果还没有看出来，可以以$a, b, c, d, e, f$来模拟：$ = \\frac{a + b}{2} + \\frac{b + c}{2} + \\frac{c + d}{2} + \\frac{d + e}{2} + \\frac{e + f}{2}$$ = \\frac{a + 2b + c}{4} + \\frac{b + 2c + d}{4} + \\frac{c + 2d + e}{4} + \\frac{d + 2e + f}{4}$$ = \\frac{a + 3b + 3c + d}{8} + \\frac{b + 3c + 3d + e}{8} + \\frac{c + 3d + 3e + f}{8}$$ = \\frac{a + 4b + 6c + 4d + e}{16} + \\frac{b + 4c + 6d + 4e + f}{16}$$ = \\frac{a + 5b + 10c + 10d + 5e + f}{32}$很明显分子上$a, b, c, d$等的系数就是二项式展开的系数，而分母也有规律，那么我们要求的式子就是：($a[i]$为$n$个数）明显$n$太大了，预处理显然不可能，如果用组合数本身的定义$C_{n}^{m} = \\frac{n!}{m! \\cdot (n - m)!}$计算阶层的时候会溢出，那怎么办？我以前做过一道和这个有点类似的概率题UVa 1639 - Candy，里面是用取对数来解决的这里我们也可以这么做。这里我们用公式$C_{n}^{k + 1} = C_{n}^{k} \\cdot \\frac{n - k}{k + 1}$来递推更新组合数。$ln(ans) = \\sum_{i = 0}^{n - 1}\\frac{ln(C_{n - 1}^{i}) \\cdot ln(a[i])}{ln(2^{n - 1})}$ $ln(ans) = \\sum_{i = 0}^{n - 1}ln(C_{n - 1}^{i}) + ln(a[i]) - ln(2^{n - 1})$ 其中$(ln(C_{n - 1}^{i + 1}) = ln(C_{n - 1}^{i}) + (n - 1 - i) - (i + 1))$最后用$exp$函数还原即可。 代码1234567891011121314151617181920212223242526272829303132333435363738//2017/6/10 0:23//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//UVa 10883 - Supermean#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 50000 + 3;int testCase;int n;double a[MAX];int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif testCase = readIn(); for(int kase = 1; kase &lt;= testCase; ++kase)&#123; n = readIn(); double ans = 0.0, C = 0.0; for(int i = 0; i &lt; n; ++i)&#123; scanf(\"%lf\", &amp;a[i]); if(a[i] &gt; 0) ans += exp(log(a[i]) + C - (n - 1) * log(2)); if(a[i] &lt; 0) ans -= exp(log(-a[i]) + C - (n - 1) * log(2)); C = C + log(n - i - 1) - log(i + 1); &#125; printf(\"Case #%d: %.3lf\\n\", kase, ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"精度处理","slug":"精度处理","permalink":"http://yoursite.com/tags/精度处理/"},{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"}]},{"title":"BZOJ 1232: [Usaco2008Nov]安慰奶牛cheer","slug":"BZOJ-1232-Usaco2008Nov-安慰奶牛cheer","date":"2017-06-09T11:33:27.000Z","updated":"2017-06-09T11:40:24.158Z","comments":true,"path":"2017/06/09/BZOJ-1232-Usaco2008Nov-安慰奶牛cheer/","link":"","permalink":"http://yoursite.com/2017/06/09/BZOJ-1232-Usaco2008Nov-安慰奶牛cheer/","excerpt":"题目地址 描述Farmer John变得非常懒，他不想再继续维护供奶牛之间供通行的道路。 道路被用来连接$N (5 \\leq N \\leq 10,000)$个牧场，牧场被连续地编号为$1 \\cdots N$，每一个牧场都是一个奶牛的家。FJ计划除去$P(N-1 \\leq P \\leq 100,000)$条道路中尽可能多的道路，但是还要保持牧场之间的连通性。你首先要决定那些道路是需要保留的$N-1$条道路。 第$j$条双向道路连接了牧场$S_{j}$和$E_{j}$ $(1 \\leq S_{j} \\leq N; 1 \\leq E_{j} \\leq N; S_{j} != E_{j})$，而且走完它需要$L_{j} (0 \\leq L_{j} \\leq 1,000)$的时间， 没有两个牧场是被一条以上的道路所连接。奶牛们非常伤心， 因为她们的交通系统被削减了， 你需要到每一个奶牛的住处去安慰她们。 每次你到达第$i$个牧场的时候(即使你已经到过)，你必须花去$C_{i} (1 \\leq C_{i} \\leq 1,000)$的时间和奶牛交谈。你每个晚上都会在同一个牧场(这是供你选择的)过夜，直到奶牛们都从悲伤中缓过神来。在早上起来和晚上回去睡觉的时候，你都需要和在你睡觉的牧场的奶牛交谈一次，这样你才能完成你的交谈任务。假设FarmerJohn采纳了你的建议，请计算出使所有奶牛都被安慰的最少时间。 对于你前10次的提交，你的程序会在一部分正式的测试数据上运行， 并且返回运行的结果。","text":"题目地址 描述Farmer John变得非常懒，他不想再继续维护供奶牛之间供通行的道路。 道路被用来连接$N (5 \\leq N \\leq 10,000)$个牧场，牧场被连续地编号为$1 \\cdots N$，每一个牧场都是一个奶牛的家。FJ计划除去$P(N-1 \\leq P \\leq 100,000)$条道路中尽可能多的道路，但是还要保持牧场之间的连通性。你首先要决定那些道路是需要保留的$N-1$条道路。 第$j$条双向道路连接了牧场$S_{j}$和$E_{j}$ $(1 \\leq S_{j} \\leq N; 1 \\leq E_{j} \\leq N; S_{j} != E_{j})$，而且走完它需要$L_{j} (0 \\leq L_{j} \\leq 1,000)$的时间， 没有两个牧场是被一条以上的道路所连接。奶牛们非常伤心， 因为她们的交通系统被削减了， 你需要到每一个奶牛的住处去安慰她们。 每次你到达第$i$个牧场的时候(即使你已经到过)，你必须花去$C_{i} (1 \\leq C_{i} \\leq 1,000)$的时间和奶牛交谈。你每个晚上都会在同一个牧场(这是供你选择的)过夜，直到奶牛们都从悲伤中缓过神来。在早上起来和晚上回去睡觉的时候，你都需要和在你睡觉的牧场的奶牛交谈一次，这样你才能完成你的交谈任务。假设FarmerJohn采纳了你的建议，请计算出使所有奶牛都被安慰的最少时间。 对于你前10次的提交，你的程序会在一部分正式的测试数据上运行， 并且返回运行的结果。 分析表示题面具有一定的迷惑性。讲了一大段话其实真正的重点只有，在保证图的连通性的条件下求到每一个牧场的花费的总时间最少。这不就是最小生成树吗？不过在这道题目中的权值指的是2倍的边权和边的两个端点的权值之和。最后一定要选一个端点权值最小的点做为起点。做完Kruskal之后加上这个点的权值即为我们所求的答案 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//2017/06/09 16:54:15//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1232:[Usaco2008Nov]安慰奶牛cheer#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 10000 + 3;const int MAX_M = 100000 + 3;int n, m;int a[MAX_N];int u[MAX_M], v[MAX_M], w[MAX_M];int rk[MAX_M], fa[MAX_M];inline bool cmp(int i, int j)&#123; return w[i] &lt; w[j];&#125;inline int find(int x)&#123; return fa[x] == x ? x : fa[x] = find(fa[x]);&#125;inline int Kruskal()&#123; int ans = 0; for(int i = 0; i &lt; n; ++i) fa[i] = i; for(int i = 0; i &lt; m; ++i) rk[i] = i; sort(rk, rk + m, cmp); for(int i = 0; i &lt; m; ++i)&#123; int e = rk[i]; int x = find(u[e]); int y = find(v[e]); if(x != y)&#123; ans += w[e]; fa[x] = y; &#125; &#125; return ans;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(), m = readIn(); for(int i = 0; i &lt; n; ++i) a[i] = readIn(); for(int i = 0; i &lt; m; ++i)&#123; u[i] = readIn(), v[i] = readIn(), w[i] = readIn(); u[i]--; v[i]--; w[i] = w[i] * 2 + a[u[i]] + a[v[i]]; &#125; sort(a, a + n); //for(int i = 0; i &lt; m; ++i) printf(\"%d \", w[i]); printf(\"%d\\n\", Kruskal() + a[0]); return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/最小生成树/"}]},{"title":"UVa 11174 - Stand in a Line","slug":"UVa-11174-Stand-in-a-Line","date":"2017-06-09T11:31:37.000Z","updated":"2017-06-09T11:32:52.783Z","comments":true,"path":"2017/06/09/UVa-11174-Stand-in-a-Line/","link":"","permalink":"http://yoursite.com/2017/06/09/UVa-11174-Stand-in-a-Line/","excerpt":"题目地址 描述村子里有$n(1 \\leq n \\leq 40000)$个人，有多少种方法可以把他们排成一列，是的没有人排在他父亲前面（有些人的父亲可能不在村子里）？输入$n$和每个人的编号及其父亲的编号，输出方案总数模$1000000000$的结果。","text":"题目地址 描述村子里有$n(1 \\leq n \\leq 40000)$个人，有多少种方法可以把他们排成一列，是的没有人排在他父亲前面（有些人的父亲可能不在村子里）？输入$n$和每个人的编号及其父亲的编号，输出方案总数模$1000000000$的结果。 分析村民由父子关系组织成了一个森林（森林：森林也可以看成是好多棵互不相连的非空的树），森林中可能有许多棵树，我们可以通过给森林添加一个虚拟结点从而将其转化成为树的形式，这样更方便我们求解，那么形象的表示就是这样的：考虑这棵有虚拟结点的数的排列方案数。 虚拟根下由3棵子树，每一棵子树都是相互独立的，给每一棵子树中的结点确定顺序，有$5 \\times 4 \\times 1$种方法。 再将所属同一棵子树中的结点当成相同的结点，那么接下来对三棵子树进行排列相当于对重复元素进行排列，而重复元素的全排列公式在这里运用表示为$\\frac {11!}{3! \\times 6! \\times 2!}$。 至此$ans = \\frac {11!}{3! \\times 6! \\times 2!} \\times 5 \\times 4 \\times 1 = 92400$ $f(i)$为以$i$为根的子树的方案数，$s(i)$为以$i$为根的子树的大小，$c_{j}$为结点$i$的第$j$个儿子。所以我们可以归纳出以结点$i$为根的子树有$f(i)$中排法：$f(i) = f(c_{1})f(c_{2}) \\cdots f(c_{k}) \\cdot \\frac {(s_{i} - 1)!} {s(c_{1})!s(c_{2})! \\cdots s(c_{k})!}$还可以进一步化简，对于不是根的结点$f(i) = \\frac{(s_{c_{i}} - 1)!} {s_{c_{i}}!} = \\frac {1}{s_{c_{i}}}$将其带入$ans = \\frac {(s(root) - 1)!} {s_{1} \\cdot s_{2} \\cdots s_{n}}(s(root) = n - 1)$，这一步的推导我并不是很确信，欢迎指谪。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//2017/06/09 09:13:17//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//UVa 11174 - Stand in a Line#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 40000 + 3;const int MOD = 1000000007;int testCase;int n, m;ll f[MAX];int fa[MAX], size[MAX];vector&lt;int&gt; G[MAX];inline void prepare() &#123; f[0] = 1; for(int i = 1; i &lt; MAX; ++i) f[i] = f[i - 1] * i % MOD;&#125;inline ll quickPow(ll a, ll b)&#123; ll res = 1; while(b)&#123; if(b &amp; 1) (res *= a) %= MOD; (a *= a) %= MOD; b &gt;&gt;= 1; &#125; return res;&#125;inline void dfs(int u)&#123; size[u] = 1; for(unsigned int i = 0; i &lt; G[u].size(); ++i)&#123; dfs(G[u][i]); size[u] += size[G[u][i]]; &#125;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif //printf(\"%lld\\n\", quickPow(2, 10)); prepare(); //for(int i = 1; i &lt; MAX; ++i) printf(\"%lld \", f[i]); testCase = readIn(); while(testCase--) &#123; n = readIn(), m = readIn(); memset(fa, 0, sizeof fa); memset(size, 0, sizeof size); for(int i = 0; i &lt;= n; ++i) G[i].clear(); for(int i = 0; i &lt; m; ++i) &#123; int u = readIn(), v = readIn(); G[v].push_back(u); fa[u] = v; &#125; for(int i = 1; i &lt;= n; ++i)&#123; if(!fa[i]) G[0].push_back(i); &#125; dfs(0); ll sum = 1; for(int i = 1; i &lt;= n; ++i) (sum *= size[i]) %= MOD; ll ans = (f[n] * quickPow(sum, MOD - 2)) % MOD; printf(\"%lld\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"}]},{"title":"BZOJ 1231: [Usaco2008 Nov]mixup2 混乱的奶牛","slug":"BZOJ-1231-Usaco2008-Nov-mixup2-混乱的奶牛","date":"2017-06-08T16:32:21.000Z","updated":"2017-06-08T17:12:05.651Z","comments":true,"path":"2017/06/09/BZOJ-1231-Usaco2008-Nov-mixup2-混乱的奶牛/","link":"","permalink":"http://yoursite.com/2017/06/09/BZOJ-1231-Usaco2008-Nov-mixup2-混乱的奶牛/","excerpt":"题目地址 描述混乱的奶牛 [Don Piele, 2007] Farmer John的$N(4 \\leq N \\leq 16)$头奶牛中的每一头都有一个唯一的编号$S_{i} (1 \\leq S_{i} \\leq 25,000)$。 奶牛为她们的编号感到骄傲， 所以每一头奶牛都把她的编号刻在一个金牌上， 并且把金牌挂在她们宽大的脖子上。 奶牛们对在挤奶的时候被排成一支“混乱”的队伍非常反感. 如果一个队伍里任意两头相邻的奶牛的编号相差超过$K (1 \\leq K \\leq 3400)$， 它就被称为是混乱的。比如说，当$N = 6, K = 1$时, $1, 3, 5, 2, 6, 4$ 就是一支“混乱”的队伍， 但是 $1, 3, 6, 5, 2, 4$ 不是(因为$5$和$6$只相差$1$)。那么，有多少种能够使奶牛排成”混乱”的队伍的方案呢？","text":"题目地址 描述混乱的奶牛 [Don Piele, 2007] Farmer John的$N(4 \\leq N \\leq 16)$头奶牛中的每一头都有一个唯一的编号$S_{i} (1 \\leq S_{i} \\leq 25,000)$。 奶牛为她们的编号感到骄傲， 所以每一头奶牛都把她的编号刻在一个金牌上， 并且把金牌挂在她们宽大的脖子上。 奶牛们对在挤奶的时候被排成一支“混乱”的队伍非常反感. 如果一个队伍里任意两头相邻的奶牛的编号相差超过$K (1 \\leq K \\leq 3400)$， 它就被称为是混乱的。比如说，当$N = 6, K = 1$时, $1, 3, 5, 2, 6, 4$ 就是一支“混乱”的队伍， 但是 $1, 3, 6, 5, 2, 4$ 不是(因为$5$和$6$只相差$1$)。那么，有多少种能够使奶牛排成”混乱”的队伍的方案呢？ 分析表示很久没有接触过动态规划了，今天做的时候竟没有想到是状压DP，表示实在是太弱了。首先看到$N(4 \\leq N \\leq 16)$是如此的小的时候就应该想到是状压DP，因为$N$很小的话可以用二进制来枚举每一头牛的编号的状态。记得我上次在最优配对的时候好像写过这样一句话： 其实我们从这道状压的基本题就可以看出状压DP实际上是将平面上离散的点压进二进制表示的集合中，有时候题目中不一定明确的说明它是离散的点，有时候可能是图的顶点，数轴上的坐标。 其实这道题目抽象来看每一头牛相当于一维数轴上离散的点，求每一个相邻的点之间差值大于$k$的方案数。 那么我们现在定义状态$dp[i][S]$为在已选的牛的集合$S$中最后一头牛是第$i$头牛的方案数。每一次枚举下一头牛选哪一头，每一头牛是否选择要依赖于前面那一头牛，如果当前下一头牛不在集合$S$中，且于前一头牛之间编号差值大于$k$则可以选。 所以我们有状态转移方程：$dp[j][S - \\{ j \\} ] += dp[i][S] (!(S \\&amp; (1 &lt;&lt; j)) \\&amp; \\&amp; abs(a[i] - a[j]) &gt; k)$ 最终的 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546//2017/6/8 22:39//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1231: [Usaco2008 Nov]mixup2 混乱的奶牛#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int INF = 0x3f3f3f3f;const int MAX = 16 + 3;int n, k;int a[MAX];ll dp[MAX][1 &lt;&lt; (MAX)];int main()&#123;#ifndef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(), k = readIn(); //printf(\"%d %d\\n\", n, k); for(int i = 0; i &lt; n; ++i) a[i] = readIn(); memset(dp, 0, sizeof dp); for(int i = 0; i &lt; n; ++i) dp[i][1 &lt;&lt; i] = 1; for(int S = 0; S &lt; (1 &lt;&lt; n); ++S)&#123; for(int i = 0; i &lt; n; ++i)&#123; if(S &amp; (1 &lt;&lt; i))&#123; for(int j = 0; j &lt; n; ++j)&#123; if(!(S &amp; (1 &lt;&lt; j)) &amp;&amp; abs(a[i] - a[j]) &gt; k) dp[j][S ^ (1 &lt;&lt; j)] += dp[i][S]; &#125; &#125; &#125; &#125; ll ans = 0; for(int i = 0; i &lt; n; ++i) ans += dp[i][(1 &lt;&lt; n) - 1]; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"状压DP","slug":"状压DP","permalink":"http://yoursite.com/tags/状压DP/"}]},{"title":"BZOJ 1230: [Usaco2008 Nov]lites 开关灯","slug":"BZOJ-1230-Usaco2008-Nov-lites-开关灯","date":"2017-06-08T09:07:39.000Z","updated":"2017-06-08T10:06:43.284Z","comments":true,"path":"2017/06/08/BZOJ-1230-Usaco2008-Nov-lites-开关灯/","link":"","permalink":"http://yoursite.com/2017/06/08/BZOJ-1230-Usaco2008-Nov-lites-开关灯/","excerpt":"题目地址 描述Farmer John尝试通过和奶牛们玩益智玩具来保持他的奶牛们思维敏捷， 其中一个大型玩具是牛栏中的灯。 $N (2 \\leq N \\leq 100,000)$ 头奶牛中的每一头被连续的编号为$1 \\cdots N$， 站在一个彩色的灯下面。刚到傍晚的时候, 所有的灯都是关闭的。 奶牛们通过N个按钮来控制灯的开关，按第$i$个按钮可以改变第$i$个灯的状态。奶牛们执行$M (1 \\leq M \\leq 100,000)$条指令，每个指令都是两个整数中的一个$(0 \\leq 指令号 \\leq 1)$。第$1$种指令(用$0$表示)包含两个数字$S_{i}$和$E_{i}$ $(1 \\leq S_{i} \\leq E_{i} &lt;= N)$，它们表示起始开关和终止开关，奶牛们只需要把从$S_{i}$到$E_{i}$之间的按钮都按一次，就可以完成这个指令。 第$2$种指令(用$1$表示)同样包含两个数字$S_{i}$和$E_{i}$ $(1 \\leq S_{i} \\leq E_{i} &lt;= N)$，不过这种指令是询问从$S_{i}$到$E_{i}$之间的灯有多少是亮着的。 帮助FJ确保他的奶牛们可以得到正确的答案.","text":"题目地址 描述Farmer John尝试通过和奶牛们玩益智玩具来保持他的奶牛们思维敏捷， 其中一个大型玩具是牛栏中的灯。 $N (2 \\leq N \\leq 100,000)$ 头奶牛中的每一头被连续的编号为$1 \\cdots N$， 站在一个彩色的灯下面。刚到傍晚的时候, 所有的灯都是关闭的。 奶牛们通过N个按钮来控制灯的开关，按第$i$个按钮可以改变第$i$个灯的状态。奶牛们执行$M (1 \\leq M \\leq 100,000)$条指令，每个指令都是两个整数中的一个$(0 \\leq 指令号 \\leq 1)$。第$1$种指令(用$0$表示)包含两个数字$S_{i}$和$E_{i}$ $(1 \\leq S_{i} \\leq E_{i} &lt;= N)$，它们表示起始开关和终止开关，奶牛们只需要把从$S_{i}$到$E_{i}$之间的按钮都按一次，就可以完成这个指令。 第$2$种指令(用$1$表示)同样包含两个数字$S_{i}$和$E_{i}$ $(1 \\leq S_{i} \\leq E_{i} &lt;= N)$，不过这种指令是询问从$S_{i}$到$E_{i}$之间的灯有多少是亮着的。 帮助FJ确保他的奶牛们可以得到正确的答案. 分析线段树区间异或。水题一枚，好高兴1A。我们令关灯为0，开灯为1。用线段树维护一段区间内1的个数，相当于区间求和。每次更新的时候用nodes[o].addV ^= 1就可以更新灯的当前状态了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//2017/6/8 12:25//Copyright (c) 2017年 ZJYelizaveta. All rights reserved.//BZOJ 1230 [Usaco2008 Nov]lites 开关灯 线段树区间异或#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 100000 + 3;int n, m;namespace Segment_Tree&#123; const int MAXNODE = (1 &lt;&lt; 17) * 4; #define ls (((o) &lt;&lt; 1) + 1) #define rs (((o) &lt;&lt; 1) + 2) #define mid (((l) + (r)) &gt;&gt; 1) struct Node&#123; int addV, sum; &#125;nodes[MAXNODE]; inline void pushUp(int o)&#123; nodes[o].sum = nodes[ls].sum + nodes[rs].sum; &#125; inline void build(int o, int l, int r)&#123; nodes[o].addV = 0; if(r - l == 1) nodes[o].sum = 0; else&#123; build(ls, l, mid), build(rs, mid, r); pushUp(o); &#125; &#125; inline void giveTagAdd(int o, int l, int r, int v) &#123; nodes[o].sum = (r - l) - nodes[o].sum; nodes[o].addV ^= 1; &#125; inline void pushDown(int o, int l, int r)&#123; if(nodes[o].addV != 0)&#123; giveTagAdd(ls, l, mid, nodes[o].addV), giveTagAdd(rs, mid, r, nodes[o].addV); nodes[o].addV = 0; &#125; &#125; inline void modify(int o, int l, int r, int a, int b, int v) &#123; if(r &lt;= a || l &gt;= b) return; if(l &gt;= a &amp;&amp; r &lt;= b) &#123; nodes[o].addV ^= 1; nodes[o].sum = (r - l) - nodes[o].sum; return;&#125;// else&#123; pushDown(o, l, r); modify(ls, l, mid, a, b, v); modify(rs, mid, r, a, b, v); pushUp(o); &#125; &#125; inline int query(int o, int l, int r, int a, int b)&#123; if(b &lt;= l || a &gt;= r) return 0; if(a &lt;= l &amp;&amp; r &lt;= b) return nodes[o].sum; else&#123; pushDown(o, l, r); return query(ls, l, mid, a, b) + query(rs, mid, r, a, b); &#125; &#125;&#125;using namespace Segment_Tree;int main()&#123;#ifdef DBEUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(), m = readIn(); build(0, 0, n); while(m--)&#123; int opt = readIn(), l = readIn() - 1, r = readIn(); if(opt == 0)&#123; modify(0, 0, n, l, r, 1); &#125; else if(opt == 1)&#123; printf(\"%d\\n\", query(0, 0, n, l, r)); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"}]},{"title":"BZOJ 2480: [Spoj 3105] Mod","slug":"BZOJ-2480-Spoj-3105-Mod","date":"2017-06-05T14:28:54.000Z","updated":"2017-06-04T12:15:07.889Z","comments":true,"path":"2017/06/05/BZOJ-2480-Spoj-3105-Mod/","link":"","permalink":"http://yoursite.com/2017/06/05/BZOJ-2480-Spoj-3105-Mod/","excerpt":"题目地址 描述已知数$a,p,b$，求满足$a^{x} \\equiv b \\ (mod \\ p)$的最小自然数$x$，$1 \\leq a, n, p \\leq 10^{9}$。","text":"题目地址 描述已知数$a,p,b$，求满足$a^{x} \\equiv b \\ (mod \\ p)$的最小自然数$x$，$1 \\leq a, n, p \\leq 10^{9}$。 分析EXBSGS的模板题目，Mark一下。分析请见BSGS及EXBSGS后面数据添加的好像是$p = 1$的情况，这个时候$ans = 0$没商量。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//BZOJ 2480: Spoj3105 Mod//2017/06/01 11:26:48//离散对数 + 数学#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;inline ll readIn()&#123; ll x = 0; int f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar();&#125; return (ll)x * f;&#125;const int INF = 0x3f3f3f3f;map &lt;ll, ll&gt; Map;inline ll quickMod(ll a, ll b, ll n)&#123; //a ^ b % n ll res = 1; while(b)&#123; if(b &amp; 1) (res *= a) %= n; (a *= a) %= n; b &gt;&gt;= 1; &#125; return res;&#125;inline ll gcd(ll a, ll b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;inline void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) x = 1, y = 0; else &#123; exgcd(b, a % b, y, x); y -= (a / b) * x; &#125;&#125;inline ll inv(ll v, ll Mod) &#123; ll x = 0, y = 0; exgcd(v, Mod, x, y); return (x % Mod + Mod) % Mod;&#125;inline ll BSGS(ll a, ll b, ll n)&#123; ll e = 1; ll m = (int)(sqrt(n + 0.5));//ceil(sqrt(n)); ll v = inv(quickMod(a, m, n), n); //printf(\"%lld\\n\", m); //printf(\"%lld\\n\", quickMod(a, m, n)); //printf(\"%lld\\n\", v); Map[1] = 0; for(int i = 1; i &lt; m; ++i)&#123; (e *= a) %= n; if(!Map.count(e)) Map[e] = i; &#125; ll i; for(i = 0; i &lt; m; ++i)&#123; if(Map.count(b)) return i * m + Map[b]; (b *= v) %= n; &#125; return -1;&#125;inline void solve(ll a, ll b, ll n)&#123; ll e = 1; a %= n, b %= n; for(int i = 0; i &lt; 100; ++i)&#123; if(e == b)&#123; printf(\"%d\\n\", i); return; &#125; (e *= a) %= n; &#125; int sum = 0; while(gcd(a, n) != 1)&#123; ll factor = gcd(a, n); if(b % factor)&#123; printf(\"No Solution\\n\"); return; &#125; n /= factor, sum++, b /= factor; (b *= inv(a / factor, n)) %= n; &#125; ll ans = BSGS(a, b, n); if(ans == -1) &#123;printf(\"No Solution\\n\"); return;&#125; printf(\"%lld\\n\", ans + sum);&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif while(1)&#123; ll a = readIn(), p = readIn(), b = readIn(); //printf(\"%lld %lld %lld\\n\", a, p, b); if(a == 0 &amp;&amp; p == 0 &amp;&amp; b == 0) break; if(p == 1) &#123; printf(\"0\\n\"); continue;&#125; Map.clear(); solve(a, b, p); &#125; return 0;&#125;","categories":[],"tags":[{"name":"BSGS & EXBSGS","slug":"BSGS-EXBSGS","permalink":"http://yoursite.com/tags/BSGS-EXBSGS/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"离散对数","slug":"离散对数","permalink":"http://yoursite.com/tags/离散对数/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"}]},{"title":"BZOJ 2818: Gcd","slug":"BZOJ-2818-Gcd","date":"2017-06-05T09:08:50.000Z","updated":"2017-06-04T12:13:48.206Z","comments":true,"path":"2017/06/05/BZOJ-2818-Gcd/","link":"","permalink":"http://yoursite.com/2017/06/05/BZOJ-2818-Gcd/","excerpt":"题目地址 描述给定整数$N$，求$1 \\leq x,y \\leq N$且$Gcd(x,y)$为素数的数对$(x,y)$有多少对， $1 \\leq N \\leq 10^{7}$。","text":"题目地址 描述给定整数$N$，求$1 \\leq x,y \\leq N$且$Gcd(x,y)$为素数的数对$(x,y)$有多少对， $1 \\leq N \\leq 10^{7}$。 分析如果一开始找不到思路，可以举一两个例子看一下。如$gcd(x, y) = 2, gcd(x, y) = 3, gcd(x, y) = 5, gcd(x, y) = 7$把式子稍微变一下$gcd(x, \\frac{y}{2}) = 1, gcd(x, \\frac{y}{3}) = 1, gcd(x, \\frac{y}{5}) = 1, gcd(x, \\frac{y}{7}) = 1$咦，好想知道怎么做了$gcd(a, b) = 1 \\Leftrightarrow a, b$互质。 以$gcd(x, y) = 2$为例子：假设$x \\leq \\frac{y}{2}$，那么这部分对答案的贡献就是小于或等于$\\frac{y}{2}$的正整数中与$\\frac{y}{2}$互素的数的个数。若$x \\geq \\frac{y}{2}$部分对答案的贡献与$x \\leq \\frac{y}{2}$是一样的，但是$x = \\frac{y}{2}$这部分计算了两次，所以$gcd(x, y) = 2$对于答案的贡献为。 那么对于其他的质数的操作也是这样的，每一个$gcd(x,y) = d (d\\in \\mathbb{P}, d &lt; N)$对答案的贡献都是。 所以我们先可以处理$1\\sim n(1 \\leq n \\leq N)$的区间中每一部分的$phi[i]$的前缀和，并存入数组$sum[]$。最后在循环体中累加ans就可以了$ans = sum[\\frac{n}{prime[i]}] \\cdot 2 - 1$（$i$的循环范围为[$1$， 小于等于$n$的质数个数]）。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//BZOJ 2818: Gcd//2017/5/31 14:36//euler phi#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 10000000 + 3;int n;bool isPrime[MAX];int prime[MAX], cnt = 0;int phi[MAX];LL sum[MAX];void findPrime()&#123; memset(prime, 0, sizeof 0); memset(isPrime, true, sizeof isPrime); isPrime[0] = false, isPrime[1] = false; for(int i = 2; i &lt;= n; ++i)&#123; if(isPrime[i]) prime[++cnt] = i; for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; ++j)&#123; isPrime[i * prime[j]] = false; if(i % prime[j] == 0) break; &#125; &#125;&#125;void eulerTable(int n)&#123; for(int i = 2; i &lt;= n; i++) phi[i] = 0; phi[1] = 1; for(int i = 2; i &lt;= n; i++)&#123; if(!phi[i])&#123; for(int j = i; j &lt;= n; j += i)&#123; if(!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); &#125; &#125; &#125;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(); eulerTable(n); findPrime(); memset(sum, 0, sizeof sum); for(int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + phi[i]; LL ans = 0; for(int i = 1; i &lt;= cnt; ++i) ans += sum[n / prime[i]] * 2 - 1; printf(\"%lld\\n\", ans); //check(); //for(int i = 1; i &lt;= n; ++i) printf(\"%d %lld\\n\", i, sum[i]); return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://yoursite.com/tags/欧拉函数/"}]},{"title":"BSGS及EXBSGS","slug":"BSGS及EXBSGS","date":"2017-06-02T14:28:20.000Z","updated":"2017-06-03T16:20:07.024Z","comments":true,"path":"2017/06/02/BSGS及EXBSGS/","link":"","permalink":"http://yoursite.com/2017/06/02/BSGS及EXBSGS/","excerpt":"离散对数定义在初等代数中，如果$a^{x} = b$，就说$x = log{_{a}}^{b}$，即$x$是以$a$为底$b$的对数。在模运算中也有相似的概念，但比初等对数中的要稍微复杂一些。对于$a^{x}\\equiv b(mod \\ n)$，我们要分成以下几种情况来讨论： $n$为素数，且$gcd(a, n) = 1$。 $n$为合数，且$gcd(a, n) \\neq 1$。 $n = 1$。","text":"离散对数定义在初等代数中，如果$a^{x} = b$，就说$x = log{_{a}}^{b}$，即$x$是以$a$为底$b$的对数。在模运算中也有相似的概念，但比初等对数中的要稍微复杂一些。对于$a^{x}\\equiv b(mod \\ n)$，我们要分成以下几种情况来讨论： $n$为素数，且$gcd(a, n) = 1$。 $n$为合数，且$gcd(a, n) \\neq 1$。 $n = 1$。 计算对于情况一，用BSGS算法来计算就可以了；对于情况二，用EXBSGS算法。 BSGS算法定义给定$a,b,n$，求最小的非负整数$x$，满足$a^{x}\\equiv b(mod \\ n)$，其中$n\\in \\mathbb{P}$。 分析最天真的算法暴力枚举，只要我们在稍微看一下方程的形式$a^{x}\\equiv b(mod \\ n)$，就可以联想到费马小定理$a^{n - 1} \\equiv 1 (mod \\ n)$。怎样在这里运用费马小定理呢？ 我们有式子这里简要的证明一下：$a^{x \\ (mod \\ (n - 1))} \\equiv a^{x} (mod \\ n)$$a^{x - k\\cdot (n - 1)} \\equiv a^{x} (mod \\ n)$$\\frac{a^{x}}{a^{k\\cdot (n - 1)}}\\equiv a^{x} (mod \\ n)$$\\frac{a^{x}}{(a^{n - 1})^{k}}\\equiv a^{x} (mod \\ n)$ $\\because n\\in \\mathbb{P}$ $\\therefore a^{n - 1} \\equiv 1 (mod \\ n)$ $\\therefore \\frac{a^{x}}{1^{m}}\\equiv a^{x} (mod \\ n)$ $\\because a^{x} \\equiv a^{x} (mod \\ n)$ $\\therefore a^{x \\ (mod \\ (n - 1))} \\equiv a^{x} (mod \\ n)$ 因为这个式子$a^{x \\ (mod \\ (n - 1))} \\equiv a^{x} (mod \\ n)$成立，所以我们确定答案$x$一定在$[0, n - 1)$的范围内，所以现在我们可以缩小暴力枚举的范围了。那么除了枚举之外我们还可以做什么？ 令$x = i \\cdot m + j$，原式写为：$a^{i \\cdot m + j} \\equiv b (mod \\ n)$$a^{j} \\equiv b \\cdot a^{-m \\cdot i} (mod \\ n)$$a^{j} \\equiv b \\cdot (a^{-m})^{i} (mod \\ n)$咦，$a^{-m}$这不是求$a^{m}$在模$n$下的逆元吗，$m$到到底值为什么我们现在还没有定义。我们取$m = n^{\\frac{1}{2}}$，后面证明这样取$m$算法实现起来最快。 现在预处理式子的左边，先求出$a^{j} \\ mod \\ n$的值，j的循环范围为$[1, m)$避免$x$的值超过$n$。然后用$map$来存$a^{j} \\ mod \\ n$和与其对应的$j$值，按照$a^{j}\\ (mod \\ n)\\rightarrow j$的关系映射到$map$中。 处理完式子左边之后，我们来处理式子的右边， 首先先处理处$a^{m}$的逆元，然后$i$循环的范围为$[0, m)$，开始枚举$i$，同时计算$b \\cdot (a^{-m})^{i} (mod \\ n)$的值，一旦存在一个$i$值，使得$a^{j} \\equiv b \\cdot (a^{-m})^{i} (mod \\ n)$，那么取出对应的$j$值，答案$x = i \\cdot m + j$。 当然如果不想求逆元的可以在开始的时候令$x = i \\cdot m - j$，那么式子就变为$(a^{m})^{i} \\equiv b \\cdot a^{j} \\ (mod \\ n)$，然后后面的处理都是一样的。 步骤1时间复杂度为$\\Theta (mlogm)$，每一轮都需要$\\Theta (logm)$，一共$\\Theta (\\frac{n}{m})$轮，总时间复杂度为$\\Theta ((m + \\frac{n}{m})logm)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657typedef long long ll;inline ll readIn()&#123; ll x = 0; int f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar();&#125; return (ll)x * f;&#125;const int INF = 0x3f3f3f3f;map &lt;ll, ll&gt; Map;inline ll quickMod(ll a, ll b, ll n)&#123; //a ^ b % n ll res = 1; while(b)&#123; if(b &amp; 1) (res *= a) %= n; (a *= a) %= n; b &gt;&gt;= 1; &#125; return res;&#125;inline ll gcd(ll a, ll b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;inline void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) &#123; if (b == 0) x = 1, y = 0; else &#123; exgcd(b, a % b, y, x); y -= (a / b) * x; &#125;&#125;inline ll inv(ll v, ll Mod) &#123; ll x = 0, y = 0; exgcd(v, Mod, x, y); return (x % Mod + Mod) % Mod;&#125;inline ll BSGS(ll a, ll b, ll n)&#123; ll e = 1; ll m = (int)(sqrt(n + 0.5));//ceil(sqrt(n)); ll v = inv(quickMod(a, m, n), n); Map[1] = 0; for(int i = 1; i &lt; m; ++i)&#123; (e *= a) %= n; if(!Map.count(e)) Map[e] = i; &#125; ll i; for(i = 0; i &lt; m; ++i)&#123; if(Map.count(b)) return i * m + Map[b]; (b *= v) %= n; &#125; return -1;&#125; EXBSGS算法定义给定$a,b,n$，求最小的非负整数$x$，满足$a^{x}\\equiv b(mod \\ n)$。 分析此时我们对$a, b, n$都没有任何性质了，但是不幸的是费马小定理在某些情况下好像不成立了，怎么办？ 继续分类讨论，首先对于$n = 1$时，肯定$x = 0$，这是毫无疑问的。那么$n$为合数，且$gcd(a, n) \\neq 1$的时候怎么办？我们考虑将其往$n$为质数的情况上靠。$a^{x} \\equiv b \\ (mod \\ n)$$a^{x} = b + k \\cdot n$$a^{x} - k \\cdot n = b$现在令$d = gcd(a, n)$，如果$b \\nmid d$，那么$a^{x}\\equiv b(mod \\ n)$无解。如果$b \\mid d$，则有：$\\frac{a^{x}}{d} - \\frac{k \\cdot n}{d} = \\frac{b}{d}$$a^{x - 1}\\cdot \\frac{a}{d} - \\frac{k \\cdot n}{d} = \\frac{b}{d}$即，$a^{x - 1}\\cdot \\frac{a}{d} = \\frac{b}{d}+ \\frac{k \\cdot n}{d}$$a^{x - 1}\\cdot \\frac{a}{d} \\equiv \\frac{b}{d} (mod \\ \\frac{k \\cdot n}{d})$若此时$gcd(\\frac{a}{d}, \\frac{n}{d}) = 1$，那么将式子变化为$a^{x - 1} \\equiv \\frac{b}{d}\\cdot (\\frac{a}{d})^{-1} \\ (mod \\ n)$。此时调用BSGS就可以了。若$gcd(\\frac{a}{d}, \\frac{n}{d}) \\neq 1$，那么继续如上的操作，直至$gcd(a, n) = 1$为止。 代码1234567891011121314151617181920212223242526inline void EXBSGS(ll a, ll b, ll n)&#123; ll e = 1; a %= n, b %= n; for(int i = 0; i &lt; 100; ++i)&#123; if(e == b)&#123; printf(\"%d\\n\", i); return; &#125; (e *= a) %= n; &#125;//force(可要可不要) int sum = 0; while(gcd(a, n) != 1)&#123; ll factor = gcd(a, n); if(b % factor)&#123; printf(\"No Solution\\n\"); return; &#125; n /= factor, sum++, b /= factor; (b *= inv(a / factor, n)) %= n; &#125; ll ans = BSGS(a, b, n); if(ans == -1) &#123;printf(\"No Solution\\n\"); return;&#125; printf(\"%lld\\n\", ans + sum);&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"BSGS & EXBSGS","slug":"BSGS-EXBSGS","permalink":"http://yoursite.com/tags/BSGS-EXBSGS/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"离散对数","slug":"离散对数","permalink":"http://yoursite.com/tags/离散对数/"}]},{"title":"UVa 11609 - Teams","slug":"UVa-11609-Teams","date":"2017-06-02T12:48:25.000Z","updated":"2017-06-02T12:49:53.566Z","comments":true,"path":"2017/06/02/UVa-11609-Teams/","link":"","permalink":"http://yoursite.com/2017/06/02/UVa-11609-Teams/","excerpt":"题目地址 描述有$n$个人，选一个或多个参加比赛，其中先一个人当队长，有多少种方案？如果参赛者完全相同，但队长不同，算作不同方案。输入$n(1 \\leq n \\leq 10^{9})$，输出方案数总数除以$1000000007$。","text":"题目地址 描述有$n$个人，选一个或多个参加比赛，其中先一个人当队长，有多少种方案？如果参赛者完全相同，但队长不同，算作不同方案。输入$n(1 \\leq n \\leq 10^{9})$，输出方案数总数除以$1000000007$。 分析首先因为$n(1 \\leq n \\leq 10^{9})$，所以预处理出所有的组合数肯定是不行的，那么我们尝试对式子进行化简，使得我们仅通过$n$就可以算出方案数。我们可以将答案表示为$ans = \\sum_{k = 1}^{n}k \\cdot C_{n}^{k}$（这个应该容易想到ans ） $ \\therefore ans = 1 \\cdot C_{n}^{1} + 2 \\cdot C_{n}^{2} + \\cdots + (n - 1) \\cdot C_{n}^{n - 1} + n \\cdot C_{n}^{n}$ $\\because C_{n}^{k} = \\frac{n!}{(n - k)!k!}$ $\\therefore k \\cdot C_{n}^{1} = k \\cdot \\frac{n!}{(n - k)!k!} = \\frac{n!}{(n - k)!(k - 1)!} = n \\cdot \\frac{(n - 1)!}{(n - k)!(k - 1)!} = n \\cdot C_{n - 1}^{k - 1}$ $\\therefore ans = n \\cdot (C_{n - 1}^{0} + C_{n - 1}^{1} + \\cdots + C_{n - 1}^{n - 2} + C_{n - 1}^{n - 1})$ $\\because (a + b)^{n} = \\sum_{k = 0}^{n}C_{n}^{k}a^{n - k}b^{k}$为二项式展开系数。 $\\therefore ans = n \\cdot ((1 + 1)^{n - 1}) = n \\cdot 2^{n - 1}$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041//UVa 11609 - Teams//2017/06/02 12:55:35#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;inline ull readIn()&#123; ull x = 0; int f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MOD = 1000000007;int testCase;ull n;inline ull quickPow(ull a, ull b)&#123; ull res = 1; while(b)&#123; if(b &amp; 1) (res *= a) %= MOD; (a *= a) %= MOD; b &gt;&gt;= 1; &#125; return res;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif scanf(\"%d\", &amp;testCase); for(int kase = 1; kase &lt;= testCase; ++kase)&#123; printf(\"Case #%d: \", kase); n = readIn(); ull ans = (n * quickPow(2, n - 1)) % MOD; printf(\"%llu\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"快速幂&快速幂取模","slug":"快速幂-快速幂取模","permalink":"http://yoursite.com/tags/快速幂-快速幂取模/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"}]},{"title":"欧拉函数","slug":"欧拉函数","date":"2017-05-31T13:38:03.000Z","updated":"2017-11-20T10:59:56.721Z","comments":true,"path":"2017/05/31/欧拉函数/","link":"","permalink":"http://yoursite.com/2017/05/31/欧拉函数/","excerpt":"定义对于正整数$n$，欧拉函数$\\phi (n)$表示小于或等于$n$的正整数中与$n$互素的数的个数。 性质欧拉函数有一下四种性质：$\\bigstar \\ \\phi(1) = 1$$\\bigstar \\ \\phi (n) = n \\cdot \\prod_{p\\mid n}(\\frac{p - 1}{p})$$\\bigstar \\ \\phi (p^{k}) = p^{k} - p^{k - 1}\\cdots \\cdots (p\\in \\mathbb{P})$$\\bigstar \\ \\phi (mn) = \\phi (m) \\phi (n)\\cdots \\cdots gcd(m, n) = 1$","text":"定义对于正整数$n$，欧拉函数$\\phi (n)$表示小于或等于$n$的正整数中与$n$互素的数的个数。 性质欧拉函数有一下四种性质：$\\bigstar \\ \\phi(1) = 1$$\\bigstar \\ \\phi (n) = n \\cdot \\prod_{p\\mid n}(\\frac{p - 1}{p})$$\\bigstar \\ \\phi (p^{k}) = p^{k} - p^{k - 1}\\cdots \\cdots (p\\in \\mathbb{P})$$\\bigstar \\ \\phi (mn) = \\phi (m) \\phi (n)\\cdots \\cdots gcd(m, n) = 1$ 证明1$ \\bigstar \\ \\phi(1) = 1$ 根据欧拉函数 $phi(i)$ 的定义推知，这是显然的。 证明2$ \\ \\bigstar \\ \\phi (p^{k}) = p^{k} - p^{k - 1}\\cdots \\cdots (p\\in \\mathbb{P})$ $\\because p\\in \\mathbb{P}$$\\therefore$小于或等于 $p^{k}$ 的正整数中与 $p^{k}$ 互素的数只有 $p$ 的倍数。$\\because$小于或等于 $p^{k}$ 的正整数中与 $p^{k}$ 互素的数的个数为 $\\frac{p^{k}}{p}$ ，化简之后为 $p^{k - 1}$$\\therefore \\phi (p^{k}) = p^{k} - p^{k - 1}\\cdots \\cdots (p\\in \\mathbb{P})$ 证明3$\\ \\bigstar \\phi (mn) = \\phi (m) \\phi (n)\\cdots \\cdots gcd(m, n) = 1$很惭愧这一个我还不会证明，不过数论概论（原书第三版）$P44 \\sim P45$给出了证明。 计算现在要计算 $phi[i]$ 的值，我们有公式： phi(n) = n \\cdot (1 - \\frac{1}{p_{1}})(1 - \\frac{1}{p_{2}})\\cdots (1 - \\frac{1}{p_{n}}) \\because \\phi(n) = \\left\\{\\begin{matrix} n - 1 & (n \\in \\mathbb{P}) \\\\ p^{k} - p^{k - 1} & (n = p^{k}, p \\in \\mathbb{P}) \\end{matrix}\\right. \\because n = p{1}^{k{1}}p{1}^{k{2}}\\cdots p{n - 1}^{k{n - 1}}p{n}^{k{n}} \\begin{align*} \\therefore \\phi (n) &= \\phi (p_{1}^{k_{1}})\\phi (p_{2}^{k_{2}})\\cdots \\phi (p_{n - 1}^{k_{n - 1}})\\phi (p_{n}^{k_{n}})\\\\ &= (p{1}^{k{1}} - p{1}^{k{1} - 1})(p{2}^{k{2}} - p{2}^{k{2} - 1})\\cdots (p{n}^{k{n}} - p{n}^{k{n} - 1})\\\\ &= p{1}^{k{1} - 1}(p{1} - 1)p{2}^{k{2} - 1}(p{2} - 1)\\cdots p{n}^{k{n} - 1}(p_{n} - 1)\\\\ &= p{1}^{k{1}}\\frac{(p{1} - 1)}{p{1}}p{2}^{k{2}}\\frac{(p{2} - 1)}{p{2}}\\cdots p{n}^{k{n}}\\frac{(p{n} - 1)}{p{n}}\\\\ &= p{1}^{k{1}}p{2}^{k{2}}\\cdots p{n}^{k{n}}\\cdot \\frac{(p{1} - 1)}{p{1}}\\frac{(p{2} - 1)}{p{2}}\\cdots \\frac{(p{n} - 1)}{p{n}}\\\\ &= n \\cdot (1 - \\frac{1}{p{1}})(1 - \\frac{1}{p{2}})\\cdots (1 - \\frac{1}{p_{n}}) \\end{align*}$\\bigstar \\ \\phi (n) = n \\cdot \\prod_{p\\mid n}(\\frac{p - 1}{p})$ 那么这个式子也得证了，这个式子只是用于计算单个 $phi[i]$ 的值，来构造一个小于等于 $n$ 的 $phi$ 表。计算第 $n$ 个数的 $phi$ 值，要用到这个式子： \\phi(n) = \\sum_{S \\subseteq \\{p_{1}, p_{2}, cdots, p_{3}\\}}(-1)^{\\left | S \\right |} \\frac{n}{\\prod_{p_{i} \\in S} p_{i}}代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10000 + 3;int n;int phi[MAX];//求与第n个数互素的数的个数int euler_phi(int n) &#123; int m = (int)sqrt(n + 0.5); LL ans = n; for (int i = 2; i &lt;= m; i++) &#123; if (n % i == 0)&#123; ans = ans / i * (i - 1); while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) ans = ans / n * (n - 1); return ans;&#125;//1~n中所有数的欧拉phi函数值 O(nloglogn)void phi_table(int n)&#123; for(int i = 2; i &lt;= n; i++) phi[i] = 0; phi[1] = 1; for(int i = 2; i &lt;= n; i++)&#123; if(!phi[i])&#123; for(int j = i; j &lt;= n; j += i)&#123; if(!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); &#125; &#125; &#125;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\",\"r\",stdin);#endif scanf(\"%d\", &amp;n); printf(\"phi(%d) = %d\\n\", n, euler_phi(n)); for(int i = 1; i &lt;= n; i++)&#123; phi_table(i); printf(\"phi[%d] = %d\\n\", i, phi[i]); &#125; return 0;&#125;/*phi(n) 表示的含义是,不超过x且和x互素的整数个数.*/","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://yoursite.com/tags/欧拉函数/"}]},{"title":"BZOJ 1008: [HNOI2008]越狱","slug":"BZOJ-1008-HNOI2008-越狱","date":"2017-05-31T12:46:28.000Z","updated":"2017-06-03T16:30:15.362Z","comments":true,"path":"2017/05/31/BZOJ-1008-HNOI2008-越狱/","link":"","permalink":"http://yoursite.com/2017/05/31/BZOJ-1008-HNOI2008-越狱/","excerpt":"题目地址 描述监狱有连续编号为$1, 2, 3 \\cdots , N - 1, N$的$N(1 \\leq N \\leq 10^{12})$个房间，每个房间关押一个犯人，有$M(1 \\leq M \\leq 10^{8})$种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能越狱的状态数，模$100003$取余。","text":"题目地址 描述监狱有连续编号为$1, 2, 3 \\cdots , N - 1, N$的$N(1 \\leq N \\leq 10^{12})$个房间，每个房间关押一个犯人，有$M(1 \\leq M \\leq 10^{8})$种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能越狱的状态数，模$100003$取余。 分析 可能越狱的状态数$ans$，等于所有的状态数$sum$减去不可能越狱的状态数$total$。 我们要求所有的状态数$sum$的时候是没有任何限制的所以$sum = m^{n}$。 对于不可能越狱的状态数$total$： 当$n = 1$的时候，$total = m$； 当$n = 2$的时候，$total = m \\cdot (m - 1)$； 当$n = 3$的时候，$total = m \\cdot (m - 1) \\cdot (m - 1)$；$\\vdots $ 当$n = N$的时候，$total = m \\cdot (m - 1) ^ {n - 1}$ 对于除第一个监狱以外，每一个监狱选择的信仰依赖于前面那一个监狱，即选择与前一个监狱不一样的信仰，就可以让每一个相邻的监狱没有犯人的宗教相同。 $\\therefore ans = m^{n} - m \\cdot (m - 1)^{n - 1}(1 \\leq m \\leq 10^{8}, 1 \\leq n \\leq 10^{12})$因为$m, n$都太大了直接强行计算幂次方的时候容易溢出，所以这里用快速幂取模来算。快速幂取模依赖于以下递推式：我们也可以证明$a^{b} \\ \\%\\ Mod = [(a \\ \\% \\ Mod) \\cdot b] \\ \\% \\ Mod$两者等价。 代码123456789101112131415161718192021222324252627282930313233343536373839// BZOJ 1008: [HNOI2008]越狱//2017/5/31 8:32//数学 + 快速幂#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline LL readIn()&#123; LL x = 0; int f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MOD = 100003;const int INF = 0x3f3f3f3f;LL n, m;LL quickPow(LL a, LL b)&#123; LL res = 1; while(b)&#123; if(b &amp; 1) (res *= a) %= MOD; (a *= a) %= MOD; b &gt;&gt;= 1; &#125; return res;&#125;int main()&#123;#ifdef DEBUG freopen(\"test.in\", \"r\", stdin);#endif m = readIn(), n = readIn(); //printf(\"%lld\\n\", quickPow(m - 1, n - 1)); LL ans = (quickPow(m, n) - (m * quickPow(m - 1, n - 1)) % MOD + MOD) % MOD; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"快速幂&快速幂取模","slug":"快速幂-快速幂取模","permalink":"http://yoursite.com/tags/快速幂-快速幂取模/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"}]},{"title":"关于图的连通性的三个Tarjan算法","slug":"关于图的连通性的三个Tarjan算法","date":"2017-05-28T04:35:54.000Z","updated":"2017-05-29T14:51:43.885Z","comments":true,"path":"2017/05/28/关于图的连通性的三个Tarjan算法/","link":"","permalink":"http://yoursite.com/2017/05/28/关于图的连通性的三个Tarjan算法/","excerpt":"无向图的割点和桥定义对于无向图$G$，如果删除某点$u$之后，连通分量数目增加，称$u$为图的割点。对于无向图$G$， 如果删除某一条边$e = (u, v)$，连通分量数目增加，称$e$为图的桥。","text":"无向图的割点和桥定义对于无向图$G$，如果删除某点$u$之后，连通分量数目增加，称$u$为图的割点。对于无向图$G$， 如果删除某一条边$e = (u, v)$，连通分量数目增加，称$e$为图的桥。 分析求割点方法1： 尝试删除每一个结点，然后DFS一遍判断连通分量是否增加。$\\Theta (n)$删点，$\\Theta (n + m)$来DFS，时间复杂度为$\\Theta (n(n + m))$。 方法2： 尝试在线性时间内求出所有的割点，即DFS一遍，时间复杂度$\\Theta (n + m)$。那么首先我们我们将无向连通图DFS一遍之后会得到一个DFS森林，对于每一结点都有进入DFS森林的时间和出去的时间，那么我们记录每一条边进入的时间和出去的时间，也就是先后顺序（DFS序），就可以处理出每一个点与点之间、边与边之间的关系。通过每一个点的时间戳，我们可以知道DFS森林中有四种边。 树边：无向图的边$e = (u, v)$，会被访问两次，访问$u$的时候一次，访问$v$的时候一次。换句话就是，顶点v是在访问边$e = (u, v)$的时候才首次被访问的。 反向边：第一次处理的时候，对于边$e = (u, v)$，从$u$的后代$v$指向u的祖先的边，意味着存在自环。 前向边：连接顶点$u$到它的某一个后裔$v$的非树边 交叉边：在于同一棵深度优先树中的两个顶点$u, v$之间，条件是顶点$u$不是顶点$v$的祖先。交叉边也可以在不同的深度优先树的顶点之间。 无向图之后反向边和树边，而有向图除了树边和反向边之外还有前向边和交叉边。 假设当前的DFS森林中只有一棵树，那么根据定义树根肯定不是割点，当且仅当树根有两个及以上子树的时候，他才会是割点。 那么对于非根结点一般的情况如何判断其实不是割点就要依靠定理：在无向连通图$G$的DFS树中，非根结点$u$是$G$割点当且仅当$u$存在一个子结点$v$，使得$v$及其所有后代都没有反向边连回$u$的祖先，连回$u$的不算，即不存在反向边。证明：看一下图就可以明白了，如图所示： 考虑$u$的任意子结点$v$，如果$v$及其后代不能连回$f$，那么删除$u$之后$f$和$v$不再连通，此时$u$为割点。 反之，如果$v$或它的任意一个后代存在一条反向边连向$f$，那么，删除结点$u$以后$v$及$v$的子树中的结点仍能够通过这条反向边连回$f$，那么此时因为图仍是连通的，所以$u$不一定是割点。以上，得证。 那么我们的线性算法也就出来了，流程是这样的： 记$pre(u)$为结点$u$进入DFS森林中的时间戳，$low(u)$为$u$及其后代所能连回的最早的祖先的$pre$值。 依次访问结点$u$的每一个子结点。 对于没有访问过的子结点，DFS并用后代的$low$值来更新结点$u$的$low$函数，如果后代的$low$值均小于等于$pre[u]$，那么$u$结点为割点。 如果存在反向边，用反向边来更新$u$的$low$函数。 最后处理树根的情况。 求桥理解求割点，那么求桥就简单了。如果$v$的后代只能连回$v$自己，那么只需删除$(u, v)$一条边就能够使图非连通了，此时边$e = (u, v)$为桥。那么只需要把求割点的第三步改一下就可以了。 记$pre(u)$为结点$u$进入DFS森林中的时间戳，$low(u)$为$u$及其后代所能连回的最早的祖先的$pre$值。 依次访问结点$u$的每一个子结点。 对于没有访问过的子结点，DFS并用后代的$low$值来更新结点$u$的$low$函数，如果后代的$low$值均小于等于$pre[u]$，那么$e = (u, v)$为桥。 如果存在反向边，用反向边来更新$u$的$low$函数。 最后处理树根的情况。 代码1234567891011121314151617int dfs(int u, int fa)&#123; int lowu = pre[u] = ++timeStamp; int child = 0; for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(!pre[v])&#123;//u的子结点v没有访问过 child++; int lowv = dfs(v, u); lowu = min(lowu, lowv);//用子树中结点的low值来更新u结点的low函数 if(lowv &gt;= pre[u]) isCut[u] = true;//割边:lowv &gt; pre[u] &#125; else if(pre[v] &lt; pre[u] &amp;&amp; v != fa) lowu = min(lowu, pre[v]);//存在反向边，用反向边更新u的low函数 &#125; if(fa &lt; 0 &amp;&amp; child == 1) isCut[u] = false;//树根 low[u] = lowu; return lowu;&#125; 无向图的双连通分量定义对于一个连通图，如果任意两点至少存在两条“点不重复”的路径，则这个图是点-双连通的；即任意两条边都在同一个简单换中，连通图中不存在割点。对于一个连通图，如果人意两点之间至少存在两条“边不重复”的路径，则这个图是边-双连通的；即内一条边都至少在一个简单环中，连通图中不存在桥。 分析如图所示，这是一个无向图双连通分量例子： 点-双连通分量对于一张无向图，点-双连通的极大子图称为双连通分量。我们可以发现，每一条边有且仅属于一个点-双连通分量，但是不同的点-双连通分量可能会有公共点。可以证明不同的点-双连通分量最多只有一个公共点，且它一定是割点。这一个很好证明，我们假设两个点-双连通分量有两个及以上的公共点，那么无论删除其中哪一个点图的连通性也不会改变，根据割点的定义，这些公共点没有哪一个会是割点。任意割点也都至少会是两个不同点-双连通分量的公共点。 回顾求个点的过程，当我们找到割顶的时候，就已经完成了一次对某个极大点双连通子图的访问，那么我们如果在进行DFS的过程中将遍历过的点保存起来，那么就可以得到点双连通分量了。 为了实现算法，我们可以在求解割顶的过程中用一个栈保存遍历过的边（注意不是点！因为不同的双连通分量存在公共点即割顶），之后每当找到一个点双连通分量，即子结点$v$与父节点$u$满足关系$low[v]&gt;=pre[u]$，我们就将栈里的东西拿出来直到栈中没有与$u$相关联的点为止且现在取出的是当前边。 这里注意放入栈中的不是点，而是边，这是因为点双连通分量是存在重复点的，如果我们放入栈中的是点，那么对于某些点双连通分量，就会少掉一些点（这些点都是割顶）。栈S保存当前双连通分量中的边，注意这里是边不是点 边-双连通分量同理，边-双连通的极大子图称之为边-双连通分量。除了桥不属于任何边-双连通分量之外，其他每一条边恰好属于一个边-双连通分量。所以我们只要把图中的桥边都删除之后，那么此时每一个连通分量就是此无向图中的边-双连通分量。那么求边-双连通分量的方法也就很清晰了。 边双连通分量例题，将稍后填坑。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct Edge&#123; int from, to;&#125;;int pre[MAX_N], bccno[MAX_N], bcc_cnt, timeStamp;//结点进入DFS森林的值，编号为i的点所属的双连通分量，双连通分量个数，时间戳bool isCut[MAX_N];vector&lt;int&gt; G[MAX_N], bcc[MAX_N];//保存图和双连通分量stack&lt;int&gt; S;int dfs(int u, int fa)&#123; int lowu = pre[u] = ++timeStamp; int child = 0; for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; Edge e = edge&#123;u, v&#125;; if(!pre[v])&#123;//没有访问过的u的子结点v S.push(e); child++; int lowv = dfs(v, u); lowu = min(lowu, lowv);//有u的后代来更新u的low函数 if(lowv &gt;= pre[u])&#123;//边-双连通分量：lowv &gt; pre[u] isCut[u] = true; bcc_cnt++; bcc[bcc_cnt].clear();//BCC编号从1开始 while(1)&#123; Edge x = S.top(); S.pop();//逐一将边取出 if(bccno[x.u] != bcc_cnt) &#123;//这个点还没有统计到这个连通分量。 bcc[bcc_cnt].push_back(x.u); bccno[x.u] = bcc_cnt;&#125; if(bccno[x.v] != bcc_cnt) &#123; bcc[bcc_cnt].push_back(x.v); bccno[x.v] = bcc_cnt;&#125; if(x.u == u &amp;&amp; x.v == v) break;//扫到u-v，栈中又没有与u相连的边了。继续试试其他孩子 &#125; &#125; &#125; else if(pre[v] &lt; pre[u] &amp;&amp; v! = fa)&#123;//对于反向边 S.push(e); lowu = min(lowu, pre[v]);//用反向边更新u的low函数 &#125; &#125; if(fa &lt; 0 &amp;&amp; child == 1) isCut[u] = false;//树根 return lowu;&#125;void find_scc()&#123; memset(pre, 0, sizeof pre);//初始化 memset(bccno, 0, sizeof bccno); memset(isCut, 0, sizeof isCut); bcc_cnt = timeStamp = 0; for(int i = 0; i &lt; n; ++i) id(!pre[i]) dfs(i, -1);&#125; 有向图的强连通分量定义如无向图一样，有向图也有相互到达这概念，对于可相互到的点我们把这些点看做一个集合，每一个集合称为有向图的一个强连通分量，简称为SCC。如果把一个集合看做一个点，那么所有的SCC构成了一个SCC图，而这个SCC图根据定义肯定是一个有向无环图，也就是一个DAG，因为一单还存环肯定会缩成一个新的SCC。 如图所示，从$G$开始DFS，最后原图会变成如下所示： 分析如果我们从$A$开始DFS，那么最终算法会得出整个有向图都是连通的，也就是这颗DSF树会包含整个图。所以有时候从不同的点出发得出的SCC图和我们定义上所期望的会相差甚远，那么如何来解决这个问题呢？我们要将多哥SCC从一颗DFS树中分离出来。考虑一个强连通分量$C$，设其中第一个被发现的点为$x$，则$C$中其他的点我们认为是$x$的后代。我们希望在$x$的子节点访问完回到$x$之后就输强联通分量$C$，这样我们就可以把一棵树中的SCC都分离开。 如图所示：然后我们需要判断结点$u$是否为此SCC第一个被访问到的结点。 如果我们发现$u$的子结点出发可以到达$u$的祖先$w$，显然$u, v,w$在同一个SCC中但是此时$u$并不会是此SCC中第一个被访问到的结点而至少会是$w$。 如果$u$的所有子结点最多只能到达$u$，那么，$u$就是该SCC中第一个被发现的点。 问题被转化成为了求每一个点岁远能到达的祖先的low函数的值，这里的到达指的是通过当前SCC中的点到达，而不是通过已经确定SCC编号的其他点。 代码123456789101112131415161718192021222324252627282930313233vector&lt;int&gt; G[MAX_N];int pre[MAX_N], lowlink[MAX_N], sccno[MAX_N], scc_cnt, timeStamp;stack&lt;int&gt; S;void dfs(int u)&#123; pre[u] = lowlink[u] = ++timeStamp;//进入DFS树的时间 S.push(u); for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(!pre[v])&#123;//没有遍历过 dfs(v);//递归处理 lowlink[u] = min(lowlink[u], lowlink[v]);//回溯时发现v可以到达更小（DFS上更远）的时间戳 &#125; else if(!sccno[v]) lowlink[u] = min(lowlink[u], pre[v]);//访问过，且不在其他连通分量中的栈内的结点，反向边 &#125; if(lowlink[u] == pre[u])&#123;//u为当前强连通分量第一个访问到的结点 scc_cnt++; while(1)&#123; int x = S.top(); S.pop(); sccno[x] = scc_cnt; size[scc_cnt]++; if(x == u) break; &#125; &#125; //printf(\"%d\\n\", scc_cnt);&#125;void Tarjan()&#123; timeStamp = 0, scc_cnt =0;//初始化 memset(sccno, 0, sizeof sccno); memset(pre, 0, sizeof pre); for(int i = 1; i &lt;= n; ++i) if(!pre[i]) dfs(i);&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"割点","slug":"割点","permalink":"http://yoursite.com/tags/割点/"},{"name":"桥","slug":"桥","permalink":"http://yoursite.com/tags/桥/"},{"name":"边-双连通分量","slug":"边-双连通分量","permalink":"http://yoursite.com/tags/边-双连通分量/"},{"name":"点-双连通分量","slug":"点-双连通分量","permalink":"http://yoursite.com/tags/点-双连通分量/"},{"name":"强联通分量","slug":"强联通分量","permalink":"http://yoursite.com/tags/强联通分量/"},{"name":"Tarjan","slug":"Tarjan","permalink":"http://yoursite.com/tags/Tarjan/"}]},{"title":"UVa 12167 - Proving Equivalences","slug":"UVa-12167-Proving-Equivalences","date":"2017-05-28T03:02:19.000Z","updated":"2017-05-30T15:44:49.733Z","comments":true,"path":"2017/05/28/UVa-12167-Proving-Equivalences/","link":"","permalink":"http://yoursite.com/2017/05/28/UVa-12167-Proving-Equivalences/","excerpt":"题目地址 描述在数学中，我们常常需要完成若干个命题的等价性证明。比如，有4个命题$a, b, c, d$，我们证明$a \\leftrightarrow b$，然后$b\\leftrightarrow c$，最后$c\\leftrightarrow d$。注意每次证明都是双向的，一次一共完成了6次推导。另一种方法是证明$a\\rightarrow b$，然后$b\\rightarrow c$，接着$c\\rightarrow d$，最后$d\\rightarrow a$，只需4次。现在你的任务是证明$n(1 \\leq n \\leq 20000)$个命题是全部等价的，且你的朋友已经帮你做出了$m(0 \\leq m \\leq 50000)$次推导（已知每次推导的内容），你至少还需要做几次推导才能完成整个证明，输出最少的推导次数。","text":"题目地址 描述在数学中，我们常常需要完成若干个命题的等价性证明。比如，有4个命题$a, b, c, d$，我们证明$a \\leftrightarrow b$，然后$b\\leftrightarrow c$，最后$c\\leftrightarrow d$。注意每次证明都是双向的，一次一共完成了6次推导。另一种方法是证明$a\\rightarrow b$，然后$b\\rightarrow c$，接着$c\\rightarrow d$，最后$d\\rightarrow a$，只需4次。现在你的任务是证明$n(1 \\leq n \\leq 20000)$个命题是全部等价的，且你的朋友已经帮你做出了$m(0 \\leq m \\leq 50000)$次推导（已知每次推导的内容），你至少还需要做几次推导才能完成整个证明，输出最少的推导次数。 分析刘汝佳先生说的解释，其实有一些绕还有一些定理没有证明，这里我简要的理了一下逻辑，然后把证明做了。 我们其实可以把每一个命题看成一个结点，把推到看成一条有向边，如由$a$推导出$b$，那么连边$a\\rightarrow b$。那么我们一开始得到的其实是有$n$个结点$m$条有向边的有向图，而最终的等价性证明相当于添加最少的边，使当前的有向图形成一个环。也就是所有的点最终都会包含在同一个强连通分量中。那么，我们首先在原图上找出所有的强连通分量，然后把每一个强连通分量缩成一个点，得到一个DAG。 定理：设原图有$a$个入度为$0$的结点，$b$个出度为$0$的结点，则$max \\{a, b\\}$就是答案（这里的每一个结点对应原图的一个SCC）。 证明：既然要证明，那么我们就要构造出在任何情况下都能使结论成立的方案，那么进行如下的分类讨论。当入度为0的点多于出度为0的点的时候很好构造，如图：我们要分成两种情况来讨论： 我们把DAG看成一棵有向的树，有一种可能就是转化成树后是多个互不相干的树，我们进行如图的转换：若这多棵树中有树存在公共的叶结点，那么只需要在进行第一步的时候选择不与之相连的点连接，如图： 我们将DAG看成一棵有向树之后发现，最终只会形成一棵有向树，那么按照如图的方式处理： 综上所述，我们已经处理了所有的情况下构造方式，证毕。Orz Skipher学长，Sengxian学长 ヾ(o°ω°O)ノ゙ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//UVa 12167 - Proving Equivalences//2017/5/22 14:48//SCC#include &lt;bits/stdc+.h&gt;using namespace std;typedef long long LL;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 20000 + 3;const int MAX_M = 50000 + 3;const int INF = 0x3f3f3f3f;int testCase;int n, m;int pre[MAX_N], lowlink[MAX_N], sccno[MAX_N], scc_cnt, timeStamp;vector&lt;int&gt; G[MAX_M];stack&lt;int&gt; S;int in[MAX_N], out[MAX_N];namespace SCC&#123; void dfs(int u)&#123; pre[u] = lowlink[u] = ++timeStamp; S.push(u); for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(!pre[v])&#123; dfs(v); lowlink[u] = min(lowlink[u], lowlink[v]); &#125; else if(!sccno[v]) lowlink[u] = min(lowlink[u], pre[v]); &#125; if(lowlink[u] == pre[u])&#123; scc_cnt++; while(1)&#123; int x = S.top(); S.pop(); sccno[x] = scc_cnt; if(x == u) break; &#125; &#125; &#125; void findSCC(int n)&#123; memset(pre, 0, sizeof pre); memset(lowlink, 0, sizeof lowlink); memset(sccno, 0, sizeof sccno); timeStamp = scc_cnt = 0; for(int i = 0; i &lt; n; ++i) if(!pre[i]) dfs(i); &#125;&#125;using namespace SCC;int main()&#123;#ifndef DEBUG freopen(\"test.in\", \"r\", stdin);#endif testCase = readIn(); while(testCase--)&#123; n = readIn(), m = readIn(); for(int i = 0; i &lt; n; ++i) G[i].clear(); for(int i = 0; i &lt; m; ++i)&#123; int u = readIn(), v = readIn(); u--; v--; G[u].push_back(v); &#125; findSCC(n); for(int i = 1; i &lt;= scc_cnt; ++i) in[i] = out[i] = 1; for(int u = 0; u &lt; n; ++u)&#123; for(int i = 0; i &lt; G[u].size(); ++i)&#123; int v = G[u][i]; if(sccno[u] != sccno[v]) out[sccno[u]] = in[sccno[v]] = 0; &#125; &#125; int cnt1 = 0, cnt2 = 0; for(int i = 1; i &lt;= scc_cnt; ++i)&#123; if(in[i]) cnt1++; if(out[i]) cnt2++; &#125; int ans = max(cnt1, cnt2); if(scc_cnt == 1) ans = 0; printf(\"%d\\n\", ans); &#125; return 0;&#125; 另一种思路首先对于如下的图我们我们肯定可以在$max \\{a, b \\}$a条边内构造出一个SCC，那么我们用递归的思想将其转化为这样的形式即可。其实这种思路我并没有完全理解，我再想一下，还是太蒻（；´д｀）ゞ","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"强连通分量","slug":"强连通分量","permalink":"http://yoursite.com/tags/强连通分量/"}]},{"title":"UVa 1391 - Astronauts","slug":"UVa-1391-Astronauts","date":"2017-05-28T02:58:39.000Z","updated":"2017-05-28T04:30:24.191Z","comments":true,"path":"2017/05/28/UVa-1391-Astronauts/","link":"","permalink":"http://yoursite.com/2017/05/28/UVa-1391-Astronauts/","excerpt":"题目地址 描述有$A, B, C$三种任务要分给n个宇航员，其中每个宇航员恰好分到一个任务。设$n(1 \\leq n \\leq 100000)$个宇航员的平均年龄为$x$，只有年龄大于等于$x$的宇航员才能分配任务$A$；只有年龄严格小于$x$的宇航员才能分到任务$B$，而任务$C$没有限制。有$m(1 \\leq m \\leq 100000)$对宇航员相互讨厌，因此不能分配到同一任务。找出满足上述所有要求的方案。 分析这道题目和之前的见图有些不一样，因为$true$和$false$对于每一个点的意义都不一样，但是不变的是每一个变量（宇航员）只有两个选择。用布尔变量$X_{i}$表示第$i$个宇航员的的分配方案。 对于年轻的宇航员，即年老的宇航员，要么做任务$B(X_{i} = true)$，要么做任务$C(X_{i} = false)$。 对于年龄大于等于平均年龄的宇航员，要么做任务$A(X_{i} = true)$，要么做任务$C(X_{i} = false)$。","text":"题目地址 描述有$A, B, C$三种任务要分给n个宇航员，其中每个宇航员恰好分到一个任务。设$n(1 \\leq n \\leq 100000)$个宇航员的平均年龄为$x$，只有年龄大于等于$x$的宇航员才能分配任务$A$；只有年龄严格小于$x$的宇航员才能分到任务$B$，而任务$C$没有限制。有$m(1 \\leq m \\leq 100000)$对宇航员相互讨厌，因此不能分配到同一任务。找出满足上述所有要求的方案。 分析这道题目和之前的见图有些不一样，因为$true$和$false$对于每一个点的意义都不一样，但是不变的是每一个变量（宇航员）只有两个选择。用布尔变量$X_{i}$表示第$i$个宇航员的的分配方案。 对于年轻的宇航员，即年老的宇航员，要么做任务$B(X_{i} = true)$，要么做任务$C(X_{i} = false)$。 对于年龄大于等于平均年龄的宇航员，要么做任务$A(X_{i} = true)$，要么做任务$C(X_{i} = false)$。 现在考虑一对相互讨厌的宇航员$i, j$， 如果他们同属于年轻或年老，那么$X_{i}, X_{j}$必须不相同，这里用一个或语句表示不清要用两个。 第一个或语句用合取范式来表示就是$X_{i} \\vee X_{j}$，意思是两者至少有一个为$true$。即一对相互讨厌的宇航员，不管这一对是年轻的宇航员还是年老的宇航员都不能同时分派到任务$C$，所以加边$addClause(a, 1, b, 1)$。 第二个约束条件用合取范式来表示就是$\\neg X_{i} \\vee \\neg X_{j}$，意思是两者至少有一个为$false$。即一对相互讨厌的年轻宇航员不能同时分派到任务$B$，所以加边$addClause(a, 0, b, 0)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//UVa 1391 - Astronauts//2017/5/25 13:47//2-SAT#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100000 + 3;const int MAX_M = 100000 + 3;const int INF = 0x3f3f3f3f;int n, m;vector&lt;int&gt; G[MAX_N &lt;&lt; 1];int S[MAX_N &lt;&lt; 1], c;bool mark[MAX_N &lt;&lt; 1];int totalAge, age[MAX_N];namespace TwoSAT&#123; void init(int n)&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); ++i) G[i].clear(); memset(mark, 0, sizeof mark); &#125; void addClause(int x, int xval, int y, int yval)&#123; x = (x &lt;&lt; 1) + xval; y = (y &lt;&lt; 1) + yval; G[x^1].push_back(y); G[y^1].push_back(x); &#125; bool dfs(int x)&#123; if(mark[x^1]) return false; if(mark[x]) return true; mark[x] = true; S[c++] = x; for(int i = 0; i &lt; G[x].size(); ++i) if(!dfs(G[x][i])) return false; return true; &#125; bool solve()&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); i += 2)&#123; if(!mark[i] &amp;&amp; !mark[i + 1])&#123; c = 0; if(!dfs(i))&#123; while(c &gt; 0) mark[S[--c]] = false; if(!dfs(i + 1)) return false; &#125; &#125; &#125; return true; &#125;&#125;using namespace TwoSAT;bool check(int x)&#123; return age[x] * n &lt; totalAge ? 1 : 0;&#125;int main()&#123;#ifndef DEBUG freopen(\"test.in\", \"r\", stdin);#endif while(scanf(\"%d%d\", &amp;n, &amp;m) == 2 &amp;&amp; n &amp;&amp; m)&#123; init(n); totalAge = 0; memset(age, 0, sizeof age); //printf(\"%d %d\\n\", n, m); for(int i = 0; i &lt; n; ++i)&#123; age[i] = readIn(); totalAge += age[i]; &#125; //printf(\"%d\\n\", totalAge); for(int i = 0; i &lt; m; ++i)&#123; int u = readIn(), v = readIn(); //printf(\"%d %d\\n\", u, v); u--; v--; if(u == v) continue; addClause(u, 1, v, 1); if(check(u) == check(v)) addClause(u, 0, v, 0); &#125; if(!solve()) printf(\"No solution.\"); else&#123; for(int i = 0; i &lt; n; ++i)&#123; if(mark[i &lt;&lt; 1]) printf(\"C\\n\");// x[i]=false，去任务C else if(check(i)) printf(\"B\\n\");// x[i]=true的年轻宇航员去任务B else printf(\"A\\n\");// x[i]=true的年轻宇航员去任务A &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://yoursite.com/tags/2-SAT/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"}]},{"title":"UVa 1146 - Now or later","slug":"UVa-1146-Now-or-later","date":"2017-05-26T15:35:26.000Z","updated":"2017-05-28T04:31:02.353Z","comments":true,"path":"2017/05/26/UVa-1146-Now-or-later/","link":"","permalink":"http://yoursite.com/2017/05/26/UVa-1146-Now-or-later/","excerpt":"题目地址 描述$n$($n \\leq 2000$)班飞机，每个飞机有一个早到时间和一个晚到时间，问怎么安排飞机，使得飞机到的间隔的最小值最大？ 分析最小化最大值，首先想到的是二分。 这里回顾一下二分法。我习惯是遵循一闭一开原则维护答案，假设下标为$0, 1, 2, ···, n - 1$，如果要求最大化答案，那么维护区间$[l, r)$；如果要求最小化答案，那么维护区间$(l, r]$。12345while(r - l &gt; 1)&#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) l = mid; else r = mid;&#125;","text":"题目地址 描述$n$($n \\leq 2000$)班飞机，每个飞机有一个早到时间和一个晚到时间，问怎么安排飞机，使得飞机到的间隔的最小值最大？ 分析最小化最大值，首先想到的是二分。 这里回顾一下二分法。我习惯是遵循一闭一开原则维护答案，假设下标为$0, 1, 2, ···, n - 1$，如果要求最大化答案，那么维护区间$[l, r)$；如果要求最小化答案，那么维护区间$(l, r]$。12345while(r - l &gt; 1)&#123; int mid = (l + r) &gt;&gt; 1; if(check(mid)) l = mid; else r = mid;&#125; 这道题目我们二分时间间隔，每一个飞机为一个变量，而早到和晚到的时间为一个集合中不能共存的两个元素。$false$表示早到，$true$表示晚到。枚举每一个飞机之间的情况，存在冲突则添加条件使其不能一起选择，最后判断是否矛盾即可。 每一个飞机之间的情况有四种： A飞机早到，B飞机早到； A飞机早到，B飞机晚到； A飞机晚到，B飞机早到； A飞机晚到，B飞机晚到； 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//UVa 1146 - Now or later//2017/5/34 16:57//2-SAT + 二分(最大化最小值)#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ago;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 2000 + 3;const int INF = 1e7 + 3;int n;vector&lt;int&gt; G[MAX_N &lt;&lt; 1];int S[MAX_N &lt;&lt; 1], c;bool mark[MAX_N &lt;&lt; 1];int T[MAX_N &lt;&lt; 1][3];namespace TwoSAT&#123; void init(int n)&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); ++i) G[i].clear(); memset(mark, false, sizeof mark); &#125; void addClause(int x, int xval, int y, int yval)&#123; x = (x &lt;&lt; 1) + xval; y = (y &lt;&lt; 1) + yval; G[x^1].push_back(y);// G[y^1].push_back(x); &#125; bool dfs(int x)&#123; if(mark[x^1]) return false; if(mark[x]) return true; mark[x] = true; S[c++] = x; for(int i = 0; i &lt; G[x].size(); ++i) if(!dfs(G[x][i])) return false; return true; &#125; bool solve()&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); i += 2)&#123; if(!mark[i] &amp;&amp; !mark[i + 1])&#123; c = 0; if(!dfs(i))&#123; while(c &gt; 0) mark[S[--c]] = false; if(!dfs(i + 1)) return false; &#125; &#125; &#125; return true; &#125;&#125;using namespace TwoSAT;bool check(int diff)&#123; init(n); for(int i = 0; i &lt; n; ++i) for(int a = 0; a &lt; 2; ++a) for(int j = i + 1; j &lt; n; ++j) for(int b = 0; b &lt; 2; ++b) if(abs(T[i][a] - T[j][b]) &lt; diff) addClause(i, a ^ 1, j, b ^ 1);// return solve();&#125;int main()&#123;#ifndef DEBUG freopen(\"test.in\", \"r\", stdin);#endif while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n)&#123; for(int i = 0; i &lt; n; ++i)&#123; for(int j = 0; j &lt; 2; ++j)&#123; T[i][j] = readIn(); &#125; &#125; int l = -1, r = INF; /*也是一种二分的办法 while(l &lt; r)&#123; int mid = l + (r - l + 1) / 2; if(check(mid)) l = mid; else r = mid - 1; &#125; */ while(r - l &gt; 1)&#123; int mid = (r + l) / 2; //printf(\"%d \", mid); if(check(mid)) l = mid; //return 0; else r = mid; &#125; printf(\"%d\\n\", l); &#125; return 0;&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://yoursite.com/tags/2-SAT/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"}]},{"title":"POJ 3678 Katu Puzzle","slug":"POJ-3678-Katu-Puzzle","date":"2017-05-25T01:36:26.000Z","updated":"2017-05-28T04:33:00.136Z","comments":true,"path":"2017/05/25/POJ-3678-Katu-Puzzle/","link":"","permalink":"http://yoursite.com/2017/05/25/POJ-3678-Katu-Puzzle/","excerpt":"题目地址 描述有$n$($n \\leq 1000$)个变量和$m$($m \\leq 1000000$)个式子，给出一些条件 （‘AND’，‘OR’，‘XOR’）以及值，问能否对这些变量赋值，使得条件全部满足。满足输出 YES，否则输出 NO。$m$个式子中包含有向边$e(a, b)$，操作$opt$以及结果$c(0\\leq c\\leq 1)$，每一个顶点$V_{i}$存在一个$X_{i}$使得式子$X_{a} \\ opt \\ X_{b} = c$成立。 And 0 1 Or 0 1 Xor 0 1 0 0 0 0 0 1 0 0 1 1 0 1 1 1 1 1 1 0","text":"题目地址 描述有$n$($n \\leq 1000$)个变量和$m$($m \\leq 1000000$)个式子，给出一些条件 （‘AND’，‘OR’，‘XOR’）以及值，问能否对这些变量赋值，使得条件全部满足。满足输出 YES，否则输出 NO。$m$个式子中包含有向边$e(a, b)$，操作$opt$以及结果$c(0\\leq c\\leq 1)$，每一个顶点$V_{i}$存在一个$X_{i}$使得式子$X_{a} \\ opt \\ X_{b} = c$成立。 And 0 1 Or 0 1 Xor 0 1 0 0 0 0 0 1 0 0 1 1 0 1 1 1 1 1 1 0 分析 首先对于And操作： 当$c = 0$ 时，若$a = 0$，则$b = 1 \\parallel b = 0 $，因为$a，b$之间的关系不是确定的所以不连边；$a = 1$时$b = 0$，$a$与$b$之间关系是确定的所以连$a\\rightarrow \\neg b$；同理$b = 1$时$a = 0$，所以连边$\\neg b\\rightarrow a$；表示出来就是$addClause(a, 0, b, 0)$。 当$c = 1$ 时，$a, b$必须满足$a = 1 且 b = 1$，所以加入边$\\neg a \\rightarrow a \\ \\wedge \\neg b \\rightarrow b$，转换成为$addClause$操作就是$addClause(a, 1, b, 1),\\ \\ \\ addClause(a, 1, b, 0), \\ \\ \\ addClause(a, 0, b, 1)$。$addClause(a, 1, b, 0), \\ \\ \\ addClause(a, 0, b, 1)$操作表示$a = b$这个关系，而加上$addClause(a, 1, b, 1)$操作表示则表示$a = b = 1$。 对于Or操作其实与And操作是一样的： 当$c = 0$ 时，$a, b$必须满足$a = 0 且 b = 0$，所以加入边$a \\rightarrow \\neg a \\wedge b \\rightarrow \\neg b$，表示出来就是转换成为$addClause$操作就是$addClause(a, 0, b, 0),\\ \\ \\ addClause(a, 1, b, 0), \\ \\ \\ addClause(a, 0, b, 1)$。 当$c = 1$ 时，$a, b$满足不能同时为$0$，表示为$addClause(a, 1, b, 1)$。 而Xor操作稍微有一些不同： 当$c = 0$ 时，$a, b$必须满足$a = b$，所以加入边$addClause(a, 0, b, 1), \\ \\ \\ addClause(a, 1, b, 0)$。 当$c = 1$ 时，$a, b$必须满足$a\\neq b$，所以加入边$addClause(a, 1, b, 1), \\ \\ \\ addClause(a, 0, b, 0)$。 如果还不理解的话就自己模拟一下就可以了。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//POJ 3678 Katu Puzzle//2017/5/22 16:50//2-SAT#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 1000 + 3;const int MAX_M = 1000000 + 3;const int INF = 0x3f3f3f3f;int n, m;vector&lt;int&gt; G[MAX_M &lt;&lt; 1];int S[MAX_M &lt;&lt; 1], c;bool mark[MAX_M &lt;&lt; 1];namespace TwoSAT&#123; void init(int n)&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); ++i) G[i].clear(); memset(mark, 0, sizeof mark); &#125; void addClause(int x, int xval, int y, int yval)&#123; x = (x &lt;&lt; 1) + xval; y = (y &lt;&lt; 1) + yval; G[x^1].push_back(y); G[y^1].push_back(x); &#125; bool dfs(int x)&#123; if(mark[x^1]) return false; if(mark[x]) return true; mark[x] = true; S[c++] = x; for(int i = 0; i &lt; G[x].size(); ++i) if(!dfs(G[x][i])) return false; return true; &#125; bool solve()&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); i += 2)&#123; if(!mark[i] &amp;&amp; !mark[i + 1])&#123; c = 0; if(!dfs(i))&#123; while(c &gt; 0) mark[S[--c]] = false; if(!dfs(i + 1)) return false; &#125; &#125; &#125; return true; &#125;&#125;using namespace TwoSAT;int main()&#123;#ifndef DEBUG freopen(\"test.in\", \"r\", stdin);#endif n = readIn(), m = readIn(); init(n); for(int i = 0; i &lt; m; ++i)&#123; int a, b, c; char opt[10]; a = readIn(), b = readIn(), c = readIn(), scanf(\"%s\", opt); //printf(\"%d %d %d %s\\n\", a, b, c,opt); if(opt[0] == 'A')&#123; if(c == 1)&#123; addClause(a, 1, b, 0); addClause(a, 0, b, 1); addClause(a, 1, b, 1); &#125; else addClause(a, 0, b, 0); &#125; else if(opt[0] == 'O')&#123; if(c == 0)&#123; addClause(a, 0, b, 0); addClause(a, 1, b, 0); addClause(a, 0, b, 1); &#125; else addClause(a, 1, b, 1); &#125; else if(opt[0] == 'X')&#123; if(c == 1)&#123; addClause(a, 0, b, 0); addClause(a, 1, b, 1); &#125; else&#123; addClause(a, 0, b, 1); addClause(a, 1, b, 0); &#125; &#125; &#125; if(solve()) printf(\"YES\\n\"); else printf(\"NO\\n\"); return 0;&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://yoursite.com/tags/2-SAT/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"位运算","slug":"位运算","permalink":"http://yoursite.com/tags/位运算/"},{"name":"POJ","slug":"POJ","permalink":"http://yoursite.com/tags/POJ/"}]},{"title":"2-SAT 问题","slug":"2-SAT问题","date":"2017-05-24T16:21:22.000Z","updated":"2017-06-04T09:07:55.405Z","comments":true,"path":"2017/05/25/2-SAT问题/","link":"","permalink":"http://yoursite.com/2017/05/25/2-SAT问题/","excerpt":"定义现有$n$个布尔变量 $x_{i}$，给出一些限制关系，比如$x_{1}$为真或者$x_{2}$为假、$x_{3}$为真或者$x_{4}$为真等（注意这里的‘或’是指至少有一个条件成立），2-SAT问题是要确定$n$个布尔变量的值，使得其满足所有限制关系。特别的，若每种限制关系中最多只对两个元素进行限制，则称为2-SAT问题。我们这里讨论$2-SAT$问题。n-SAT问题在$(n &gt; 2)$目前是没有多项式时间内的算法，是NP问题。通常我们都利用合取范式来抽象的描述我们需要求解的布尔方程。如$(a\\vee \\neg b) \\wedge (b \\vee c) \\wedge (\\neg c \\vee \\neg a)$。 其中$\\vee$为析取，即$(a \\parallel b)$只要$a, b$中满足任意一个值为真即可 $\\wedge$为合取， 即$(a \\ \\&amp;\\&amp; \\ b)$只要$a, b$均为真则成立 $\\neg$简单来说就相当于取反 所以这个合取范式当$a$和$b$为真而$c$为假的时候成立。","text":"定义现有$n$个布尔变量 $x_{i}$，给出一些限制关系，比如$x_{1}$为真或者$x_{2}$为假、$x_{3}$为真或者$x_{4}$为真等（注意这里的‘或’是指至少有一个条件成立），2-SAT问题是要确定$n$个布尔变量的值，使得其满足所有限制关系。特别的，若每种限制关系中最多只对两个元素进行限制，则称为2-SAT问题。我们这里讨论$2-SAT$问题。n-SAT问题在$(n &gt; 2)$目前是没有多项式时间内的算法，是NP问题。通常我们都利用合取范式来抽象的描述我们需要求解的布尔方程。如$(a\\vee \\neg b) \\wedge (b \\vee c) \\wedge (\\neg c \\vee \\neg a)$。 其中$\\vee$为析取，即$(a \\parallel b)$只要$a, b$中满足任意一个值为真即可 $\\wedge$为合取， 即$(a \\ \\&amp;\\&amp; \\ b)$只要$a, b$均为真则成立 $\\neg$简单来说就相当于取反 所以这个合取范式当$a$和$b$为真而$c$为假的时候成立。当只有少量合取表达式的时候我们可以手算，当存在很多个合取表达式的时候我们就要尝试用程序和思维来帮助我们实现。 解法2-SAT问题难在建模，所以一般来说不会在时间上卡你，故用一种较为简洁，较好理解的方法就可以了，不需要那么麻烦。首先最重要的一定要记住2-SAT 问题添加的条件只能是 ‘或’ ，即两个之中有一个成立即可，但我们可以通过添加多条‘或’语句，来表示其他逻辑关系。因此我们先由如何建模开始，首先我们要建立一个图首先要定义图中的点和边。图中的点一般而言都是题目中的集合中的两个不能共存的元素，比如飞机降落时早降的时间和晚降的时间、位运算中$a \\bigoplus b = c$中的$a, b$；而图中的边一般为有向边表示只要满足条件1则一定可以满足条件2。 现在我们就要对于实际问题来建立图中的点和边。 构造一张有向图G，其中每一个变量$X_{i}$拆成两个结点$2i$和$2i + 1$，分别表示$X_{i}$为假和$X_{i}$为真。最后要为每一个变量选择其中一个结点标记，若标记结点$2i$表示$X_{i}$为假，反之若标记结点$2i + 1$表示$X_{i}$为真。 对于“$X_{i}$为假或$X_{j}$假”这样的条件用合取范式来表示就是$\\neg X_{i}\\vee \\neg X_{j}$，我们将限制条件拆分成为如果A成立那么B成立来表示就是$X_{i} \\Rightarrow \\neg X_{j} \\wedge X_{j} \\Rightarrow \\neg X_{i}$，所以这里连边$X_{i} \\rightarrow \\neg X_{j}$和$X_{j} \\rightarrow \\neg X_{i}$，用刘汝佳的建图方式就表示为$addClause(a, 0, b, 0)$，表示如果$X_{i}$为真那么$X_{j}$必须为假条件才成立，同理$X_{j}$为真那么$X_{i}$必须为假条件才成立。这条有向边相当于推导出的意思，对于其他的情况我们也可以类似连边。换句话说，每一个体检对应两条对称的边。 接下来注意考虑每个没有赋值的变量，设为$X_{i}$。我们先假定它为假，然后标记结点$2i$，并且沿这条有向边标记所有能标记的结点。如果标记过程中发现某个变量对应的两个结点都被标记，则$X_{i}$为假这个条件不成立，需要改成$X_{i}$为真，然后重新标记。注意，这里改为$X_{i}$为真继续尝试，并不是代表回溯的过程，而是打了标记的点重新设为没有被标记，如果回溯的话，时间复杂度爆炸。如果当前考虑的变量赋值不管为真还是为假都会引发矛盾，那么可以证明整个2-SAT问题无解。 拓展 - 条件 对应语句 1 $a = b$ $addClause(a, 1, b, 0);\\ \\ \\ \\ addClause(a, 0, b, 1);$ 2 $a \\neq b$ $addClause(a, 0, b, 0); \\ \\ \\ addClause(a, 1, b, 1);$ 3 $a = b = true$ $addClause(a, 1, b, 1); \\ \\ addClause(a, 0, b, 1); \\ \\ \\ addClause(a, 1, b, 0);$ 4 $a = b = false$ $addClause(a, 0, b, 0); \\ \\ addClause(a, 1, b, 0); \\ \\ addClause(a, 0, b, 1);$ $a \\neq b$等价于$a \\ \\ xor \\ \\ b = true$，同理$a = b$等价于$a \\ \\ xor \\ \\ b = false$。 模板（代码）1234567891011121314151617181920212223242526272829303132333435363738394041namespace TwoSAT&#123; vector&lt;int&gt; G[MAX_N &lt;&lt; 1];//节点数为 2 * n int S[MAX_N &lt;&lt; 1], c;//S为栈，用于反悔。c 为栈大小 bool mark[MAX_N &lt;&lt; 1];//表示是否选中 void init(int n)&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); ++i) G[i].clear(); memset(mark, 0, sizeof mark); &#125; //x == xval || y == yval void addClause(int x, int xval, int y, int yval)&#123; x = (x &lt;&lt; 1) + xval; y = (y &lt;&lt; 1) + yval; G[x^1].push_back(y); G[y^1].push_back(x); &#125; bool dfs(int x)&#123; if(mark[x^1]) return false;//如果另一个节点已经被选，那么不能成立！ if(mark[x]) return true; S[c++] = x;//入栈 mark[x] = true;//选中 for(int i = 0; i &lt; G[x].size(); ++i) if(!dfs(G[x][i])) return false;//从当前点出发，沿着有向边标记所有能标记的节点 return true; &#125; bool solve()&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); i += 2)&#123; if(!mark[i] &amp;&amp; !mark[i + 1])&#123;//找到还没被标记的变量 c = 0;//栈清空 if(!dfs(i))&#123;//如果尝试 false 不行，反悔到之前的情况，尝试 true while(c &gt; 0) mark[S[--c]] = false;//退栈，反悔 if(!dfs(i + 1)) return false; &#125; &#125; &#125; return true; &#125;&#125;using namespace TwoSAT; 例题POJ 3678 Katu Puzzle题目地址运用扩展中的内容如果不理解扩展中由条件到加边是如何过来的的一看一下，毕竟当时我是绕了好久才绕过来的，这道题是2-SAT模板题，可以用来练简单的建模。POJ 3678 Katu Puzzle解题报告 POJ 3207 - Ikki’s Story IV - Panda’s Trick题目地址 和Sengxian学长讲的一样，题义明白了，那么看图就可以懂了，若会相交，则一定是是在圆内或者圆外相交，若一条线在圆内一条线在圆外这种情况下不会相交。那么圆内表示为0，圆外表示为1；如果一条线在圆外，另一条线一定在圆内，反之亦然。 UVa 1146 - Now or laterUVa 1146 - Now or later解题报告 UVa 1391 - AstronautsUVa 1391 - Astronauts解题报告未待续完","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://yoursite.com/tags/2-SAT/"},{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"}]},{"title":"BZOJ 1823: [JSOI2010]满汉全席","slug":"BZOJ-1823-JSOI2010-满汉全席","date":"2017-05-24T11:30:51.000Z","updated":"2017-05-28T04:33:10.963Z","comments":true,"path":"2017/05/24/BZOJ-1823-JSOI2010-满汉全席/","link":"","permalink":"http://yoursite.com/2017/05/24/BZOJ-1823-JSOI2010-满汉全席/","excerpt":"题目地址 描述满汉全席是中国最丰盛的宴客菜肴，有许多种不同的材料透过满族或是汉族的料理方式，呈现数量繁多的菜色之中。由于菜色众多而繁杂，只有极少数博学多闻技艺高超的厨师能够做出满汉全席，而能够烹饪出经过专家认证的满汉全席，也是中国厨师最大的荣誉之一。 世界满汉全席协会是由能够做出满汉全席的专家厨师们所组成，而他们之间还细分为许多不同等级的厨师。为了招收新进的厨师进入世界满汉全席协会，将于近日举办满汉全席大赛，协会派遣许多会员当作评审员，为的就是要在参赛的厨师之中，找到满汉料理界的明日之星。大会的规则如下：每位参赛的选手可以得到$n$种材料，选手可以自由选择用满式或是汉式料理将材料当成菜肴。大会的评审制度是：共有$m$位评审员分别把关。每一位评审员对于满汉全席有各自独特的见解，但基本见解是，要有两样菜色作为满汉全席的标志。如某评审认为，如果没有汉式东坡肉跟满式的涮羊肉锅，就不能算是满汉全席。但避免过于有主见的审核，大会规定一个评审员除非是在认为必备的两样菜色都没有做出来的状况下，才能淘汰一位选手，否则不能淘汰一位参赛者。换句话说，只要参赛者能在这两种材料的做法中，其中一个符合评审的喜好即可通过该评审的审查。","text":"题目地址 描述满汉全席是中国最丰盛的宴客菜肴，有许多种不同的材料透过满族或是汉族的料理方式，呈现数量繁多的菜色之中。由于菜色众多而繁杂，只有极少数博学多闻技艺高超的厨师能够做出满汉全席，而能够烹饪出经过专家认证的满汉全席，也是中国厨师最大的荣誉之一。 世界满汉全席协会是由能够做出满汉全席的专家厨师们所组成，而他们之间还细分为许多不同等级的厨师。为了招收新进的厨师进入世界满汉全席协会，将于近日举办满汉全席大赛，协会派遣许多会员当作评审员，为的就是要在参赛的厨师之中，找到满汉料理界的明日之星。大会的规则如下：每位参赛的选手可以得到$n$种材料，选手可以自由选择用满式或是汉式料理将材料当成菜肴。大会的评审制度是：共有$m$位评审员分别把关。每一位评审员对于满汉全席有各自独特的见解，但基本见解是，要有两样菜色作为满汉全席的标志。如某评审认为，如果没有汉式东坡肉跟满式的涮羊肉锅，就不能算是满汉全席。但避免过于有主见的审核，大会规定一个评审员除非是在认为必备的两样菜色都没有做出来的状况下，才能淘汰一位选手，否则不能淘汰一位参赛者。换句话说，只要参赛者能在这两种材料的做法中，其中一个符合评审的喜好即可通过该评审的审查。如材料有猪肉，羊肉和牛肉时，有四位评审员的喜好如下表： - 评审一 评审二 评审三 评审四 1 满式牛肉 满式猪肉 汉式牛肉 汉式牛肉 2 汉式猪肉 满式羊肉 汉式猪肉 满式羊肉 如参赛者甲做出满式猪肉，满式羊肉和满式牛肉料理，他将无法满足评审三的要求，无法通过评审。而参赛者乙做出汉式猪肉，满式羊肉和满式牛肉料理，就可以满 足所有评审的要求。 但大会后来发现，在这样的制度下如果材料选择跟派出的评审员没有特别安排好的话，所有的参赛者最多只能通过部分评审员的审查而不是全部，所以可能会发生没有人通过考核的情形。如有四个评审员喜好如下表时，则不论参赛者采取什么样的做法，都不可能通过所有评审的考核： - 评审一 评审二 评审三 评审四 1 满式羊肉 满式猪肉 汉式羊肉 汉式羊肉 2 汉式猪肉 满式羊肉 汉式猪肉 汉式猪肉 所以大会希望有人能写一个程序来判断，所选出的$m$位评审，会不会发生 没有人能通过考核的窘境，以便协会组织合适的评审团。 分析题面很长，但是仔细分析以后可以提炼出来一下几点： 对于每一种材料只能选择一种料理方式；选了满式就不能选汉式，选了汉式就不能选满式。 对于每一个评委的要求满足其中一个即可，可表示为$x == xval || y == yval$， 如果$x$如果不能满足评委，那么就必须让$y$满足评委；同理，如果$y$如果不能满足评委，那么就必须让$x$满足评委。 那么分类讨论： 存在$m_{a}$和$h_{b}$，如果存在$m_{a}$不满足评委，那么一定让$h_{b}$满足评委，转换一下就是如果存在$h_{a}$就一定存在$h_{b}$；如果存在$m_{b}$则一定存在$m_{a}$。 存在$h_{a}$和$h_{b}$，如果存在$m_{a}$就一定存在$h_{b}$；如果存在$m_{b}$则一定存在$h_{a}$。 存在$m_{a}$和$m_{b}$，如果存在$h_{a}$就一定存在$m_{b}$；如果存在$h_{b}$则一定存在$m_{a}$。 存在$h_{a}$和$m_{b}$，如果存在$m_{a}$就一定存在$m_{b}$；如果存在$h_{b}$则一定存在$h_{a}$。 根据$2-SAT$的定义，我们用一条有向边$i\\rightarrow j$来表示选$i$的情况下，一定要选$j$，然后我们根据分类讨论出来的情况连边就可以了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//BZOJ 1823: [JSOI2010]满汉全席//2017/5/23 16:09//2-SAT#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX_N = 100 + 3;const int MAX_M = 10000 + 3;const int INF = 0x3f3f3f3f;int testCase;int n, m;vector&lt;int&gt; G[MAX_M &lt;&lt; 1];int S[MAX_M], c;int mark[MAX_M &lt;&lt; 1];char str1[MAX_M], str2[MAX_M];namespace TwoSAT&#123; void init(int n)&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); ++i) G[i].clear(); memset(mark, 0, sizeof mark); &#125; void addClause(int x, int xval, int y, int yval)&#123; x = (x &lt;&lt; 1) + xval; y = (y &lt;&lt; 1) + yval; G[x^1].push_back(y); G[y^1].push_back(x); &#125; bool dfs(int x)&#123; if(mark[x^1]) return false; if(mark[x]) return true; mark[x] = true; S[c++] = x; for(unsigned int i = 0; i &lt; G[x].size(); ++i) if(!dfs(G[x][i])) return false; return true; &#125; bool solve()&#123; for(int i = 0; i &lt; (n &lt;&lt; 1); i += 2)&#123; if(!mark[i] &amp;&amp; !mark[i + 1])&#123; c = 0; if(!dfs(i))&#123; while(c &gt; 0) mark[S[--c]] = false; if(!dfs(i + 1)) return false; &#125; &#125; &#125; return true; &#125;&#125;using namespace TwoSAT;int main()&#123;#ifndef DEBUG freopen(\"test.in\", \"r\", stdin);#endif testCase = readIn(); while(testCase--)&#123; n = readIn(), m = readIn(); init(n); for(int i = 0; i &lt; n; ++i)&#123; addClause(i, 1, i, 0); addClause(i, 0, i ,1); &#125; for(int i = 1; i &lt;= m; ++i)&#123; scanf(\"%s%s\", str1, str2); //printf(\"%s %s\\n\", str1, str2); int x, y; sscanf(str1 + 1, \"%d\", &amp;x); sscanf(str2 + 1, \"%d\", &amp;y); x--; y--; //printf(\"%d %d\\n\", x, y); if(str1[0] == 'h' &amp;&amp; str2[0] == 'h') addClause(x, 1, y, 1); else if(str1[0] == 'h' &amp;&amp; str2[0] == 'm') addClause(x, 1, y, 0); else if(str1[0] == 'm' &amp;&amp; str2[0] == 'h') addClause(x, 0, y, 1); else addClause(x, 0, y, 0); &#125; if(solve()) printf(\"GOOD\\n\"); else printf(\"BAD\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://yoursite.com/tags/2-SAT/"},{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"}]},{"title":"WHEZOJ 83 - 棋子","slug":"WHEZOJ-83-棋子","date":"2017-05-23T16:56:40.000Z","updated":"2017-06-29T02:55:44.567Z","comments":true,"path":"2017/05/24/WHEZOJ-83-棋子/","link":"","permalink":"http://yoursite.com/2017/05/24/WHEZOJ-83-棋子/","excerpt":"描述$n$个有一面是黑色的棋子排成一排， 从$1$到$n$编号， 一开始有的棋子黑色面朝上，有的朝下。 接下来第$1$秒， 把所有编号为$1$的倍数的棋子翻转； 第$2$秒， 把所有编号为$2$的倍数的棋子翻转； 第$3$秒， 把所有编号为$3$的倍数的棋子翻转…… 这样的操作一直持续了$n$秒。现在想知道$n$秒后一共有多少个棋子是黑色朝上。第一行输入一个整数$n$，表示棋子的数量。第二行输入$3$个整数$a_1,p,q$，对于$2\\leq i\\leq n$，$a_{i} = ((a_{i - 1} \\times p + q) \\ mod\\ (10^{9} + 7)) mod \\ 2$。表示若$a_{i}$为$1$，表示最开始第$i$个棋子黑色面朝上，为$0$则表示朝下。","text":"描述$n$个有一面是黑色的棋子排成一排， 从$1$到$n$编号， 一开始有的棋子黑色面朝上，有的朝下。 接下来第$1$秒， 把所有编号为$1$的倍数的棋子翻转； 第$2$秒， 把所有编号为$2$的倍数的棋子翻转； 第$3$秒， 把所有编号为$3$的倍数的棋子翻转…… 这样的操作一直持续了$n$秒。现在想知道$n$秒后一共有多少个棋子是黑色朝上。第一行输入一个整数$n$，表示棋子的数量。第二行输入$3$个整数$a_1,p,q$，对于$2\\leq i\\leq n$，$a_{i} = ((a_{i - 1} \\times p + q) \\ mod\\ (10^{9} + 7)) mod \\ 2$。表示若$a_{i}$为$1$，表示最开始第$i$个棋子黑色面朝上，为$0$则表示朝下。 分析子任务$3$一看就很好过呀，找了半天规律，无奈智商太低，没找出来就先打了一个$30$分的暴力。其实正解应该也不难想，还是自己太弱。正解其实就是在约数个数定理上稍微变通了一下。只有在秒数为棋子编号的约数的时候，棋子才会被翻。如果棋子原本只黑色的面朝上，那么翻偶数次之后仍然是黑色面朝上，翻奇数次后就会是白色的面朝上。所以我么现在只需要判断棋子的编号的约数个数是偶数还是奇数就可以了。假设我们现在有一颗棋子编号为$n$，我们得出正整数$n$的唯一分解式$n =p_{1}^{a^{1}}p_{2}^{a_{2}}p_{3}^{a_{3}}\\cdots p_{k}^{a_{k}}$，现在可以计算出编号为$n$的棋子的约数个数为$\\prod_{i=1}^{k}(a_{i}+1)=(a_{1}+1)(a_{2}+1)\\cdots (a_{k}+1)$，而当且仅当$a_{i}(1 \\leq i \\leq k)$为偶数的时候约数的个数才会是奇数，即$n$为平方数的时候。所以我们的答案只需要关心： 第一个棋子是否白色朝上（因为第一个棋子有且仅会翻转一次）。 有什么棋子以开始是黑色朝上的。 如果棋子原本只黑色的面朝上，那么翻偶数次之后仍然是黑色面朝上，翻奇数次后就会是白色的面朝上，答案减去编号为平方数的。 如果棋子原本只白色的面朝上，那么翻偶数次之后仍然是白色面朝上，翻奇数次后就会是黑色的面朝上，答案加上编号为平方数的。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9') &#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int MAX = 10000000 + 3;const int MOD = 1000000000 + 7;;int n;LL a[MAX], p, q;//int ans = 0;int main()&#123; freopen(\"chess.in\",\"r\",stdin); freopen(\"chess.out\",\"w\",stdout); n = readIn(); scanf(\"%lld%lld%lld\", &amp;a[1], &amp;p, &amp;q); if(!a[1]) ans++;//only reverse once for(int i = 2; i &lt;= n; i++)&#123; a[i] = ((a[i - 1] * p + q) % MOD) &amp; 1; if(a[i]) ans++; &#125; for(int i = 2; i * i &lt;= n; i++)&#123; if(a[i * i]) ans--; else ans++; &#125; printf(\"%d\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"约数个数定理","slug":"约数个数定理","permalink":"http://yoursite.com/tags/约数个数定理/"}]},{"title":"[模板]高斯消元法","slug":"模板-高斯消元法","date":"2017-05-23T16:54:58.000Z","updated":"2017-05-23T16:56:09.801Z","comments":true,"path":"2017/05/24/模板-高斯消元法/","link":"","permalink":"http://yoursite.com/2017/05/24/模板-高斯消元法/","excerpt":"高斯消元法 (Gaussian Elimination)，是线性代数中的一个算法，可用来为线性方程组求解。","text":"高斯消元法 (Gaussian Elimination)，是线性代数中的一个算法，可用来为线性方程组求解。 推导假设现在有如下的方程组：现在把方程组写为矩阵形式为：然后我们我们可以对方程组进行3种操作而不改变方程组的解集： 交换两行。 把第i行乘以一个非$0$系数$k$。即对于$j=1\\cdots n$， 令$a_{ij} = k \\times a_{ij}, b_{i}=k \\times b_{i}$。 把第$p$行乘以一个非$0$系数$k$之后加在第$i$行上。即对于$j=1\\cdots n$， 令$a_{ij} = a_{ij} + k \\times a_{pj}, b_{i}=b_{i} + k \\times p_{i}$。 以上三个操作叫做初等行变换。我们可以使用它们，对矩阵中的$a_{ij}$进行加减乘除变换。如图所示是一个栗子： 实现的时候简单来说就是，从上到下依次处理每一行，处理完第$i$行后，让$A_{ii}$非$0$，而$A_{ji}$均为$0$，其中最后一个增广矩阵的系数部分是上三角阵。 方程的解的情况上面的过程，描述了一个美好的过程，不错，若有$n$个方程，$n$个未知数，要是我们每次都能选定一个未知数，且总有一个且之前未选过的方程使得这个未知数的系数不为 $0$，那么所有的方程就一定会变成仅包含一个未知数的形式。所以，每次都能选定一个未知数是方程有解的充分必要条件！但是有时候方程并不是那么美好，在解方程的过程中一样需要找出无解的情况并舍去。 情况一：存在矛盾方程假设现在有一个含有两个未知数的线性方程组：$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ a + 3b = 7 \\cdots \\cdots 方程1$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 2a + 6b = 10 \\cdots \\cdots 方程2$我们模拟高斯消元的过程先消去$a$，用方程$2$乘以$\\frac{1}{2}$减去方程$1$，得:$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ a + 3b = 7 \\cdots \\cdots 方程1$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 0a + 0b = -2 \\cdots \\cdots 方程2$$0x + 0y = -2$，这个方程显然是不成立的。所以我们得出结论：不难得出，存在矛盾方程当且仅当有一方程问未知数系数全为 0，但等号右边却不为 0。 存在自由变量关于自由变量学长是这么解释的高斯消元法。就是有重复的方程，即方程之间存在倍数关系，比如：$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ a + 3b = 5 \\cdots \\cdots 方程1$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 2a + 6b = 10 \\cdots \\cdots 方程2$按照高斯消元的过程执行之后，得到的：$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ a + 3b = 5 \\cdots \\cdots 方程1$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 0a + 0b = 0 \\cdots \\cdots 方程2$这样的方程组中有两个变量却只有一个方程，可见这个方程组在某些方面上相当于一个不定方程组了，这时我们说，自由变量有$1$个，因为确定任何一个变量，整个方程就解出来了。引申到矩阵上是当且仅当所有行的向量是线性无关的时候方程组才有解，线性无关指的是，一行向量不得由矩阵中的其他行向量通过加、减和数乘得到。 代码说实话，我不是很喜欢高斯-约旦消元法，所以我写的就是一般的消元法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;inline int readIn()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123;if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123;x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;const int max_n = 500 + 3;const int max_m = 1000 + 3;const double eps = 1e-6;//一般还是取1e-6或1e-7int n, m;typedef double Matrix[max_m][max_n];double b[max_m];int ans[max_n];int gauss(Matrix a, int n, int m)&#123; for(int i = 1; i &lt;= n; ++i)&#123; int idx = 0;//行的编号 for(int j = i; j &lt;= m; ++j) if(fabs(a[j][i]) &gt; fabs(a[idx][i])) idx = i; if(!idx) return 2;//无数解 swap(i, idx);//交换行的编号 //与第i + 1 ~ m行进行消元 for(int j = i + 1; j &lt;= m; ++j)&#123; double f = 1.0 * a[j][i] / a[i][i]; for(int k = 1; k &lt;= n; ++k) a[j][k] -= a[i][k] * f; b[j] -= b[i] * f; &#125; &#125; //未知数系数全为0，而常数项不为0；无解 for(int i = 1; i &lt;= m; ++i)&#123; bool flag = true; for(int j = 1; j &lt;= n; ++j) if(fabs(a[i][j]) &gt;= eps) flag = false; if(flag &amp;&amp; fabs(b[i]) &lt; eps) flag = false; if(flag) return 0; &#125; for(int i = n; i &gt;= 1; --i)&#123; for(int j = i+1; j &lt;= n; ++j)&#123; b[i] -= a[i][j] * ans[j]; a[i][j] = 0; &#125; ans[i] = b[i] / a[i][i] + 0.5; &#125; return 1;&#125;Matrix a;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif n = readIn(), m = readIn(); for(int i = 1; i &lt;= m; ++i)&#123; for(int j = 1; j &lt;= n; ++j) a[i][j] = readIn(); b[i] = readIn(); &#125; int flag = gauss(a, n, m); if(flag == 1) for(int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", ans[i]); else if(flag == 0) puts(\"No solutions\"); else puts(\"Many solutions\"); return 0;&#125;","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"高斯消元","slug":"高斯消元","permalink":"http://yoursite.com/tags/高斯消元/"}]},{"title":"UVa 11997 - K Small Sums","slug":"UVa-11997-K-Small-Sums","date":"2017-05-23T16:53:36.000Z","updated":"2017-05-28T04:32:38.688Z","comments":true,"path":"2017/05/24/UVa-11997-K-Small-Sums/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-11997-K-Small-Sums/","excerpt":"题目地址 描述有$k$个整数数组，各包含$k$个元素。在每一个数组中组一个元素加起来，可以得到$k^{k}$个和。求这些和中最小的$k$个值（重复的只算多次）。输入包含$k$组数据$(1 \\leq k \\leq 750)$，以下$k$行包含$k$个不大于$10^{6}$的正整数。输出$k$个最小和的值。","text":"题目地址 描述有$k$个整数数组，各包含$k$个元素。在每一个数组中组一个元素加起来，可以得到$k^{k}$个和。求这些和中最小的$k$个值（重复的只算多次）。输入包含$k$组数据$(1 \\leq k \\leq 750)$，以下$k$行包含$k$个不大于$10^{6}$的正整数。输出$k$个最小和的值。 分析还是从小规模的入手，考虑有两个有序序列$A, B$，$A, B$中各有$n$个元素，现在要求从序列$A, B$中各取一个数相加，求出所有的$n_{2}$的和中最小的$n$个。那么这个问题可以转化成为多路归并问题，这样就有$n$个有序表，这$n$个有序表一定满足：$表1：A_{1}+B_{1}\\leq A_{1}+B_{2}\\leq \\cdots \\leq A_{1}+B_{n}$$表2：A_{2}+B_{1}\\leq A_{2}+B_{2}\\leq \\cdots \\leq A_{2}+B_{n}$$表3：A_{3}+B_{1}\\leq A_{3}+B_{2}\\leq \\cdots \\leq A_{3}+B_{n}$$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\vdots$$表n：A_{n}+B_{1}\\leq A_{1}+B_{2}\\leq \\cdots \\leq A_{n}+B_{n}$这里第一列的$n$个和就是我们所求的所有的$n^{2}$的和中最小的$n$个。首先最小的一定是$A_{1}+B_{1}$ ，但问题求最小的$n$个和，那第二小的是谁呢？显然只可能存在于剩下的数列的第一个和以及数列一的第二个和中，我们可以知道，如果一个数列的前一个位置没有被选中，那么这个数列后面的数也不可能被选中。所以我们建立一个优先队列（最小堆），一开始 $push$ 进去所有数列的第一个数，如果某一个和出队，它一定是当前最小和。接着它所在的数列在它后面的一个和就要进队。第$i$次出队得到第$i$小的和，队列总是有$n$个和，复杂度$\\Theta (nlogn)$ 。这被称为多路归并问题。那么这个题目也就不难解决了，根据贪心思想，将表两两合并，就能得到最小的$n$个和。我们令表$a$中的元素形为$A_{a} + B_{b}$，$s = A_{a} + B_{b}$，这样可以用一个二元组$(s, b)$来表示一个元素，表$a$中的下一个元素是$(s’, b + 1)$，其中$s’ = A_{a} + B_{b + 1} = s - B_{b} + B_{b + 1}$。因此我们根本用不到a呀！其实就是把$k$个有序表，两两合并生成新的表，然后维护每个表中的当前元素，相当于程序中的$merge$，所以$merge$的时间复杂度为$\\Theta (nlogn)$。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 750 + 3;int k;int A[MAX][MAX];struct Node&#123; int s, b; Node(int s = 0, int b = 0) : s(s), b(b) &#123;&#125; bool operator &lt; (const Node&amp; rhs) const&#123; return s &gt; rhs.s; &#125;//priority_queue的优先级&#125;;void merge(int* A, int* B, int *C, int n)&#123; priority_queue&lt;Node&gt; pq; for(int i = 0; i &lt; n; i++) pq.push(Node(A[i] + B[0], 0)); for(int i = 0; i &lt; n; i++)&#123; Node node = pq.top(); pq.pop(); C[i] = node.s; if(node.b + 1 &lt; k) pq.push(Node(node.s - B[node.b] + B[node.b + 1], node.b + 1)); &#125;&#125;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif while(scanf(\"%d\", &amp;k) != EOF)&#123; memset(A, 0, sizeof A); for(int i = 0; i &lt; k; i++)&#123; for(int j = 0; j &lt; k; j++) scanf(\"%d\", &amp;A[i][j]); sort(A[i], A[i] + k); &#125; for(int i = 1; i &lt; k; i++) merge(A[0], A[i], A[0], k); printf(\"%d\", A[0][0]); for(int i = 1; i &lt; k; i++) printf(\" %d\", A[0][i]);// printf(\"\\n\"); &#125; return 0;&#125; 一道思想类似的题目1203 - Argus","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"优先队列","slug":"优先队列","permalink":"http://yoursite.com/tags/优先队列/"},{"name":"多路归并问题","slug":"多路归并问题","permalink":"http://yoursite.com/tags/多路归并问题/"}]},{"title":"UVa 1401 - Remember the Word & UVa 11732 - strcmp Anyone?","slug":"UVa-1401-Remember-the-Word-UVa-11732-strcmp-Anyone","date":"2017-05-23T16:51:38.000Z","updated":"2017-05-28T04:31:14.001Z","comments":true,"path":"2017/05/24/UVa-1401-Remember-the-Word-UVa-11732-strcmp-Anyone/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-1401-Remember-the-Word-UVa-11732-strcmp-Anyone/","excerpt":"$UVa 1401 - Remember \\ the \\ Word$UVa 1401题目地址 描述给出一个由$S$个不同单词组成的字典一个长字符串。把这个字符串分解成若干的单词的连接（单词可以重复使用），有多少种方法？输入包含多组数据。每组数据为小写字母组成的待分解的字符串，长度$L$不超过$300000$。第二行单词个数为$S(1 \\leq S \\leq 4000)$。以下$S$行为一个长度不超过$100$由小写字母组成的单词。","text":"$UVa 1401 - Remember \\ the \\ Word$UVa 1401题目地址 描述给出一个由$S$个不同单词组成的字典一个长字符串。把这个字符串分解成若干的单词的连接（单词可以重复使用），有多少种方法？输入包含多组数据。每组数据为小写字母组成的待分解的字符串，长度$L$不超过$300000$。第二行单词个数为$S(1 \\leq S \\leq 4000)$。以下$S$行为一个长度不超过$100$由小写字母组成的单词。 分析用指针实现的比数组稍微快一点儿吧。。。很容易想到一道关于字符串的动态规划。我们令$d(i)$表示从字符$i$开始的字符串的分解方案数（即后缀$S[i…L]$）。我们通过递推式定义可以推导出递推方程$d(i) = sum(d(i + len(x)) \\mid x为S[i…L]的前缀 )$，递推时一定要注意递推的边界。在推导递推式的时候我们要判断$x$是否为$S[i…L]$的前缀，如果我们要来枚举的话在最坏的情况下我们要依次判断$4000$个单词，每一个单词长度最坏的情况下将长达$100$，我们显然无法在一定的时间范围中的出结果。这时候我们想到把所有的单词先组织成一颗$Trie$，然后试着在$Trie$中来判断$x$是否为$S[i…L]$的前缀。查找过程中我们每经过一个单词结点，就找到上述状态转移方程中的$x$，最多只需要比较$100$次就能找到所有的$x$。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXNODE = 4000 * 100 + 3;const int SIGMA_SIZE = 26;const int maxl = 300000 + 3;// 文本串最大长度const int maxw = 4000 + 3;// 文本串最大长度const int maxwl = 100 + 3;// 文本串最大长度const int MOD = 20071027;int d[maxl], len[maxw], S;char text[maxl], word[maxwl];struct Trie&#123; struct Node&#123; Node *ch[SIGMA_SIZE]; int val; &#125;pool[MAXNODE], *pit, *root; void init()&#123; pit = pool, root = pit++; root-&gt;val = 0; memset(root-&gt;ch, 0, sizeof root-&gt;ch); &#125; void insert(char* s, int id)&#123; Node *cur = root; for(int i = 0; s[i]; ++i)&#123; int c = s[i] - 'a'; if(!cur-&gt;ch[c])&#123; memset(pit-&gt;ch, 0, sizeof pit-&gt;ch); pit-&gt;val = -1; cur-&gt;ch[c] = pit++; &#125; cur = cur-&gt;ch[c]; &#125; cur-&gt;val = id; &#125; void find_prefixes(const char *s, int len, vector&lt;int&gt;&amp; ans)&#123; Node *cur = root; for(int i = 0; s[i]; i++)&#123; if(s[i] == '\\0') break; int c = s[i] - 'a'; if(!cur-&gt;ch[c]) break; cur = cur-&gt;ch[c]; if(cur-&gt;val &gt;= 0) ans.push_back(cur-&gt;val); // 找到一个前缀 &#125; &#125;&#125;trie;int main()&#123;#ifndef DBEUG //freopen(\"test.in\",\"r\",stdin);#endif int kase = 0; while(scanf(\"%s%d\", text, &amp;S) == 2)&#123; trie.init(); for(int i = 1; i &lt;= S; i++)&#123; scanf(\"%s\", word); len[i] = strlen(word); trie.insert(word, i); &#125; memset(d, 0, sizeof(d)); int L = strlen(text); d[L] = 1; for(int i = L - 1; i &gt;= 0; i--)&#123; vector&lt;int&gt; p; trie.find_prefixes(text + i, L - i, p); for(unsigned int j = 0; j &lt; p.size(); j++) d[i] = (d[i] + d[i + len[p[j]]]) % MOD; &#125; printf(\"Case %d: %d\\n\", ++kase, d[0]); &#125; return 0;&#125; $UVa 11732 - “strcmp()” \\ Anyone?$UVa 11732题目地址 描述输入$n$个字符串，两两调用一次$strcmp()$（即一共调用$\\frac{n(n - 1)}{2}$次），问字符比较的总次数是？ 分析我觉得这道题目很巧妙呀，虽然它是在$Trie$部分后面的习题，但是整道题目正解的思想很巧妙呀。只要想到用$Trie$最后一般都是可以把比较次数的式子推出来的。从这道题目的数据范围可以知道，一般的朴素暴力算法（两两比较）是效率很低的，在最坏的情况下用朴素的思想显然是不行的。那么我们把所有的字符串插入到一颗$Trie$树中呢？因为题目中字符集较大，所以我们这里用左儿子右兄弟的方式建图， 就是将多叉树转为二叉树。如图所示，这里就不解释了。这里我们还要计算一个$tot[i]$即为第$i$个结点为根的子树包含的叶结点总数，也就是有多少字符串经过这个结点。比较分为两种情况： $n$字符串两两比较一共要比较$\\frac{n(n-1)}{2}$组字符串，因为是两两比较所以比较$n(n-1)$次，若字符串两两相等（此处为完全相等，即长度与字符均相等）模拟运用$strcmp$则需要比较$n(n-1) \\cdot length$次（题目中的$length$为字符串相等长度$+1$）。 若字符串中结点$u$之前的字符串完全相等，而结点$v$之后的字符串开始不相等，因为我们前面用左儿子右兄弟的方式来存数，所以我们比较$\\frac{tot[v] \\cdot (tot[u] - tot[v])}{2}$对字符串，比较次数为$tot[v] \\cdot (tot[u] - tot[v])$，比较完最左边的儿子以后，我们找与最左边的儿子属于同一层的相邻的右兄弟，计算右兄弟与除右兄弟以外属于结点$u$的其他字符串所需要的比较次数；我们举例之后发现，这样子计算比较次数会因为重复计算而变为正常所需比较次数的两倍。最终的比较次数为$\\frac{tot[v] \\cdot (tot[u] - tot[v])}{2} \\mid v\\in u$。 这样预处理完每个结点的$tot$之后，$DFS$一次就可以了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int maxnode = 4000 * 1000 + 3;const int sigma_size = 26;const int maxl = 1000 + 10;int n;char word[maxl];struct Trie&#123; int head[maxnode];// head[i]为第i个结点的左儿子编号 int next[maxnode];//next[i]为第i各节点的右兄弟编号 int tot[maxnode];// tot[i]为第i个结点为根的子树包含的叶结点总数 int ch[maxnode]; int sz; LL ans; void clear()&#123; sz = 1; head[0] = next[0] = tot[0] = 0;&#125; void insert(char *s)&#123; int u = 0, v, n = strlen(s); tot[0]++; for(int i = 0; i &lt;= n; i++)&#123;//included '\\0' bool equal = false; for(v = head[u]; v != 0; v = next[v])&#123; if(ch[v] == s[i])&#123; equal = true; break; &#125; &#125; if(!equal)&#123; v = sz++; tot[v] = 0; ch[v] = s[i]; next[v] = head[u]; head[u] = v;// 插入到链表的首部 head[v] = 0; &#125; u = v; tot[u]++; &#125; &#125; void dfs(int depth, int u)&#123; if(head[u] == 0) ans += tot[u] * (tot[u] - 1) * depth; else&#123; int sum = 0; for(int v = head[u]; v != 0; v = next[v]) sum += tot[v] * (tot[u] - tot[v]); ans += sum / 2 * (2 * depth + 1); for(int v = head[u]; v != 0; v = next[v]) dfs(depth + 1, v); &#125; &#125; LL count()&#123; ans = 0; dfs(0, 0); return ans; &#125;&#125;trie;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif int kase = 0; while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n)&#123; trie.clear(); for(int i = 0; i &lt; n; i++)&#123; scanf(\"%s\", word); trie.insert(word); &#125; printf(\"Case %d: %lld\\n\", ++kase, trie.count()); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"Trie","slug":"Trie","permalink":"http://yoursite.com/tags/Trie/"},{"name":"树形DP","slug":"树形DP","permalink":"http://yoursite.com/tags/树形DP/"}]},{"title":"[模板]树状数组","slug":"模板-树状数组","date":"2017-05-23T16:47:36.000Z","updated":"2017-10-27T03:22:41.914Z","comments":true,"path":"2017/05/24/模板-树状数组/","link":"","permalink":"http://yoursite.com/2017/05/24/模板-树状数组/","excerpt":"定义先学完线段树后再学树状数组比较好理解。树状数组又称为二叉索引树，可以支持以下两种操作： $Add(x, d)$操作，让$A_{i}$增加$d$。 $Query(L, R)$：计算$A_{L} + A_{L + 1} + \\cdots + A_{R}$。","text":"定义先学完线段树后再学树状数组比较好理解。树状数组又称为二叉索引树，可以支持以下两种操作： $Add(x, d)$操作，让$A_{i}$增加$d$。 $Query(L, R)$：计算$A_{L} + A_{L + 1} + \\cdots + A_{R}$。 分析我们之所以用树状数组来进行整两个操作是因为树状数组可以在$\\Theta (nlobn)$的时间复杂度下完程这两个操作，我们看树状数组时如何巧妙快速的完成的 (´▽`ʃ♡ƪ)。对于正整数$x$，我们定义$lowbit(x)$为$x$二进制表达式中最右边的$1$所对应的值。如$34 = 00100010$，那么$34$的$lowbit = 10 = 2$。我们如何快速的求出每一个数的$lowbit$呢？后面再说我们为什么要用到$lowbit$。123int lowbit(int x)&#123; x &amp; (~x + 1);&#125; 我们根据补码的特性，可以描述为123int lowbit(int x)&#123; x &amp; (-x);&#125; 现在看一下树状数组的结构吧，如图所示，这个图是我画的(੭ˊᵕˋ)੭ଘ。我们来明确图中每一个元素的意义。会的结点时$BIT$中的结点，每一层结点的$lowbit$都相同，$lowbit$越大越靠近根结点。编号$0$时虚拟结点，我们在循环中通常要从$1$开始遍历。对于结点$i$，如果$i$时左子结点，那么他父亲的编号为$i + lowbit(i)$；如果$i$为右子结点，那么他父亲的编号为$i - lowbit(i)$。现在我们引入辅助数组$C$，其中$C_{i} = A_{i - lowbit(i) + 1} + A_{i - lowbit(i) + 2} + \\cdots + A_{i}$。$C$中的每一个元素都是$A$数组中一段连续和，如：$C_{12} = A_{9} + A_{10} + A_{11} + A_{12}$。相信你看到这里，已经明白了树状数组的奥妙了吧。所以我们计算前缀和$S_{i}$，只需要顺着结点$i$一边往左走，一边往上走。如图所示，求$S_{23}$的前缀和。我们修改了一个$A_{i}$当然就要把用$A_{i}$计算的$C_{i}$的值也进行修改，*那么我一边往右走，一边往上走。如图所示，修改$A_{9}$的值。 代码现在给出树状数组的模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 100 + 3;int n;int A[MAX];inline int lowbit(int x)&#123; return x &amp; (-x);// x &amp; (~x+1);&#125;struct FenwickTree&#123; int n; vector&lt;int&gt; C; void resize(int n)&#123;//resize(x) 重新指定树状数组的大小为x, O(1), x&gt;=0 this-&gt;n = n; C.resize(n); &#125; void clear()&#123; fill(C.begin(), C.end(), 0); &#125; int sum(int x)&#123; int ret = 0; while(x &gt; 0)&#123; ret += C[x]; x -= lowbit(x); &#125; return ret; &#125; int query_sum(int x, int y)&#123; return sum(y) - sum(x - 1); &#125; void add(int x, int d)&#123; while(x &lt;= n)&#123; C[x] += d; x += lowbit(x); &#125; &#125;&#125;FT;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif scanf(\"%d\", &amp;n); int max_a = 0; for(int i = 1; i &lt;= n; i++)&#123;//from 1 to n scanf(\"%d\", &amp;A[i]); max_a = max(max_a, A[i]); &#125; FT.resize(max_a); int ans[MAX]; int Interval = 0; for(int i = 1; i &lt;= n; i++)&#123; FT.add(A[i], i); ans[i] = FT.sum(A[i]); Interval = FT.query_sum(1, 5); &#125; for(int i = 1; i &lt;= n; i++) printf(\"%d \", ans[i]); printf(\"\\n\"); printf(\"%d\\n\", Interval); return 0;&#125; 应用现在来解决一道问题吧！$UVa 1428 - Ping \\ pong$题目地址代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 20000 + 3;int n;int a[MAX], c[MAX], d[MAX];inline int lowbit(int x)&#123; return x &amp; (-x);//x &amp; (~x + 1)&#125;struct FenwickTree&#123; int n; vector&lt;int&gt; C; void resize(int n)&#123; this-&gt;n = n; C.resize(n); &#125; void clear()&#123; fill(C.begin(), C.end(), 0); &#125; int sum(int x)&#123; int ret = 0; while(x &gt; 0)&#123; ret += C[x]; x -= lowbit(x); &#125; return ret; &#125; void add(int x, int d)&#123;// while(x &lt;= n)&#123; C[x] += d; x += lowbit(x); &#125; &#125;&#125;FT;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif int T; scanf(\"%d\", &amp;T); while(T--)&#123; scanf(\"%d\", &amp;n); int max_a = 0; for(int i = 1; i &lt;= n; i++)&#123; scanf(\"%d\", &amp;a[i]); max_a = max(max_a, a[i]); &#125; FT.resize(max_a); FT.clear(); for(int i = 1; i &lt;= n; i++)&#123; FT.add(a[i], 1); c[i] = FT.sum(a[i]-1); &#125; FT.clear(); for(int i = n; i &gt;= 1; i--)&#123; FT.add(a[i], 1); d[i] = FT.sum(a[i]-1); &#125; LL ans = 0; for(int i = 1; i &lt;= n; i++) ans += (LL)c[i]*(n-i-d[i]) + (LL)(i-c[i]-1)*d[i]; printf(\"%lld\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"模板","slug":"模板","permalink":"http://yoursite.com/tags/模板/"},{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"}]},{"title":"UVa 10881 - Piotr's Ants","slug":"UVa-10881-Piotr-s-Ants","date":"2017-05-23T16:46:04.000Z","updated":"2017-10-27T03:20:50.847Z","comments":true,"path":"2017/05/24/UVa-10881-Piotr-s-Ants/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-10881-Piotr-s-Ants/","excerpt":"题目地址 描述一根长度为$L$厘米的木棍上有$n$只蚂蚁，每只蚂蚁要么向左爬，要么向右爬，速度为$1$厘米/秒。当两只蚂蚁相撞时，二者同时掉头（掉头时间忽略不计）。给出每只蚂蚁的初始位置和朝向（单位：厘米）。字母表示初始朝向（$L$表示朝左，$R$表示朝右）。第一行输入$3$个正整数$L, T, n(0\\leq n\\leq 10000)$，以下$n$行描述一只蚂蚁的初始位置，$x$为蚂蚁距离木棍左端的距离，字母表示朝向。对于每组数据按顺序输出每只蚂蚁的位置和朝向。","text":"题目地址 描述一根长度为$L$厘米的木棍上有$n$只蚂蚁，每只蚂蚁要么向左爬，要么向右爬，速度为$1$厘米/秒。当两只蚂蚁相撞时，二者同时掉头（掉头时间忽略不计）。给出每只蚂蚁的初始位置和朝向（单位：厘米）。字母表示初始朝向（$L$表示朝左，$R$表示朝右）。第一行输入$3$个正整数$L, T, n(0\\leq n\\leq 10000)$，以下$n$行描述一只蚂蚁的初始位置，$x$为蚂蚁距离木棍左端的距离，字母表示朝向。对于每组数据按顺序输出每只蚂蚁的位置和朝向。 分析很多人把这类题目称为弹性碰撞，听起来比较玄学，但是理解以后就很简单了。先引入两个定理： 忽略个体的差异，那么两个物体相撞掉头可以看作保持原样运动擦身而过。 无论如何碰撞，物体的顺序始终与开始时相同（即相对位置不变）。我们来模拟以下样例: 输入：$10 , 2 , 3 \\mid (3, R), (5, L), (8, R)$ 输出：$(3, L), (5, R), (10, R)$图片我弄了好久QAQ首先依次读入$n$个蚂蚁的编号，位置，方向，然后根据相对位置对蚂蚁进行排序也就是图中所示的初始状态。每只蚂蚁速度均为$1$厘米/秒，模拟一秒以后的状态。$A$和$B$相撞，因为蚂蚁$A$和蚂蚁$B$其本质上都是蚂蚁，并没有任何区别(☄⊙ω⊙)☄。所以我们这里默认蚂蚁$A$和蚂蚁$B$是一样的，认为他们相撞后相当于擦肩而过，这时候$A$走$B$应该走的路，而$B$走$A$应该走的路。所以我们在给出初始状态的时候，分别计算出每个初始初始状态一一对应的末状态。以上运用定理一。因为几只蚂蚁在一根木棍是怎样相撞的，什么时候相撞的，撞了几次，这些因素对蚂蚁的相对位置是没有任何影响的，也就是定理二无论如何碰撞，物体的顺序始终与开始时相同（即相对位置不变）。已知一只蚂蚁初始位置在第$1$个，那么它的末位置也一定是在第$1$个，所以我们可以应用定理二可推出每只蚂蚁的末位置。所以我们用一个$before$和$after$的结构体来对应蚂蚁的初始状态和末状态（此时我们认为蚂蚁相撞后擦肩而过没有掉头，因此方向与初始状态方向一样，用定义的方向推出相对位置，但是此时的输入顺序是未知的），所以要再用一个数组$order$来记录初始状态时每只蚂蚁的相对位置。将$after$结构体根据相对位置排序后一一对应同样根据相对位置排序后的初始状态的序号，然后按照顺序依次输出。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 10000 + 3;const char Orientation[][10] = &#123;\"L\", \"Turning\",\"R\"&#125;;int N;int L, T, n;int order[MAX];struct Ant&#123; int id, pos, dir;//left -1, turning 0, right 1 bool operator &lt; (const Ant&amp; rhs) const&#123; return pos &lt; rhs.pos; &#125;&#125;before[MAX], after[MAX];int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin); //freopen(\"test.out\",\"w\",stdout);#endif scanf(\"%d\", &amp;N); for(int kase = 1; kase &lt;= N; kase++)&#123; printf(\"Case #%d:\\n\", kase); scanf(\"%d%d%d\", &amp;L, &amp;T, &amp;n); for(int i = 0; i &lt; n; i++)&#123; int p; char ch; scanf(\"%d %c\", &amp;p, &amp;ch);// Why need a tab here? int d = (ch == 'R' ? 1 : -1); before[i] = (Ant)&#123;i, p, d&#125;; after[i] = (Ant)&#123;0, p + T * d, d&#125;; &#125; sort(before, before + n); for(int i = 0; i &lt; n; i++) order[before[i].id] = i; sort(after, after + n); for(int i = 0; i &lt; n - 1; i++) if(after[i].pos == after[i + 1].pos) after[i].dir = after[i + 1].dir = 0; for(int i = 0; i &lt; n; i++)&#123; int a = order[i]; if(after[a].pos &lt; 0 || after[a].pos &gt; L) printf(\"Fell off\\n\"); else printf(\"%d %s\\n\", after[a].pos , Orientation[after[a].dir + 1]); &#125; printf(\"\\n\"); &#125; return 0;&#125; $Attention:$这个地方的$+1$我一直没有弄明白后面弄清楚了。其实是这样的，此时$after$数组已经按初始状态的序号一一对应了，但因为我们定义向左走为$-1$为保证输出的常量数组下标不为$-1$，所以我们这里要$+1$。1else printf(\"%d %s\\n\", after[a].pos , Orientation[after[a].dir + 1]);","categories":[],"tags":[{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"弹性碰撞","slug":"弹性碰撞","permalink":"http://yoursite.com/tags/弹性碰撞/"}]},{"title":"超大背包问题","slug":"超大背包问题","date":"2017-05-23T16:43:38.000Z","updated":"2017-05-23T16:58:47.624Z","comments":true,"path":"2017/05/24/超大背包问题/","link":"","permalink":"http://yoursite.com/2017/05/24/超大背包问题/","excerpt":"描述有重量和价值分别为$W_{i}, V_{i}$的$n$个物品。从这些物品中挑选总重量不超过$W$的物品，求所有挑选方案中价值总和最大值。$1\\leq n\\leq 40$$1\\leq w_{i},v_{i}\\leq 10^{15}$$1\\leq W\\leq 10^{15}$ 分析在一般的背包问题中，$w_{i}, v_{i}和W$一般都比较小，所以我们可以用$DP$来解决。但是现在这道题目$w_{i}, v_{i}和W$的范围都扩大了很多，因为$DP$求解背包的复杂度是$\\Theta(nW)$，所以我们从数据范围上可以判断这道题目不能使用$DP$进行求解。因为此处$n$的数据范围较小所以我们考虑从$n$来找问题的突破口。因为挑选物品的方法总共有$2^{n}$（每个物品有选与不选两种状态），我们肯定会想到枚举，但是$2^{n}$还是太大了不能直接枚举，所以我们考虑把物品的个数分为一半来枚举，这样只用枚举$2\\cdot 2^{20}$。","text":"描述有重量和价值分别为$W_{i}, V_{i}$的$n$个物品。从这些物品中挑选总重量不超过$W$的物品，求所有挑选方案中价值总和最大值。$1\\leq n\\leq 40$$1\\leq w_{i},v_{i}\\leq 10^{15}$$1\\leq W\\leq 10^{15}$ 分析在一般的背包问题中，$w_{i}, v_{i}和W$一般都比较小，所以我们可以用$DP$来解决。但是现在这道题目$w_{i}, v_{i}和W$的范围都扩大了很多，因为$DP$求解背包的复杂度是$\\Theta(nW)$，所以我们从数据范围上可以判断这道题目不能使用$DP$进行求解。因为此处$n$的数据范围较小所以我们考虑从$n$来找问题的突破口。因为挑选物品的方法总共有$2^{n}$（每个物品有选与不选两种状态），我们肯定会想到枚举，但是$2^{n}$还是太大了不能直接枚举，所以我们考虑把物品的个数分为一半来枚举，这样只用枚举$2\\cdot 2^{20}$。 我们把前半部分中的选取办法对应的重量和价值的总和记为$w_{1}, v_{1}$，然后在后半部分找满足$w_{2}\\leq W - w_{1}$对应的最大的$v_{2}$就行了。因此我们思考从枚举得到的$(w_{2}, v_{2})$的集合中高效的寻找$max(v_{2}\\mid w_{1}\\leq W’)$。首先我们可以排除所有满足$w_{2}[i] \\leq w_{2}[j] 且 v_{2}[i]\\geq v_{2}[j]$的$j$。之后剩余的元素均满足$w_{2}[i] &lt; w_{2}[j] \\Leftrightarrow v_{2}[i] &lt; v_{2}[j]$，若要计算$max(v_{2}\\mid w_{1}\\leq W’ )$，只要寻找满足$w_{2}[i] \\leq W’$的最大的$i$即可。 这个这一用二分搜索来完成。所以总的时间复杂度为$\\Theta (2^{\\frac{n}{2}}n)$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int MAX = 40 + 3;int n, W;int w[MAX], v[MAX];pair&lt;int, int&gt; Interval[1 &lt;&lt; (MAX / 2)];int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif scanf(\"%d%d\", &amp;n, &amp;W); for(int i = 0; i &lt; n; i++) scanf(\"%d%d\", &amp;w[i], &amp;v[i]); int S = n / 2;//折半 for(int i = 0; i &lt; (1 &lt;&lt; S); i++)&#123; int weight = 0; int value = 0; for(int j = 0; j &lt; S; j++)&#123; if(i &gt;&gt; (j &amp; 1))&#123;//if(i &amp; (1 &lt;&lt; j)) weight += w[j]; value += v[j]; &#125; &#125; Interval[i] = make_pair(weight, value); &#125; sort(Interval, Interval + (1 &lt;&lt; S)); //去除多余元素 int m = 0; for(int i = 0; i &lt; (1 &lt;&lt; S); i++)&#123; if(Interval[m - 1].second &lt; Interval[i].second) Interval[m++] = Interval[i]; &#125; int ans = 0; for(int i = 0; i &lt; 1 &lt;&lt; (n - S); i++)&#123; int weight = 0; int value = 0; for(int j = 0; j &lt; n - S; j++)&#123; if(i &gt;&gt; (j &amp; 1))&#123;//if(i &amp; (1 &lt;&lt; j)) weight += w[S + j]; value += v[S + j]; &#125; &#125; if(weight &lt;= W)&#123; int sumv = (lower_bound(Interval, Interval + m, make_pair(W - weight, INF)) - 1)-&gt;second; ans = max(ans, value + sumv); &#125; &#125; printf(\"%d\\n\", ans); return 0;&#125;/*输入 n = 4, W = 5; 2 3 1 2 3 4 2 2 输出 7 */","categories":[],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"折半搜索 & 双向枚举","slug":"折半搜索-双向枚举","permalink":"http://yoursite.com/tags/折半搜索-双向枚举/"}]},{"title":"UVa 11300 - Spreading the Wealth","slug":"UVa-11300-Spreading-the-Wealth","date":"2017-05-23T16:42:17.000Z","updated":"2017-10-27T03:19:17.981Z","comments":true,"path":"2017/05/24/UVa-11300-Spreading-the-Wealth/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-11300-Spreading-the-Wealth/","excerpt":"题目地址 描述圆桌旁坐着$n$个人，每人有一定数量的的金币，金币数总能被$n$整除。每个人可以给他左右相邻的人一些金币，最终使得每个人的金币数目相等。你的任务是求出被转手的金币数量的最小值。每组数据第一行为整数$n(n\\leq 1000000)$，以下$n$行每行为一个整数，按逆时针顺序给出每个人应有的金币数。输入结束标志为$EOF$。对于每组数据输出被转手金币的数量的最小值。","text":"题目地址 描述圆桌旁坐着$n$个人，每人有一定数量的的金币，金币数总能被$n$整除。每个人可以给他左右相邻的人一些金币，最终使得每个人的金币数目相等。你的任务是求出被转手的金币数量的最小值。每组数据第一行为整数$n(n\\leq 1000000)$，以下$n$行每行为一个整数，按逆时针顺序给出每个人应有的金币数。输入结束标志为$EOF$。对于每组数据输出被转手金币的数量的最小值。 分析首先我们可以先计算出最终每个人手中持有的金币数量$M$，$M$等于总金币数量除以人数$n$。假设有$4$个人，按顺序编号为$1， 2， 3， 4$。假设$1$号给$2$号$3$枚金币，然后$2$号给$1$号$5$枚金币，实际上相当于$2$号给$1$号$2$枚金币，而$1$号什么都没有给$2$号。这样，我们设$x_{2}$表示$2$号给了$1$号多少金币，如果$x_{2}$小于$0$说明$1$号给了$2$号$-x_{2}$枚金币。现在假设编号为$i$的人初始有$A_{1}$枚金币。对于$1$号，他给了$4$号$x_{1}$枚金币，还剩$A_{1} - x_{1}$枚金币；又因为$2$号给了他$x_{2}$枚金币，所以最终他剩$A_{1} - x_{1} + x_{2}$枚金币。对于剩下的人也是一样的，依次我们可以得到$n$个等式： \\left\\{\\begin{matrix} A_{1} - x_{1} + x_{2} = M \\\\ A_{2} - x_{2} + x_{3} = M \\\\ A_{3} - x_{3} + x_{4} = M \\\\ \\vdots\\\\ A_{n} - x_{n} + x_{1} = M \\end{matrix}\\right.这里我们令$C_{n} = A_{n} - M$，进行移项变为 \\left\\{\\begin{matrix} x_{2} = M - A_{1} + x_{1} = x_{1} - C_{1} \\\\ x_{3} = M - A_{2} + x_{2} = x_{1} - C_{2} \\\\ x_{4} = M - A_{3} + x_{3} = x_{1} - C_{3}\\\\ \\vdots\\\\ x_{5} = M - A_{n - 1} + x_{n - 1} = x_{1} - C_{n - 1} \\end{matrix}\\right.第二项是这样子变过来的$A_{2} -x_{2} +x_{3} = M\\rightarrow x_{3} = M - A_{2} + x_{2} = 2M -A_{1} -A_{2}+x_{1} = x_{1} - C_{2}$第三项同理$A_{3} -x_{3} +x_{4} = M\\rightarrow x_{4} = M - A_{3} + x_{3} = 3M -A_{1} -A_{2} - A_{3}+x_{1} = x_{1} - C_{3}$ 其实在实际应用中我们并不需要第$n$个等式，因为这道题目中题到过这是一个环形。我们希望所有的$x_{i}$的绝对值最小，即$|x_{1}| + |x_{1} - C_{1}| + |x_{1} - C_{2}| + \\cdots + |x_{1} - C_{n - 1}|$的绝对值最小。$ |x_{1} - C_{i}|$的几何意义是数轴上点$x_{1}$到$C_{i}$的距离。至此问题就变为了给定数轴上的$n$个点，找出一个到它们距离之和尽量小的点。这里我们简要的证明一下，为什么最优的的$x_{1}$是这些数的中位数。如图，任意找一个点，如图中灰色的圆，它左边有$4$个输入点，右边有$2$个输入点。当灰色的圆向左平移$d$个单位，灰点左边的$4$个点到它的距离距离各减少了$d$，而灰点右边的$2$个点各增加了$d$，总共距离减少了$2d$。当灰点右边有$4$个点左边有$2$个点的时候，同理，将灰点向右平移$d$个单位长度，距离减少$2d$。所以如果输入点的个数有奇数个，则灰点必定会与中间的那个点重合，即为中位数；当个数为偶数，那么灰点可以位于中间的两个点之间的任意位置，仍然是中位数。有许多题目中，我们转化为这个模型后，都可以用中位数进行求解。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1000000 + 3;int n;LL A[MAX];LL C[MAX];int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif while(scanf(\"%d\", &amp;n) != EOF)&#123; LL sum = 0; for(int i = 0; i &lt; n; i++)&#123; scanf(\"%lld\", &amp;A[i]); sum += A[i]; &#125; LL M = sum / n; C[0] = 0; for(int i = 1; i &lt; n; i++) C[i] = C[i - 1] + A[i] - M; sort(C, C + n); LL x1 = C[n/2], ans = 0; for(int i = 0; i &lt; n; i++) ans += abs(x1 - C[i]); printf(\"%lld\\n\", ans); &#125; return 0;&#125; 其实代码还可以进一步优化，如运用快速选择，在线性时间内求出中位数。（＾∀＾●）ﾉｼ","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"}]},{"title":"UVa 11729 - Commando War","slug":"UVa-11729-Commando-War","date":"2017-05-23T16:39:44.000Z","updated":"2017-05-28T04:32:28.566Z","comments":true,"path":"2017/05/24/UVa-11729-Commando-War/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-11729-Commando-War/","excerpt":"题目地址 描述你有$n$个部下，每个部下需要完成一项任务。第$i$个部下需要你花$B_{i}$分钟交待任务，然后他会立刻独立地、无间断地执行$J_{i}$分钟任务。你徐亚选择交待任务的顺序，使得所有任务尽早执行完毕（即最后一个执行完的任务应尽早结束）。注意，不能同时给两个部下交待任务，但是部下可以同时执行他们各自的任务。每组数据第一行$N(1\\leq N\\leq 1000)$为部下的人数。以下$N$行每一行有两个正整数$B$和$J$$(1\\leq B,J\\leq 10000)$，即交待任务的时间和完成任务的时间。输入结束标志为$N = 0$。输出完成任务所需的最短的时间。","text":"题目地址 描述你有$n$个部下，每个部下需要完成一项任务。第$i$个部下需要你花$B_{i}$分钟交待任务，然后他会立刻独立地、无间断地执行$J_{i}$分钟任务。你徐亚选择交待任务的顺序，使得所有任务尽早执行完毕（即最后一个执行完的任务应尽早结束）。注意，不能同时给两个部下交待任务，但是部下可以同时执行他们各自的任务。每组数据第一行$N(1\\leq N\\leq 1000)$为部下的人数。以下$N$行每一行有两个正整数$B$和$J$$(1\\leq B,J\\leq 10000)$，即交待任务的时间和完成任务的时间。输入结束标志为$N = 0$。输出完成任务所需的最短的时间。 分析由题意我们可以很快想到贪心，执行任务所需时间最长的最先交待，那么我们要按照$J$从大到小的顺序依次排序，然后依次交待。现在我们用反证法来证明贪心的正确性。 证明假设我们交换相邻的两个任务$X$和$Y$（交换前$X$在$Y$之前，那么交换后$X$在$Y$之后），我们发现其他任务完成的时间没有影响，但是对于这两个交换的任务我们有如下两种情况。情况一，如图一所示。交换前任务$Y$比$X$先结束。交换后$X$结束时间延后，$Y$的结束时间提前了，但是这样交换对于我们最终的结果非但没有好处反而花费的时间更长了。情况二，如图二所示。交换前$X$比$Y$先结束，如果交换后情况没有变好，那么一定满足：交换后$X$的结束时间不比交换前$Y$的结束时间早，也就是说，交换后$Y$的结束时间肯定变早了。所以如图二所示的情况将满足不等式$B[Y] + B[X] + J[X] \\geq B[X] + B[Y] + J[Y]$，化简后得$J[X] \\geq J[Y]$，这就是我们贪心的依据。这里提一下，关于排序的小技巧。(๑•̀ㅂ•́)و✧ 贪心的时候我们经常要用到排序，如果是单个数组排序的话直接$sort$就可以了。但是如果出现一对数呢？为了避免排序的时候一对数被打散，这时候我们就要用到结构体，因为我们要对结构体中的元素进行排序，我们把要进行排序的元素在结构体中进行重载，然后把结构体作为$vector$容器中的变量，然后就可以哒。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int n;struct Node&#123; int b, j; bool operator &lt; (const Node&amp; rhs) const &#123; return j &gt; rhs.j; &#125;&#125;;vector&lt;Node&gt; vec;inline int ReadInt()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123; if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123; x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif int kase = 1; while(scanf(\"%d\", &amp;n) == 1 &amp;&amp; n)&#123; vec.clear();// int b, j; for(int i = 0; i &lt; n; i++)&#123; b = ReadInt(); j = ReadInt(); vec.push_back((Node)&#123;b, j&#125;); &#125; sort(vec.begin(), vec.end()); int s = 0, ans = 0; for(int i = 0; i &lt; n; i++)&#123; s += vec[i].b; ans = max(ans, s + vec[i].j); &#125; printf(\"Case %d: %d\\n\", kase++, ans); &#125; return 0;&#125; 开始学习《训练指南》了，加油φ(≧ω≦*)♪","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"}]},{"title":"UVa 1659 - Help Little Laura(最小费用循环流)","slug":"UVa-1659-Help-Little-Laura-最小费用循环流","date":"2017-05-23T16:37:06.000Z","updated":"2017-05-28T04:31:37.058Z","comments":true,"path":"2017/05/24/UVa-1659-Help-Little-Laura-最小费用循环流/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-1659-Help-Little-Laura-最小费用循环流/","excerpt":"题目地址 描述平面上有$m$条有向线段连接了$n$个点。你从某一个点出发顺着有向线段行走，给沿途经过的每条线段涂一种不同的颜色，最后回到起点。你可以多次行走，给多个回路涂色。可以重复经过一个点，但是不能重复经过一条有向线段。如图所示是一种涂色方法(虚线表示未涂色)。","text":"题目地址 描述平面上有$m$条有向线段连接了$n$个点。你从某一个点出发顺着有向线段行走，给沿途经过的每条线段涂一种不同的颜色，最后回到起点。你可以多次行走，给多个回路涂色。可以重复经过一个点，但是不能重复经过一条有向线段。如图所示是一种涂色方法(虚线表示未涂色)。每涂一个单位长度将得到$x$分，但每使用一种颜料将扣$y$分。假定颜料有无限多种，如何涂色才能使得分最大？输入保证若存在有向线段$u\\rightarrow v$，则不会出现有向线段$v\\rightarrow u$。$n\\leq 100，m\\leq 500，1\\leq x, y\\leq 1000$。 分析首先我们先简化这道题目，尝试建模：给出一幅有向图，从中选取权和最大的边集，组成若干个有向圈。这里的边权等于$dx - y$，其中$d$为边的两个端点之间的欧几里德距离。提炼出模型后我们再来处理细节，题目中说由于每一个点并不一定只属于一个有向圈，因此“匹配后继”在这里并不适用。但是我们还是可以依据题目建立一个费用流的模型：在原图的基础上设每一条边的容量为$1$，边权就是费用。我们要找一个流使得对于每一给结点都满足流量守恒的条件，且总流量乘以费用总和最大。但是这样的模型是没有源点和汇点的，又因为每一个结点满足流量守恒，所以不存在最大流，而我们大这称为循环流。因此，换句话说我们这道题目实际上是要求解最大费用循环流问题。对于最大循环流我们如何解决呢？ 方法一：对于最大费用流问题，我们通常会将边权取负，然后计算最小费用流。对于最大费用循环流我们也是一样解决的：把每条边的边权由$dx - y$改为$-dx + y$，那么问题就转化为了求解最小费用循环流。我们每一次寻找整个图的负费用增广圈，沿着付费用增广圈增广后，每一个点的流量平衡并不会因此而被破坏，而整个循环流的总费用是变小了。因为找负费用增广圈相当于在残量网络中寻找负圈，所以我们可以适当套用最小费用最大流的算法，用$Bellman-Ford$来判负圈。 方法二：其实，我们还有另外一种不用涉及负圈的算法，不过比较巧妙很难想到。其实也很常规，就是新增附加源$s$和附加汇点$t$，对于原图中的每一条负圈边$u\\rightarrow v$拆分成为三条边$s\\rightarrow v，v\\rightarrow u和u\\rightarrow t$，容量均为$1$，但是$v\\rightarrow u$的费用为原来的相反数，其它两条边的费用均为$0$。原图中的正权边$u\\rightarrow v$保持不变：容量为$1$，费用为权值。这样处理过后，途中所有都变为了正权边，但是网络中会出现很多重边，要处理一下：对于任意点$u$，假设$s\\rightarrow u$的弧有$a$条，$u\\rightarrow t$的弧有$b$条。则当$a &gt; b$时保留一条弧$s\\rightarrow u$，容量为$a - b$，删除所有$u\\rightarrow t$的弧。 当$a &lt; b$时保留一条弧$u\\rightarrow t$，容量为$b - a$，删除所有$s\\rightarrow u$的弧。那么只需要求一次$s-t$的最小费用最大流，求出的最小费用加上原图的所有负权之和就为循环流的最小费用值。 其实大多数网络流的题目都是这样的，提炼出题目的模型，然后用我们学过最基本的算法，最大流，最小费用最大流，为二分图匹配之类的算法往上套，为了用已知的算法处理这道题目，我们还要进行大量的预处理。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int MAX = 100 + 3;int n, a, b;int x[MAX], y[MAX], c1[MAX], c2[MAX];vector&lt;int&gt; G[MAX];inline int ReadInt()&#123; int x = 0, f = 1; char ch = getchar(); while(ch &lt; '0' || ch &gt; '9')&#123; if(ch == '-') f = -1; ch = getchar();&#125; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9')&#123; x = x * 10 + ch - '0'; ch = getchar();&#125; return x * f;&#125;struct Edge&#123; int from, to, cap, flow; double cost; Edge(int from, int to, int cap, int flow, double cost) : from(from), to(to), cap(cap), flow(flow), cost(cost)&#123;&#125;&#125;;struct MCMF&#123; int n, m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[MAX]; int a[MAX]; int p[MAX]; double d[MAX]; int inq[MAX]; void init(int n)&#123; this-&gt;n = n; for(int i = 0; i &lt; n; i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from, int to, int cap, double cost)&#123; edges.push_back(Edge(from, to, cap, 0, cost)); edges.push_back(Edge(to, from, 0, 0, -cost)); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool Bellman_Ford(int s, int t, int&amp; flow, double&amp; cost)&#123; for(int i = 0; i &lt; n; i++) d[i] = INF; memset(inq, 0, sizeof(inq)); d[s] = 0; inq[s] = 1; p[s] = 0; a[s] = INF; queue&lt;int&gt; q; q.push(s); while(!q.empty())&#123; int u = q.front(); q.pop(); inq[u] = 0; for(int i = 0; i &lt; G[u].size(); i++)&#123; Edge&amp; e = edges[G[u][i]]; if(e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost)&#123; d[e.to] = d[u] + e.cost; p[e.to] = G[u][i]; a[e.to] = min(a[u], e.cap - e.flow); if(!inq[e.to])&#123; q.push(e.to); inq[e.to] = 1; &#125; &#125; &#125; &#125; if(d[t] == INF) return false; flow += a[t]; cost += d[t] * a[t]; for(int u = t; u != s; u = edges[p[u]].from)&#123; edges[p[u]].flow += a[t]; edges[p[u]^1].flow -= a[t]; &#125; return true; &#125; int MincostMaxflow(int s, int t, double&amp; cost)&#123; int flow = 0; cost = 0; while(Bellman_Ford(s, t, flow, cost)); return flow; &#125;&#125;mcmf;int main()&#123;#ifndef DEUBG //freopen(\"test.in\",\"r\",stdin);#endif int kase = 0, v; while(scanf(\"%d%d%d\", &amp;n, &amp;a, &amp;b) == 3 &amp;&amp; n)&#123; mcmf.init(n + 2); for(int u = 0; u &lt; n; u++)&#123; x[u] = ReadInt(); y[u] = ReadInt(); G[u].clear(); while(1)&#123; v = ReadInt(); if(v == 0) break; G[u].push_back(v - 1); &#125; &#125; memset(c1, 0, sizeof(c1)); memset(c2, 0, sizeof(c2)); double sum = 0; for(int u = 0; u &lt; n; u++)&#123; for(int i = 0; i &lt; G[u].size(); i++)&#123; int v = G[u][i]; double d = sqrt((x[u] - x[v])*(x[u] - x[v]) + (y[u] - y[v])*(y[u] - y[v])); double edge_cost = -d*a+b; // minimize sum&#123;edge_cost&#125; if(edge_cost &gt;= 0) mcmf.AddEdge(u, v, 1, edge_cost); else&#123; mcmf.AddEdge(v, u, 1, -edge_cost);// c1[v]++; c2[u]++; sum += -edge_cost; &#125; &#125; &#125; for(int u = 0; u &lt; n; u++)&#123; if(c1[u] &gt; c2[u]) mcmf.AddEdge(n, u, c1[u] - c2[u], 0); if(c2[u] &gt; c1[u]) mcmf.AddEdge(u, n + 1, c2[u] - c1[u], 0); &#125; double cost; int flow = mcmf.MincostMaxflow(n, n + 1, cost); double ans = sum - cost; if(ans &lt; 0) ans = 0; printf(\"Case %d: %.2lf\\n\", ++kase, ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"最小费用循环流","slug":"最小费用循环流","permalink":"http://yoursite.com/tags/最小费用循环流/"}]},{"title":"UVa 10735 - Euler Circuit(混合图的欧拉回路)","slug":"UVa-10735-Euler-Circuit-混合图的欧拉回路","date":"2017-05-23T16:34:21.000Z","updated":"2017-10-27T03:15:38.487Z","comments":true,"path":"2017/05/24/UVa-10735-Euler-Circuit-混合图的欧拉回路/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-10735-Euler-Circuit-混合图的欧拉回路/","excerpt":"题目地址 描述给出$V$个点$E$条边($1\\leq V\\leq 100$， $1\\leq E\\leq 500$)的混合图(即有的边是有向边描述为$D$，有的边是无向边描述为$U$)，试求出它的一条欧拉回路，如果没有输出无解信息。 连通的无向图$G$存在欧拉回的充要条件是：$G$中每个顶点的度都是偶数。","text":"题目地址 描述给出$V$个点$E$条边($1\\leq V\\leq 100$， $1\\leq E\\leq 500$)的混合图(即有的边是有向边描述为$D$，有的边是无向边描述为$U$)，试求出它的一条欧拉回路，如果没有输出无解信息。 连通的无向图$G$存在欧拉回的充要条件是：$G$中每个顶点的度都是偶数。 分析其实很多混合图问题可以转化为有向图问题，方法是把无向边拆成两条方向相反的有向边。但是因为本题欧拉回路的限制，那就是说从任何一点出发都可以经过所有边恰好一次再回到自己，混合图中无向图定向后，有欧拉回路当且仅当所有点的入度都等于出度，所以这道题目并不可以用常规的办法解决。换一个思路想我们可以把图中的无向边定向，在从而解决这道题。 证明首先，我们将无向边任意定向，因为输入一定保证在忽略边的方向后图示连通的，所以在这里不用判断图是否连通。然后把定向后的有向边单独组成另一个图$G’$。初始时，使$G’$为空，对于$G$中的每一条无向边$u\\rightarrow v$，定向后在图$G’$中连一条边$u’\\rightarrow v’$。然后，我们计算每一个点出度与入度的差值$degree$。我们发现，如果所有点入度等于出度，则图中一定存在欧拉回路。当一个点出度$out(i)$与入度$in(i)$的差值为偶数的时候，可以把出度减少$\\frac{|out(i) - in(i)|}{2}$，把入度增加$\\frac{|out(i) - in(i)|}{2}$。但是，当一个点$degree$为奇数的时候，永远不可能使它的入度等于出度。接下来，思考如何给边进行定向，使得所有点的$degree$都为$0$，这里我们用网络流来解决。建立源点$S$和汇点$T$。对于$degree &gt; 0$的点$v$，我们连一条边$S\\rightarrow v$，容量为$\\frac{degree(v)}{2}$，只有$v$点出度减少$\\frac{degree(v)}{2}$入度才会等与出度，当$degree$为偶数的时候。对于$degree &lt; 0$的点$v$，我们连一条边$v\\rightarrow T$，容量为$\\frac{-degree(v)}{2}$，只有$v$点出度增加$\\frac{-degree(v)}{2}$入度才会等与出度，当$degree$为偶数的时候。然后，我们把所有是无向边的边加进来，把不是无向边的不添加进去。这不是废话吗┌(。Д。)┐、开始跑网络流，如果从出发的满流了说明所有的$degree &gt; 0$都被修改为$degree = 0$了，根据斜对称性可知，$degree &lt; 0$也等于$0$，因此我们可以通过给无向边进行定向从而使得$degree = 0$成立。然后我们把图$G’$打印出来，这时候里面的边已经都定向好了：对于流量为$1$的边，反向放入，否则方向不变。最后打印欧拉回路即可，注意有重边。（分析部分参考于） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 1000000000;const int max_n = 100 + 3;const int max_m = 500 + 3;int n, m;int u[max_m], v[max_m], directed[max_m], id[max_m], diff[max_n];struct Edge&#123; int from, to, cap, flow; Edge(int from, int to, int cap, int flow) : from(from), to(to), cap(cap), flow(flow)&#123;&#125;&#125;;struct EdmondsKarp&#123; int n, m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[max_n]; int a[max_n]; int p[max_n]; void init(int n)&#123; for(int i = 0; i &lt; n; i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from, int to, int cap)&#123; edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); m = edges.size(); G[from].push_back(m - 2); G[to].push_back(m - 1); &#125; int Maxflow(int s, int t)&#123; int flow = 0; while(1)&#123; memset(a, 0, sizeof(a)); queue&lt;int&gt; q; q.push(s); a[s] = INF; while(!q.empty())&#123; int x = q.front(); q.pop(); for(int i = 0; i &lt; G[x].size(); i++)&#123; Edge&amp; e = edges[G[x][i]]; if(!a[e.to] &amp;&amp; e.cap &gt; e.flow)&#123; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow);// q.push(e.to); &#125; &#125; if(a[t]) break; &#125; if(!a[t]) break; for(int u = t; u != s; u = edges[p[u]].from)&#123; edges[p[u]].flow += a[t]; edges[p[u]^1].flow -= a[t]; &#125; flow += a[t]; &#125; return flow; &#125;&#125;EK;// for euler tour onlyvector&lt;int&gt; G[max_n];vector&lt;int&gt; vis[max_n];vector&lt;int&gt; path;void Euler(int u)&#123; for(int i = 0; i &lt; G[u].size(); i++)&#123; if(!vis[u][i])&#123; vis[u][i] = 1; Euler(G[u][i]); path.push_back(G[u][i] + 1); &#125; &#125;&#125;void print_path()&#123; // build the new graph for(int i = 0; i &lt; n; i++)&#123; G[i].clear(); vis[i].clear(); &#125; for(int i = 0; i &lt; m; i++)&#123; bool rev = false; if(!directed[i] &amp;&amp; EK.edges[id[i]].flow &gt; 0) rev = true; if(!rev)&#123; G[u[i]].push_back(v[i]); vis[v[i]].push_back(0); &#125; else&#123; G[v[i]].push_back(u[i]); vis[u[i]].push_back(0); &#125; &#125; path.clear(); Euler(0); printf(\"1\"); for(int i = path.size() - 1; i &gt;= 0; i--) printf(\" %d\", path[i]); printf(\"\\n\");&#125;int main()&#123;#ifndef DBEUG //freopen(\"test.in\",\"r\",stdin);#endif int T; scanf(\"%d\", &amp;T); while(T--)&#123; scanf(\"%d%d\", &amp;n, &amp;m); EK.init(n + 2);//包含源点与汇点 memset(diff, 0, sizeof(diff));//出度与入度的差值 for(int i = 0; i &lt; m; i++)&#123; char dir[9]; scanf(\"%d%d%s\", &amp;u[i], &amp;v[i], dir); u[i]--; v[i]--; directed[i] = (dir[0] == 'D' ? 1 : 0); diff[u[i]]++; diff[v[i]]--; if(!directed[i])&#123; id[i] = EK.edges.size(); EK.AddEdge(u[i], v[i], 1); &#125; &#125; bool ok = true; for(int i = 0; i &lt; n; i++)&#123; if(diff[i] % 2 != 0)&#123; ok = false; //出度与入度差值为奇数，不存在欧拉回路 break; &#125; &#125; int s = n, t = n + 1; if(ok)&#123; int sum = 0; for(int i = 0; i &lt; n; i++)&#123; if(diff[i] &gt; 0)&#123;//建图 EK.AddEdge(s, i, diff[i]/2); sum += diff[i]/2; &#125; if(diff[i] &lt; 0)&#123; EK.AddEdge(i, t, -diff[i]/2); &#125; &#125; if(EK.Maxflow(s, t) != sum) ok = false;// &#125; if(!ok) printf(\"No euler circuit exist\\n\"); else print_path(); if(T) printf(\"\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://yoursite.com/tags/图论/"},{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"欧拉回路","slug":"欧拉回路","permalink":"http://yoursite.com/tags/欧拉回路/"}]},{"title":"UVa 1639 - Candy","slug":"UVa-1639-Candy","date":"2017-05-23T16:20:44.000Z","updated":"2017-10-27T03:14:33.020Z","comments":true,"path":"2017/05/24/UVa-1639-Candy/","link":"","permalink":"http://yoursite.com/2017/05/24/UVa-1639-Candy/","excerpt":"题目地址 描述有两个盒子各有$n(n \\leq 2 \\times 10^{5})$个糖，每天随机选一个盒子并打开它（概率分别为$p$，$1 - p$），如果里面有糖，他会吃掉其中一个；否则他会打开另一个盒子，然后吃一颗糖。他已经每天吃一颗糖吃了几天了，有一天，他打开盒子一看，没糖啦（；´д｀）ゞ！打开另一个盒子之前，他希望你帮他算一下另一个盒子里剩余糖的个数的数学期望。有多组测试数据，对每一组测试数据包含每一个盒子中糖的个数$n(n \\leq 2 \\times 10^{5})$以及实数$p(0\\leq p\\leq 1，小数点后6位)$，以$EOF$终止。对于每组测试数据，以$”Case X：Y”$形式输出，其中$X$是测试数据的编号(从$1$开始)，$Y$是另一个盒子里剩余糖的个数的数学期望，任何答案绝对误差必须$\\leq 10^{-4}$。","text":"题目地址 描述有两个盒子各有$n(n \\leq 2 \\times 10^{5})$个糖，每天随机选一个盒子并打开它（概率分别为$p$，$1 - p$），如果里面有糖，他会吃掉其中一个；否则他会打开另一个盒子，然后吃一颗糖。他已经每天吃一颗糖吃了几天了，有一天，他打开盒子一看，没糖啦（；´д｀）ゞ！打开另一个盒子之前，他希望你帮他算一下另一个盒子里剩余糖的个数的数学期望。有多组测试数据，对每一组测试数据包含每一个盒子中糖的个数$n(n \\leq 2 \\times 10^{5})$以及实数$p(0\\leq p\\leq 1，小数点后6位)$，以$EOF$终止。对于每组测试数据，以$”Case X：Y”$形式输出，其中$X$是测试数据的编号(从$1$开始)，$Y$是另一个盒子里剩余糖的个数的数学期望，任何答案绝对误差必须$\\leq 10^{-4}$。 分析根据期望的定义，我们设最后打开第$1$个盒子，发现没有糖，此时第$2$个盒子里还剩下$i$颗糖，因为每次打开一个盒子取一颗糖，所以我们已经打开了$n$次第$1$个盒子和$n - i$次第$2$个盒子，一共打开了$n + (n - i) = 2n - i$次盒子。因为其满足二项分布，所以“最后打开的是第$1$个盒子”的概率为$\\binom{n}{2n + i}p^{n + 1}(1-p)^{n - i}$。因为$n \\leq 2 \\times 10^{5}$，所以n会非常大；又因为$p$为实数且$0\\leq p\\leq 1$，所以$p^{i + 1}， (1-p)^{n - i}$会非常接近于$0$。如果分别计算这三项再把它们乘起来，那么我们就不能控制精度$0\\leq p\\leq 1$，所以这里我们用对数来处理。$\\therefore设V_{1}(i) = ln(\\binom{n}{\\ 2n + i\\ }p^{i + 1}(1-p)^{n - i})$$= ln (\\binom{n}{\\ 2n + i\\ }) + ln(p^{n + 1})+ln (1-p)^{n - i}$$= ln (\\binom{n}{\\ 2n + i\\ })+(n + 1)ln(p) + (n - i)ln(1-p)$ 处理以后最后打开的是第$1$个盒子”的概率为$e^{V_{1}(i)}$。注意$p$的指数是$n + 1$，因为除了之前打开了$n$次盒子$1$后，最后又打开了$1$次。$log$之间一定是相加。同理，如果最后打开的是第$2$个盒子，此时第$1$个盒子中还剩下$i$颗糖。则，“最后打开的是第$2$个盒子”的概率为$\\binom{n}{2n + i}(1-p)^{n + 1}p^{n - i}$。$\\therefore设 V_{2}(i) = ln(\\binom{n}{\\ 2n + i\\ }\\ (1-p)^{n + 1}p^{n - i})$$= ln(\\binom{n}{\\ 2n + i\\ }) + ln((1-p)^{n + 1})+ln(p^{n - i})$$= ln(\\binom{n}{\\ 2n + i\\ })+(n + 1)ln(1-p) + (n - i)ln(p)$ 处理以后最后打开的是第$2$个盒子”的概率为$e^{V_{2}(i)}$。因为二项分布的期望值为$E(X) = np$ ，所以另一个盒子里糖的个数的数学期望为： \\sum(e^{v_{1}(i)} + e^{v_{2}(i)})代码123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX = 200000 + 3;long double logF[MAX * 2 + 1];int n;double p;long double logC(int n, int m)&#123; return logF[n] - logF[m] - logF[n - m];&#125;double solve(int n, double p)&#123; double ans = 0; for(int i = 0; i &lt;= n; i++)&#123; long double c = logC(n * 2 - i, n); long double v1 = c + (n + 1) * log(p) + (n - i) * log(1 - p); long double v2 = c + (n + 1) * log(1-p) + (n - i) * log(p); ans += i * (exp(v1) + exp(v2)); &#125; return ans;&#125;int main()&#123;#ifndef DEUBG //freopen(\"test.in\",\"r\",stdin);#endif logF[0] = 0; for(int i = 1; i &lt;= MAX; i++) logF[i] = logF[i - 1] + log(i); int kase = 0; while(scanf(\"%d%lf\", &amp;n, &amp;p) == 2) printf(\"Case %d: %.6lf\\n\", ++kase, solve(n, p)); return 0;&#125; 第一次接触用对数处理精度的人可能会问，为什么用取对数的方法可以让答案更加精确呢(＠_＠;)？在这道题目里你可以看出，它们都是连乘，组合数会越乘越大，而$p$也就是$0 \\leq p \\leq 1$的实数会越乘越小。但是你取对数就不会呀，取$log$只会计算一次呀！所以，当然是很精确的。一定要记住取完$log$后要用$C++$函数库里的$exp$函数还原！计算机中的$log$函数是以自然对数$e$为底，而$exp$函数是以自然对数$e$为底的幂。关于二项分布和二项分布的期望和方差我这里就不花时间写了( ﾟдﾟ)つBye！","categories":[],"tags":[{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"精度处理","slug":"精度处理","permalink":"http://yoursite.com/tags/精度处理/"},{"name":"期望 & 概率","slug":"期望-概率","permalink":"http://yoursite.com/tags/期望-概率/"}]},{"title":"同余与模运算","slug":"同余与模运算","date":"2017-05-23T15:22:58.000Z","updated":"2017-10-27T03:08:22.539Z","comments":true,"path":"2017/05/23/同余与模运算/","link":"","permalink":"http://yoursite.com/2017/05/23/同余与模运算/","excerpt":"好啦，要开始学习模运算啦，只是紫书上一点微小的部分，还是先膜一下为敬0w0。。。无关紧要的话：我觉得作为一个合格的Oler应该对于每一个基础的知识点都有一个符合自己代码风格和习惯的模板，最好是能深刻理解这个算法之后写的模板，这样我们才不会在考场上出现低级的错误哒！比如有的人取区间喜欢左闭右开，有人喜欢让左右都是闭区间；有的人循环喜欢从1开始，有人喜欢从0开始；当然，各有各的好处，只是要做到在考场上部分因为低级错误而丢分甚至于调试很长的时间就可以啦。 定义如果存在 $a\\pmod n\\equiv b\\pmod n$，即a,b除以m所得的余数相等,那么我们记作$a\\equiv \\ b \\pmod n$。 基本性质和其他的运算一样，模运算也有自己的运算法则。如果存在$a\\equiv \\ b\\pmod n$，且有$c\\equiv \\ d pmod n$，那么下面的运算率成立。 $a + c\\equiv \\ b + d \\pmod n$ $a - c\\equiv \\ b - d \\pmod n$ $a \\times c\\equiv \\ b \\times d \\pmod n$我们经常利用这三个性质对输出答案较大的程序取模，一般是模完再加，加减乘均满足的这个性质，不过除法是不满足的。","text":"好啦，要开始学习模运算啦，只是紫书上一点微小的部分，还是先膜一下为敬0w0。。。无关紧要的话：我觉得作为一个合格的Oler应该对于每一个基础的知识点都有一个符合自己代码风格和习惯的模板，最好是能深刻理解这个算法之后写的模板，这样我们才不会在考场上出现低级的错误哒！比如有的人取区间喜欢左闭右开，有人喜欢让左右都是闭区间；有的人循环喜欢从1开始，有人喜欢从0开始；当然，各有各的好处，只是要做到在考场上部分因为低级错误而丢分甚至于调试很长的时间就可以啦。 定义如果存在 $a\\pmod n\\equiv b\\pmod n$，即a,b除以m所得的余数相等,那么我们记作$a\\equiv \\ b \\pmod n$。 基本性质和其他的运算一样，模运算也有自己的运算法则。如果存在$a\\equiv \\ b\\pmod n$，且有$c\\equiv \\ d pmod n$，那么下面的运算率成立。 $a + c\\equiv \\ b + d \\pmod n$ $a - c\\equiv \\ b - d \\pmod n$ $a \\times c\\equiv \\ b \\times d \\pmod n$我们经常利用这三个性质对输出答案较大的程序取模，一般是模完再加，加减乘均满足的这个性质，不过除法是不满足的。 大整数取模输入正整数$n$和$m$，输出$n \\pmod m$的值。$n \\leqslant 10^{100}$，$m \\leqslant 10^{9}$。这里我们需要把大整数写成自左向右的形式，那么什么叫自左向右的形式呢？这里我们举一个栗子(～￣▽￣)～，如$1234 = ((1 \\times 10 + 2) \\times 10 + 3) \\times 10 + 4$。然后应用前面的运算法则每一步取模。 代码123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 100 + 3;char n[MAX];int m;LL ans;int main()&#123; scanf(\"%s%d\", n, &amp;m); int len = strlen(n); for(int i = 0; i &lt; len; i++) ans = (int)(((LL)ans * 10 + n[i] - '0') % m); printf(\"%d\\n\", (int)ans); return 0;&#125; 幂取模输入正整数$a$，$n$，$m$，输出$a^{n} \\pmod m$的。$a, n, m \\leq 10^{9}$。实际上就是快速幂啦，这里我们用分治法高效地实现。 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll a, n, m;int pow_mod(int a, int n, int m)&#123; ll res = 1ll; while (n) &#123; if (n &amp; 1) (res *= a) %= m; (a *= a) %= m; n &gt;&gt;= 1; &#125; return a;&#125;int main()&#123; scanf(\"%d%d%d\", &amp;a, &amp;n, &amp;m); printf(\"%d\\n\", pow_mod(a, n, m)); return 0;&#125; 逆元在$mod \\ n$的意义下存在$a \\times b = 1$，我们就说$a, b$互为乘法下的逆，记作$a = b^{-1}, b = a^{-1}$。我们还可以用逆元的定义来实现模意义下的除法。如，我们可以利用$a \\times b = 1$，令$a \\div b = a \\times b^{-1} \\pmod n)$。我们现在有$ax \\equiv b \\pmod n$，我们又知道模方程存在一个特殊的情况，$b = 1$时，$ax \\equiv 1 \\pmod n$的解称为$a$关于模$n$的逆。扩展欧几里德（EXGCD）算法可以在 $O(\\log \\max(a, b))$的时间内求出关于$x, y$的方程$ax + by = gcd(a, b)$的一组整数解。 模线性方程组（线性同余方程组）好吧，我现在只会求模线性方程，暂且还不会求方程组（；´д｀）ゞ。对于$ax \\equiv b \\pmod n$。因为同余，所以$ax - b = yn$，即$ax - ny = b$，当且仅当$gcd(a, n) \\mid b$时，方程有解。我们令$g = gcd(a,n)$，形如$ax - ny$的每一个数时$g$的倍数；因此如果$g$不整除$b$，则$ax - ny = b$没有解，从而$ax \\equiv b \\pmod n$没有解。假设$g$确实整除$b$，我们可推知：$ax+ny = g$总有解，通过扩展欧几里得算法求得$x = x’, y = y’$。由于假设$g$整除$b$，所以$a\\frac{bx’}{g} + n\\frac{by’}{g} = b$。这说明，$x\\equiv \\frac{bx’}{g} \\pmod n$是同余式$ax \\equiv b \\pmod n$的解。既然不定方程有多组解，难道这个方程只有以一组解吗，模方程还有其他解吗？假设$x_{1}$是同余式$ax \\equiv b \\pmod n$的其他解，则$ax_{1} \\equiv ax_{0} \\pmod n$。所以$m$整除$ax_{1} - ax_{0}$，$\\frac{n}{g}$整除$\\frac{a(x_{1} - x{0})}{g}$。我们已知$\\frac{n}{g}$与$\\frac{a}{g}$没有公因数，从而$\\frac{n}{g}$必整除$x_{1} - x_{0}$。所以存在整数$k$使得 $x_{1} = x_{0}+k\\cdot \\frac{n}{g} \\pmod n$,$k = 0, 1, 2, \\cdots , g-1$。线性同余定理 如果$g \\nmid b$，则同余式$ax \\equiv b \\pmod n$无解。 如果$g \\mid b$，则同余式$ax \\equiv b \\pmod n$恰好有$g$个不同解。 代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;int a, b, n;int d, x, y;int exgcd(int a, int b, int&amp; x, int&amp; y)&#123; int d = a; if(!b)&#123; x = 1; y = 0;&#125; else&#123; d = exgcd(b, a % b, y, x); y -= (a / b) * x; &#125; return d;&#125;int modular_linear_equation_solver(int a, int b, int n)&#123; int d = exgcd(a, n, x, y); if(b % d == 0)&#123; int x0 = x * (b / d) % n;//special answer for(int i = 0; i &lt; d; i++) printf(\"%d\\n\", (x0 + i * (n / d)) % n);//all the possible answers &#125; else printf(\"No solutions\\n\");&#125;int main()&#123; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;n); modular_linear_equation_solver(a, b, n); return 0;&#125; 中国剩余定理定义中国剩余定理是数论中的一个关于一元线性同余方程组的定理，说明了一元线性同余方程组有解的准则以及求解方法，其实是一种构造解的思想。形如同余方程组 \\left\\{\\begin{matrix} x\\equiv a_{1}\\mod m_{1}\\\\ x\\equiv a_{2}\\mod m_{2}\\\\ \\vdots\\\\ x\\equiv a_{n}\\mod m_{n} \\end{matrix}\\right.中国剩余定理说明：假设任意$n$互素，对于任意整数$a$，恰有一解$0\\leq x\\leq n_{1}n_{2}\\cdots n_{k}$1.令$N = \\prod_{i=1}^{k}n_{i}$， $N_{i} = \\frac{N}{n_{i}}$， $(i \\in (1, 2, 3, \\cdots , k))$。2.令$t_{i} = N_{i}^{-1}$，则$t_{i}N_{i} \\equiv 1 \\pmod n_{i}$，$(i \\in (1, 2, 3, \\cdots , k))$。3.方程组的通解形式为$S = a_{1}t_{1}N_{1}+a_{2}t_{2}N_{2}+\\cdots +a_{k}t_{k}N_{k} + pN = pN + \\sum_{i=1}^{k}a_{i}t_{i}N_{i}$，$(p\\in \\mathbb{Z})$。在$\\pmod n$的的意义下方程有且仅有一解$x = \\sum_{i=1}^{k}a_{i}t_{i}N_{i}$ 。 证明有我们假设的知道$gcd(n_{i},N_{i}) = 1$，所以说明存在整数$t$使得$t_{i}N_{i} \\equiv 1\\pmod n_{i}$成立。$\\because a_{i}t_{i}N_{i} \\equiv a_{i}\\cdot 1\\equiv a_{i}\\ (mod \\ n_{i})$又$\\because j \\in (1,2,\\cdots, n), \\ j\\neq i, \\ a_{i}t_{i}N_{i}\\equiv 0 \\ (mod \\ n_{j})$$\\therefore x = a_{1}t_{1}N_{1}+a_{2}t_{2}N_{2}+\\cdots +a_{k}t_{k}N_{k}$满足：$i\\in (1, 2, \\cdots , k), \\ x = a_{i}t_{i}N_{i}+ \\sum_{j\\neq i} a_{j}t_{j}N_{j}\\equiv a_{i}+\\sum_{j\\neq i}0\\equiv a_{i}\\ (mod \\ n_{i})$。若$x_{1},x_{2}$均为模方程组的解，同理可证。综上所述，模方程的解集为$(pN + \\sum_{i=1}^{k}a_{i}t_{i}N_{i},p \\in \\mathbb{Z})$。 上面比较抽象，现在我们举一个实际一点的栗子=￣ω￣=。今有物，不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？根据上面的证明可知，$n_{1} = 3, n_{2} = 5,n_{3} = 7$，$N_{1} = 35,N_{2} = 21,N_{3} = 15$，$t_{1} = 2, t_{2} = 1,t_{3} = 1$。带入可得：$\\therefore x = 233 + p \\times 105(p\\in \\mathbb{Z})$，当$p = -2$时，$x$有最小正正解$23$。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 1000 + 3;int a[MAX], m[MAX];int n;void exgcd(LL a, LL b, LL&amp; x, LL&amp; y)&#123; if(!b)&#123; x = 1; y = 0;&#125; else&#123; exgcd(b, a % b, y, x); y -= (a / b) * x; &#125;&#125;LL china(int n, int* a, int *m)&#123; LL M = 1, d, y, x = 0; for(int i = 0; i &lt; n; i++) M *= m[i]; for(int i = 0; i &lt; n; i++)&#123; LL w = M / m[i]; exgcd(m[i], w, d, y); x = (x + y * w * a[i]) % M; &#125; return (x + M) % M;&#125;int main()&#123; scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) scanf(\"%d%d\", &amp;a[i], &amp;m[i]); printf(\"%lld\\n\", china(n, a, m)); return 0;&#125; 费马小定理在$n$是素数的情况下，对任意整数$x$都有$x^{n}\\equiv x\\pmod n$这个定理被称作费马小定理。其中如果$x$无法被$n$整除，那么$x^{n - 1}\\equiv 1\\pmod n$。我们可以用费马小定理求$a$得逆元，求素数。上面式子变形之后得到$a^{-1}\\equiv a^{n-2}\\pmod n$，因此我们可以用快速幂求得$a$的逆元。费马小定理可由欧拉公式证得，这里我就不多赘述啦╮(╯▽╰)╭。 欧拉公式与欧拉函数定义费马小定理在一定程度上与欧拉公式$a^{\\phi (n)}\\equiv 1\\pmod n$具有相似性。欧拉函数可用于求小于$n$且与$n$互素的整数个数。给出正整数$n$的唯一分解式$n = p_{1}^{a^{1}}p_{2}^{a_{2}}p_{3}^{a_{3}}\\cdots p_{k}^{a_{k}}$，求$1, 2, 3,\\cdots ,n$中与$n$互素的数的个数。 证明我们通过正整数$n$的唯一分解因式可以得到$n$的正因数的个数$\\prod_{i=1}^{k}(a_{i}+1)=(a_{1}+1)(a_{2}+1)\\cdots (a_{k}+1)$，而这里并不是这么简单。 我们现在已经证得了欧拉公式，但是因为其中含有$\\phi (n)$所以我们必须找到计算$\\phi (n)$的有效方法，让我们可以完整的应用这个公式。显然可以看出，当$n = p$是素数的时候容易计算$\\phi (n)$，应为每一个整数$1\\leq a\\leq p-1$与$n$互素。因此$\\phi (p) = p-1$。当$n = p^{k}$是素数次幂的时候，我们可以推出$\\phi (p^{k})$的公式。 我们有满足$1 \\leq a\\leq p^{k}$开始没然后丢弃与$p^{k}$不互素的整数，用公式表示是$\\phi (p^{k}) = p^{k} - (a:1\\leq a\\leq p^{k},p\\mid a)$。 数$a$什么时候和$p^{k}$不互素呢=￣ω￣=？因为$p^{k}$仅有的因数是$p$的幂次，所以当$a$被$p$的整除的时候$a$与$p^{k}$不互素。那么有哪些$p$的倍数呢？$p, 2p, 3p, 4p, \\cdots , (p^{k-1} -2)p, (p^{k-1} -1)p,p^{k}$一共有$p^{k-1}$个。所以$\\phi (n) = p^{k}-p^{k-1}$。 更详细的证明可以看这里欧拉函数 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int MAX = 10000 + 3;int n;int phi[MAX];//求与第n个数互素的数的个数int euler_phi(int n) &#123; int m = (int)sqrt(n + 0.5); LL ans = n; for (int i = 2; i &lt;= m; i++) &#123; if (n % i == 0)&#123; ans = ans / i * (i - 1); while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) ans = ans / n * (n - 1); return ans;&#125;//1~n中所有数的欧拉phi函数值 O(nloglogn)void phi_table(int n)&#123; for(int i = 2; i &lt;= n; i++) phi[i] = 0; phi[1] = 1; for(int i = 2; i &lt;= n; i++)&#123; if(!phi[i])&#123; for(int j = i; j &lt;= n; j += i)&#123; if(!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); &#125; &#125; &#125;&#125;int main()&#123; scanf(\"%d\", &amp;n); printf(\"phi(%d) = %d\\n\", n, euler_phi(n)); for(int i = 1; i &lt;= n; i++)&#123; phi_table(i); printf(\"phi[%d] = %d\\n\", i, phi[i]); &#125; return 0;&#125;/*phi(n) 表示的含义是,不超过x且和x互素的整数个数.*/ 好啦，到此为止紫书上所有关于同余与模运算的东西都写完了，终于把坑填好啦&lt;(￣ˇ￣)/。上面大部分重要的内容我都写了详细的证明，也给出了解题的模板。那就这样啦，马上就要学蓝书啦，蓝书上面也只有一个离散对数和指数循环节啦，等我把这两节学完之后再把这个部分完结吧(～o￣3￣)～！","categories":[],"tags":[{"name":"快速幂&快速幂取模","slug":"快速幂-快速幂取模","permalink":"http://yoursite.com/tags/快速幂-快速幂取模/"},{"name":"欧拉函数","slug":"欧拉函数","permalink":"http://yoursite.com/tags/欧拉函数/"},{"name":"逆元","slug":"逆元","permalink":"http://yoursite.com/tags/逆元/"},{"name":"模运算","slug":"模运算","permalink":"http://yoursite.com/tags/模运算/"},{"name":"费马小定理","slug":"费马小定理","permalink":"http://yoursite.com/tags/费马小定理/"},{"name":"中国剩余定理","slug":"中国剩余定理","permalink":"http://yoursite.com/tags/中国剩余定理/"},{"name":"模线性方程","slug":"模线性方程","permalink":"http://yoursite.com/tags/模线性方程/"}]},{"title":"埃及分数问题","slug":"埃及分数问题","date":"2017-05-23T15:14:46.000Z","updated":"2017-05-23T15:18:26.068Z","comments":true,"path":"2017/05/23/埃及分数问题/","link":"","permalink":"http://yoursite.com/2017/05/23/埃及分数问题/","excerpt":"这篇Blog意在通过埃及分数问题学习和理解迭代加深搜索。 定义迭代加深搜索通常是从小到大枚举不超过$Maxd$或是不小于$Mind$的结点，每次执行的时候只考虑在结点深度不超过$Maxd$或是不小于$Mind$的结点。这样只要解的深度有限那么有限时间内就可有搜索完。简而言之，就是对深度优先搜索进行了一定改进，对搜索树的深度进行控制，即有界深度优先搜索。","text":"这篇Blog意在通过埃及分数问题学习和理解迭代加深搜索。 定义迭代加深搜索通常是从小到大枚举不超过$Maxd$或是不小于$Mind$的结点，每次执行的时候只考虑在结点深度不超过$Maxd$或是不小于$Mind$的结点。这样只要解的深度有限那么有限时间内就可有搜索完。简而言之，就是对深度优先搜索进行了一定改进，对搜索树的深度进行控制，即有界深度优先搜索。 应用埃及分数问题描述在古埃及，人们使用单位分数的和（即$\\frac{1}{a}，a$是自然数）表示一切有理数。例如$\\frac{2}{3}=\\frac{1}{2}+\\frac{1}{6}$，但不允许$\\frac{2}{3}=\\frac{1}{3}+\\frac{1}{3}$。因为在加数中不允许有相同的。对于一个分数$\\frac{a}{b}$，表示方法有很多种，其中加数少的比加数多的好，如果加数个数相同，则最小的分数越大越好。举一个栗子，$\\frac{19}{45}= \\frac{1}{5}+\\frac{1}{6}+\\frac{1}{8}$时最优方案。 分析这道题目理论上是可以用回溯法来实现，但是解答树不仅深度是没有明显的上界的，而且加数的选择在理论上也是无限的。那么深度优先搜索就是连一层都扩展不完。这时候引入迭代加深搜索，如其名字，我们每一次枚举深度上限$Maxd$，每次执行的时候只考虑深度不超过$Maxd$的结点。同时迭代加深搜索另一重要方法就是剪枝，通过题目中推出来的结论进行剪枝，如怎样丢都达不到要求，或是已求出最优解不会存在比这更优的解。例如埃及分数中，我们按照字母递增顺序进行扩展，如果扩展到$i$层时，前$i$个分数之和为$\\frac{c}{d}$，而第i个分数是1/e，则接下来至少还需要$\\frac{(\\frac{a}{b}-\\frac{c}{d})}{\\frac{1}{e}}$个分数总和才能到$\\frac{a}{b}$。比如有$\\frac{19}{45}$,当前搜索到$\\frac{1}{5}+\\frac{1}{100}+\\cdots$ ，则后面的分数每个最大为$\\frac{1}{101}$，至少需要$\\frac{(\\frac{19}{45}-\\frac{1}{5})}{\\frac{1}{101}}= 23$项才能达到$\\frac{19}{45}$，那么前面$22$次迭代是不会考虑到这棵子树的。所以跌倒加深搜索的关键可以估计至少还要多少步才能出解。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;int a, b, maxd;typedef long long LL;LL gcd(LL a, LL b) &#123; return b == 0 ? a : gcd(b, a%b);&#125;inline int get_first(LL a, LL b) &#123; return b/a +1;&#125;const int maxn = 100 + 5;LL v[maxn], ans[maxn];bool better(int d) &#123; for(int i = d; i &gt;= 0; i--)&#123; if(v[i] != ans[i]) &#123; return ans[i] == -1 || v[i] &lt; ans[i]; &#125; &#125; return false;&#125;bool dfs(int d, int from, LL a, LL b) &#123; if(d == maxd) &#123; if(b % a) return false; v[d] = b/a; if(better(d)) memcpy(ans, v, sizeof(LL) * (d+1)); return true; &#125; bool judge = false; from = max(from, get_first(a, b)); for(int i = from; ; i++) &#123; if(b * (maxd+1-d) &lt;= i * a) break; v[d] = i; LL b2 = b*i; LL a2 = a*i - b; LL g = gcd(a2, b2); if(dfs(d+1, i+1, a2/g, b2/g)) judge = true; &#125; return judge;&#125;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif int testcases = 0; while(scanf(\"%d%d\", &amp;a, &amp;b) == 2)&#123; int judge = 0; for(maxd = 1; maxd &lt;= 100; maxd++) &#123; memset(ans, -1, sizeof(ans)); if(dfs(0, get_first(a, b), a, b)) &#123; judge = 1; break; &#125; &#125; cout &lt;&lt; \"Case \" &lt;&lt; ++testcases &lt;&lt; \": \"; if(judge) &#123; cout &lt;&lt; a &lt;&lt; \"/\" &lt;&lt; b &lt;&lt; \"=\"; for(int i = 0; i &lt; maxd; i++) cout &lt;&lt; \"1/\" &lt;&lt; ans[i] &lt;&lt; \"+\"; cout &lt;&lt; \"1/\" &lt;&lt; ans[maxd] &lt;&lt; \"\\n\"; &#125; else cout &lt;&lt; \"No solution.\\n\"; &#125; return 0;&#125; 总结及拓展通常情况下我们需要设一个乐观估价函数，比如，设深度上限为$Maxd$，当前结点$n$的深度为$g(n)$，乐观估价函数为$h(n)$，则当$g(n) + h(n) &gt; Maxd$时需要进行剪枝。如果可以设计一个乐观估价函数，并预测出当前结点至少还需要扩展几层结点才可能有解，这时候迭代加深搜索与A算法结合变成了**IDA算法**。迭代加深搜索通常用于那种搜索树又深又宽、但是解并不是很深的情况，这时广度优先搜索会超空间，而深度优先搜索会超时。这时迭代加深搜索很有用，可是说是在用递归方法在实现广度优先搜索。","categories":[],"tags":[{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"迭代加深搜索","slug":"迭代加深搜索","permalink":"http://yoursite.com/tags/迭代加深搜索/"}]},{"title":"最优配对问题","slug":"最优配对问题","date":"2017-05-23T14:39:06.000Z","updated":"2017-10-27T03:01:01.047Z","comments":true,"path":"2017/05/23/最优配对问题/","link":"","permalink":"http://yoursite.com/2017/05/23/最优配对问题/","excerpt":"第一次学状态压缩DP，在学长的指导下（雾）终于弄明白了。现在就要用算法竞赛入门经典上的一道题来了解状压DP吧，希望这次学过状压DP之后可以不看题解自己做出NOIP Day2T3。感觉自己自己学新的知识学得好慢。 最优配对问题空间里有n个点$P_{0}, P_{1}, P_{2}，···，P_{n - 1}$，你的任务是把它们配成$\\frac{n}{2}$对（n是偶数），使得每一个点恰好在一个点对中。所有点对中两点的距离之和应尽量小。$n \\leq 20 ,\\ |x_{i}|, |y_{i}|, |z_{i}| \\leq 10000$。","text":"第一次学状态压缩DP，在学长的指导下（雾）终于弄明白了。现在就要用算法竞赛入门经典上的一道题来了解状压DP吧，希望这次学过状压DP之后可以不看题解自己做出NOIP Day2T3。感觉自己自己学新的知识学得好慢。 最优配对问题空间里有n个点$P_{0}, P_{1}, P_{2}，···，P_{n - 1}$，你的任务是把它们配成$\\frac{n}{2}$对（n是偶数），使得每一个点恰好在一个点对中。所有点对中两点的距离之和应尽量小。$n \\leq 20 ,\\ |x_{i}|, |y_{i}|, |z_{i}| \\leq 10000$。 符合动态规划的条件 既然每一个点都要配对，那么我们显然可以看出这是一个多阶段决策问题：首先配对P0，接下来是P1，然后配对P2, ···，最后是Pn-1。 我们可以用反证法来证明其满足最优子结构，无后效性以及重叠子问题的特性。 推导状态转移方程 我一看到这个题，就把它的状态定为$d(i)$ 表示把前$i$个点两两配对的最小距离之和。那么接下来我们思考第i个点和谁配对，此时我们假设它和第j个点两两配对的距离之和最小（$j &lt; i$）。那么为了从$d(i)$转移到$d(i + 1)$我们要先计算出“把前i个点中除j之外的其他点两两配对”，显然，我们无法表示“除点j之外”这个状态，所以这样定义状态不能转移。 因为我们不能转移这个状态，所以我们考虑增加维度来解决这个问题。我们用$d(i, S)$表示前$i$个点中属于集合S的点两两配对得到的最小距离。我们根据前面的思路可以得出这样的状态转移方程：d(i, S) = min \\{ P_{i}P_{j} + d(i - 1, S - {i} - {j}) \\} 怎么来理解这个状态转移方程呢？我们要求得第i个点配对后的最小距离这个状态，是依赖于前$i - 1$个点中属于集合$S - {i} - {j}$的最小距离加上点i和点j的距离之和这个状态的。其中集合$S$表示 集合${1,2,3，······，n}$所有的子集，这里我们用二进制来生成子集，因为二进制生成子集的效率最高代码量也相对于较少。 从一般到优化在实现了用二维描述状态转移方程后我们思考，是否能够降低维度。我们在手推了二维的状态转移方程后，发现其实我们每次都在枚举$i$和$j$，我们考虑一个二进制的序列。既然第一个1早晚需要与后面的$1$来配对，那么我们为什么不固定这个i的位置来枚举j呢？刘汝佳先生是这么解释的：“状态可以进行压缩，$i$的值其实隐藏在S中，S中最高位为$1$的即为$i$，所以需要一次查找,从$n-1$到$0$进行一次历编即可，整个运算下来，平均查找次数仅为$2$。”这句话你手推意会一下就可以了。那么我们尝试求出二进制序列中的第一个$i$，或最后一个i从而来每次枚举j的位置。这样一来状态转移方程可以简化为一维： d(S) = min \\{P_{i}P_{j} + d(S - \\{i \\} - \\{j \\}) \\}代码先回顾下第七章用二进制枚举子集的方法吧！123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int n;void print_subset(int n, int s)&#123; printf(\"%d %d\\n\", n, s); for(int i = 0; i &lt; n; i++)&#123; if(s &amp; (1&lt;&lt;i)) printf(\"%d \", i); &#125; printf(\"\\n\");&#125;int main()&#123;#ifndef DEBUG //freopen(\"test1.in\",\"r\",stdin);#endif scanf(\"%d\", &amp;n); for(int i = 0; i &lt; (1&lt;&lt;n); i++)&#123;// i = 0 ~ 2的n次方 - 1 print_subset(n, i); &#125; return 0;&#125; 方法一：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAX = 20 + 3;const double INF = 1e9;int n, S;struct Node&#123; int x, y, z;&#125;node[MAX];double dp[MAX][1 &lt;&lt; MAX];double dis(Node &amp;a, Node &amp;b)&#123; return sqrt((double)(a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y) + (a.z - b.z)*(a.z - b.z));&#125;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) scanf(\"%d%d%d\", &amp;node[i].x, &amp;node[i].y, &amp;node[i].z); for(int i = 0; i &lt; n; i++)&#123; for(int s = 0; s &lt; (1 &lt;&lt; (i + 1)); s++)&#123; if(s == 0) dp[i][s] = 0; else dp[i][s] = INF; if((s &amp; (1 &lt;&lt; i)))&#123; for(int j = i - 1; j &gt;= 0; j--) if((s &amp; (1 &lt;&lt; j))) dp[i][s] = min(dp[i][s], dis(node[i], node[j]) + dp[i - 1][s^(1 &lt;&lt; i)^(1 &lt;&lt; j)]); &#125; else if(i != 0)&#123; dp[i][s] = dp[i - 1][s]; &#125; &#125; &#125; printf(\"%.3lf\\n\", dp[n - 1][(1 &lt;&lt; n) - 1]); return 0;&#125; 方法二：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int MAX = 20 + 3;const double INF = 1e9;int n, S;struct Node&#123; int x, y, z;&#125;node[MAX];double dp[1 &lt;&lt; MAX];double dis(Node &amp;a, Node &amp;b)&#123; return sqrt((double)(a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y) + (a.z - b.z)*(a.z - b.z));&#125;int main()&#123;#ifndef DEBUG //freopen(\"test1.in\",\"r\",stdin);#endif scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) scanf(\"%d%d%d\", &amp;node[i].x, &amp;node[i].y, &amp;node[i].z); dp[0] = 0; for(int S = 1; S &lt; (1 &lt;&lt; n); S++)&#123; int i, j; dp[S] = INF; for(i = 0; i &lt; n; i++) if(S &amp; (1 &lt;&lt; i)) break; for(j = i + 1; j &lt; n; j++) if(S &amp; (1 &lt;&lt; j)) dp[S] = min(dp[S], dis(node[i], node[j]) + dp[S^(1 &lt;&lt; i)^(1 &lt;&lt; j)]); &#125; printf(\"%.3lf\\n\", dp[1 &lt;&lt; n - 1]);//注意运算优先级 return 0;&#125; 总结好啦，到此为止最优配对问题就做出来了。那么现在你明白了状压DP是什么了吗？其实我们从这道状压的基本题就可以看出状压DP实际上是将平面上离散的点压进二进制表示的集合中，有时候题目中不一定明确的说明它是离散的点，有时候可能是图的顶点，数轴上的坐标。那么我们怎样通过一道题目的描述知道这道题目的知识点是考状压DP的呢？最显著的一个特点是题目中的n通常很小，通常小于23，这时候你可能会问为什么？首先我们明白状压DP是把离散的点压成二进制表示的集合，我们假设我们可以用一维数组来表示状态，通常情况下空间有32M，换算成int类的字节就是8388608字节，等于2的23次方。所以呀n不能太大，不然空间会爆掉的0w0！","categories":[],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://yoursite.com/tags/动态规划/"},{"name":"状压DP","slug":"状压DP","permalink":"http://yoursite.com/tags/状压DP/"}]},{"title":"Uva 816 - Abbott's Revenge","slug":"Uva-816-Abbott-s-Revenge","date":"2017-05-23T14:33:38.000Z","updated":"2017-05-28T04:30:38.350Z","comments":true,"path":"2017/05/23/Uva-816-Abbott-s-Revenge/","link":"","permalink":"http://yoursite.com/2017/05/23/Uva-816-Abbott-s-Revenge/","excerpt":"表示蒟蒻搜索弱爆了，还是做题太少了。 题目地址 描述有一个最多包含$9\\cdot 9$个交叉点的迷宫。输入起点， 离开起点时的朝向和终点，求一条最短路（多解时任意输出一个即可）。","text":"表示蒟蒻搜索弱爆了，还是做题太少了。 题目地址 描述有一个最多包含$9\\cdot 9$个交叉点的迷宫。输入起点， 离开起点时的朝向和终点，求一条最短路（多解时任意输出一个即可）。 分析这道迷宫类型的题和以往有些不一样，这次又增添了许多细节和限制条件。如，进入一个交叉点的方向（用$NEWS$这四个字母分别表示北东四南）不同，允许出去的方向也不同（$FLR$这三个字母分别是直行左转和右转）。到这里为止，通过已有的题意描述，很自然你会想到第三章节《数组和字符串》中对于常量数组的应用。接着往下继续，去掉以上这些细节的牵制，这道题目本质上和其它的迷宫题是一样的，但是对于这道题朝向是起到了至关重要的作用，所#E以这里我们用一个三元组$(r,c,dir)$来描述位于$(r,c)$面朝$dir$的状态。对于我们设置的这个状态，我们假设入口位置的坐标是$(r, c)$，朝向$dir$，但是实际上初始状态并不是$(r,c,dir)$，而是$(r’,c’,dir’)$沿方向$dir$走一步之后的坐标。然后用$d[r][c][dir]$表示初始状态到$(r, c, dir)$的最短路的长度， 并且用$p[r][c][dir]$ 来保存状态$(r, c, dir)$在$BFS$树中的父节点（一遍后来打印路径可以应用$vector$保存结点，用循环避免递归时溢出，并且更加灵活）。 对于很多迷宫问题都可以转化为最短路问题通过$BFS$和$DFS$来求解。但是在套用框架之前，我们一定要明白这两种搜索方式的适用范围，和图中结点所包含的内容。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const double Pi = 4 * atan(1);const int MAX = 200 + 3;int dr[] = &#123;-1, 0, 1, 0&#125;;int dc[] = &#123;0, 1, 0, -1&#125;;struct Node&#123; int r, c, dir; Node(int rr, int cc, int dd)&#123; r = rr; c = cc; dir = dd; &#125; Node()&#123;&#125;&#125;;const char * dirs = \"NESW\";const char * turns = \"FLR\";bool Edge[10][10][4][4];int d[10][10][4];int r1,c1,dir;int r0,c0;int r2,c2;bool flag;Node p[10][10][4];int dir_id(char C) &#123; return strchr(dirs, C) - dirs; &#125;int turn_id(char C) &#123; return strchr(turns, C) - turns; &#125;Node Walk(const Node&amp; u, int turn)&#123; int dir = u.dir; if(turn == 1) dir = (dir + 3) % 4; if(turn == 2) dir = (dir + 1) % 4; return Node(u.r + dr[dir], u.c + dc[dir], dir);&#125;bool inside(int r, int c)&#123; if(r &gt; 0 &amp;&amp; r &lt; 10 &amp;&amp; c &gt; 0 &amp;&amp; c &lt; 10) return true; return false;&#125;void print_ans(Node u)&#123; vector&lt;Node&gt; vec; while(1)&#123; vec.push_back(u); if(d[u.r][u.c][u.dir] == 0) break; u = p[u.r][u.c][u.dir]; &#125; vec.push_back(Node(r0, c0, dir)); int cnt = 0; for(int i = vec.size() - 1; i &gt;= 0; i --)&#123; if(cnt % 10 == 0) printf(\" \"); printf(\" (%d,%d)\", vec[i].r, vec[i].c); if(++ cnt % 10 == 0) printf(\"\\n\"); &#125; if(vec.size() % 10 != 0) printf(\"\\n\");&#125;void Bfs()&#123; queue&lt;Node&gt; q; memset(d, -1, sizeof(d)); memset(p, 0, sizeof(p)); Node u(r1, c1, dir); d[u.r][u.c][u.dir] = 0; q.push(u); while(!q.empty())&#123; Node u = q.front(); q.pop(); if(u.r == r2 &amp;&amp; u.c == c2)&#123; flag = 0; print_ans(u); return; &#125; for(int i = 0; i &lt; 3; i ++)&#123; Node v = Walk(u, i); if(Edge[u.r][u.c][u.dir][i] &amp;&amp; inside(v.r, v.c) &amp;&amp; d[v.r][v.c][v.dir] &lt; 0)&#123; d[v.r][v.c][v.dir] = d[u.r][u.c][u.dir] + 1; p[v.r][v.c][v.dir] = u; q.push(v); &#125; &#125; &#125;&#125;int main()&#123;#ifndef ONLINE_JUDGE //freopen(\"test.in\",\"r\",stdin);#endif char str[30]; while(~scanf(\"%s\",str) &amp;&amp; strcmp(str,\"END\"))&#123; printf(\"%s\\n\",str); flag = 1; memset(Edge,0,sizeof(Edge)); char ch; cin &gt;&gt; r0 &gt;&gt; c0 &gt;&gt; ch &gt;&gt; r2 &gt;&gt; c2; dir = dir_id(ch); r1 = r0 + dr[dir]; c1 = c0 + dc[dir]; int r,c; char str2[30]; while(cin &gt;&gt; r)&#123; if(r == 0)&#123; break; &#125; cin &gt;&gt; c; while(cin &gt;&gt; str2)&#123; if(str2[0] == '*') break; int dirID = dir_id(str2[0]); int len = strlen(str2); for(int i = 1;i &lt; len;i++)&#123; int turnID = turn_id(str2[i]); Edge[r][c][dirID][turnID] = 1; &#125; &#125; &#125; Bfs(); if(flag)&#123; cout &lt;&lt; \" No Solution Possible\" &lt;&lt; endl; &#125; getchar(); &#125; return 0;&#125; $update$: 无权图上的最短路可用BFS求解","categories":[],"tags":[{"name":"DFS及BFS","slug":"DFS及BFS","permalink":"http://yoursite.com/tags/DFS及BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"暴力","slug":"暴力","permalink":"http://yoursite.com/tags/暴力/"}]},{"title":"UVa 10976 - Fractions Again?!","slug":"UVa-10976-Fractions-Again","date":"2017-05-23T14:19:51.000Z","updated":"2017-05-28T04:32:09.055Z","comments":true,"path":"2017/05/23/UVa-10976-Fractions-Again/","link":"","permalink":"http://yoursite.com/2017/05/23/UVa-10976-Fractions-Again/","excerpt":"题目描述 描述输入正整数K，找出所有得正整数 $x\\geq y$，使得$\\frac{1}{k}=\\frac{1}{x}+\\frac{1}{y}$。","text":"题目描述 描述输入正整数K，找出所有得正整数 $x\\geq y$，使得$\\frac{1}{k}=\\frac{1}{x}+\\frac{1}{y}$。 分析首先想到的是枚举出所有的正整数$x，y$使之成立。那么枚举的范围如何确定呢？有样例我们可以看出x，y之间的大小差别可大可小。再反过来观察题目中所给出的条件正整数$x，y$，$x\\geq y$ ,由此可知必然有 $\\frac{1}{x}\\leq \\frac{1}{y}$。那么 $\\frac{1}{k}=\\frac{1}{x}+\\frac{1}{y}$就可以转换成为 $\\frac{1}{k}-\\frac{1}{y}\\leq \\frac{1}{y}$，即$y\\leq 2k$。至此我们就求出了枚举的范围了，接下来只用在$2k$的范围内枚举$y$，然后根据尝试计算出$x$即可。 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;utility&gt;//pair#include &lt;algorithm&gt;using namespace std;int k;vector&lt; pair&lt;int, int&gt; &gt; vec;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif while(scanf(\"%d\\n\", &amp;k) == 1)&#123; int sum = 0; vec.clear(); for(int i = k + 1; i &lt;= 2 * k; i ++)&#123; if((i * k) % (i - k) == 0)&#123; sum ++; vec.push_back(make_pair((i * k) / (i - k), i)); &#125; &#125; printf(\"%d\\n\", sum); for(unsigned int i = 0; i &lt; vec.size(); i ++) printf(\"1/%d = 1/%d + 1/%d\\n\", k, vec[i].first, vec[i].second); &#125; return 0;&#125; 这里灵活的应用了pair 和 make_pair。同时还要注意到循环的边界。","categories":[],"tags":[{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"暴力","slug":"暴力","permalink":"http://yoursite.com/tags/暴力/"}]},{"title":"UVa 839 - Not so Mobile","slug":"UVa-839-Not-so-Mobile","date":"2017-05-23T14:10:51.000Z","updated":"2017-05-28T04:30:51.340Z","comments":true,"path":"2017/05/23/UVa-839-Not-so-Mobile/","link":"","permalink":"http://yoursite.com/2017/05/23/UVa-839-Not-so-Mobile/","excerpt":"题目地址 描述输入一个树状天平，根据力矩相等原则判断是否平衡（$W_{l}\\cdot D_{l} = W_{r}\\cdot D_{r}$）。采用先序（递归）方式输入：每一个天平的格式为$W_{l},D_{l},W_{r},D_{r}$，当$W_{l}$ 或 $W_{r}$为$0$时，表示该砝码实际上是一个子天平，接下来会描述这个子天平。当$W_{l} = W_{r} = 0$时，会先描述左子天平，然后是右子天平。","text":"题目地址 描述输入一个树状天平，根据力矩相等原则判断是否平衡（$W_{l}\\cdot D_{l} = W_{r}\\cdot D_{r}$）。采用先序（递归）方式输入：每一个天平的格式为$W_{l},D_{l},W_{r},D_{r}$，当$W_{l}$ 或 $W_{r}$为$0$时，表示该砝码实际上是一个子天平，接下来会描述这个子天平。当$W_{l} = W_{r} = 0$时，会先描述左子天平，然后是右子天平。 分析如图首先根据所给出的样例来理解题意。理解题意之后再来仔细看这道题，因为这道题目的输入是递归输入，所以我们就顺着题意走，用递归来建树。写一个bool solve，在建树的过程中同时完成判断（使用引用传值），输入一个子天平，返回子天平是否平衡，将参数W修改为子天平的总重量，这样由最下层的子天平逐渐递归到树状天平的根。 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int T,W;bool solve(int&amp; W)&#123; int W1, D1, W2, D2; bool b1 = true; bool b2 = true; cin &gt;&gt; W1 &gt;&gt; D1 &gt;&gt; W2 &gt;&gt; D2; if(!W1) b1 = solve(W1); if(!W2) b2 = solve(W2); W = W1 + W2; return b1 &amp;&amp; b2 &amp;&amp; (W1 * D1 == W2 * D2);&#125;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif scanf(\"%d\", &amp;T); while(T --)&#123; if(solve(W)) printf(\"YES\\n\"); else printf(\"NO\\n\"); if(T) printf(\"\\n\"); &#125; return 0;&#125; 每次在写递归的时候一定要多问自己几次递归的定义，递归的步骤，递归结束的条件是什么。一个类似的题目。UVa 699最后推荐一篇关于递归入门的好文章。递归算法详解把前面丢失的博客找回来了，(^o^)/","categories":[],"tags":[{"name":"UVa","slug":"UVa","permalink":"http://yoursite.com/tags/UVa/"},{"name":"二叉树的递归遍历","slug":"二叉树的递归遍历","permalink":"http://yoursite.com/tags/二叉树的递归遍历/"}]},{"title":"路径寻找问题及哈希表","slug":"路径寻找问题及哈希表","date":"2017-05-23T13:59:51.000Z","updated":"2017-05-23T15:18:46.858Z","comments":true,"path":"2017/05/23/路径寻找问题及哈希表/","link":"","permalink":"http://yoursite.com/2017/05/23/路径寻找问题及哈希表/","excerpt":"这一篇Blog着重写的应该是Hash吧，路径寻找问题在应用中会稍微提到一点。 定义 若关键字为k，则其值存放在f(k) 的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系 f为散列函数，按这个思想建立的表为散列表。 对不同的关键字可能得到同一散列地址，即k1 ≠ k2 ，而 f(k1) = f(k2)，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数 f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。 若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数，这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。","text":"这一篇Blog着重写的应该是Hash吧，路径寻找问题在应用中会稍微提到一点。 定义 若关键字为k，则其值存放在f(k) 的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系 f为散列函数，按这个思想建立的表为散列表。 对不同的关键字可能得到同一散列地址，即k1 ≠ k2 ，而 f(k1) = f(k2)，这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数 f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。 若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数，这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。 应用八数码问题描述编号为1~8的8个正方形滑块被摆成3行3列（有一个格子留空），如图7-14所示。每次可以把与空格相邻的滑块（有公共边才算相邻）移到空格中，而它原来的位置就成为了新的空格。给定初始局面和目标局面（用0表示空格），你的任务是计算出最少的移动步数，如果无法到达目标局面，则输出-1。 图7 - 14 分析看完题目之后，我们不难想到将八数码问题归结为图上的最短路问题，图中的结点就是9个格子里的滑块编号（从上到下，从左到右把它们放在一个包含9个元素的数组中）。而且这副图上的权都为1，所以不难想到用BFS来求解。而且，只要用到BFS一定要进行判重，为避免同一个结点访问很多次，提高空间和时间复杂度（树的BFS不用判重，而图的BFS要进行判重，想一想为什么？）。对于判重而言，就有很多种方式了。 第一种方法是：把排列变为整数，然后开一个一维数组。也就是设计一套排列的编码和解码函数，然后一一对应起来。 第二种方法是用STL里的set集合，先把状态转换为9为十进制整数，然后用set进行判重。但这两种办法对于需要判重的数很多的时候，不仅不会降低复杂度反而还会提升。 第三种做法哈希表。简而言之就是把结点变为整数，但不一定是要一一对应的，只需要设计一个哈希函数，然后将任意结点映射到某一个指定范围[0，M - 1]内，其中M是由我们自己定的，要根据要开的数组大小来选择（也就是我们说得HashSize）。而HushSize有是有目前的数的个数（结点的个数）来确定的，通常在估算完结点个数后，取比结点个数大20%~50%的质数作为HushSize。每次用数模HushSize，然后取其余数，把这个数接到余数所对应的链表后。举一个栗子，如图我们有数7, 12，29，38，57，98。这里我们取HushSize为11，7mod11余7（所以把7放在链表从上往下数0,1,2,3,4,5,6,7，第七个位置后接起来），对于mod之后余数相同的数，我们的做法不同图上所显示的方法，而是要充分的利用链表的特性把大的数放在前面（相同的每次用vector来push_back把大的数放在后面，但是由于每用STL时都要动态的分配空间，同样会使时间复杂度升高），所以这里我们采用刘汝佳的方法，用数组模拟链表来做。1234567891011121314151617181920212223const int hashsize = 1000003;int head[hashsize], next[MaxState];void init_lookup_table()&#123;memset(head, 0, sizeof(head));&#125;int hash(State&amp; s)&#123; int v = 0; for(int i = 0; i &lt; 9; i++) v = v * 10 + s[i];//把九个数字组合成九位数（对于八数码而言） return v % hashsize;//确保Hash函数的值是不超过Huah表的大小的非负整数&#125;int try_to_insert(int s)&#123; int h = hash(st[s]);//调用Hush int u = head[h];//从表头开始查找链表 while(u)&#123; if(memcmp(st[u], st[s], sizeof(st[s])) == 0) return 0;//找到了重复的，所以插入失败 u = next[u];//顺着链表继续找 &#125; next[s] = head[h];//插入链表中 head[h] = s; return 1;&#125; 想一想为什么最后才将数插入链表，顺序为什么是这样子的？在看完Hush算法后，我们再回来理一理这道题目的思路。首先，把这道题目归结为路径寻找问题，想到用BFS来求解（套用BFS框架）；因为BFS要判重所以我们引入Hush。最后提一下这道题目中一个重要的技巧，也就是使用Hush的一个前提之一，将3*3的格子中的每行或三列的三个数由字符转为一个三位数。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;typedef int State[9];const int MaxState = 1000000;State st[MaxState], goal;int dist[MaxState];const int dx[] = &#123; -1, 1, 0, 0&#125;;const int dy[] = &#123; 0, 0, -1, 1&#125;;const int hashsize = 1000003;int head[hashsize], next[MaxState];void init_lookup_table()&#123;memset(head, 0, sizeof(head));&#125;int hash(State&amp; s)&#123; int v = 0; for(int i = 0; i &lt; 9; i++) v = v * 10 + s[i]; return v % hashsize;&#125;int try_to_insert(int s)&#123; int h = hash(st[s]); int u = head[h]; while(u)&#123; if(memcmp(st[u], st[s], sizeof(st[s])) == 0) return 0; u = next[u]; &#125; next[s] = head[h]; head[h] = s; return 1;&#125;int bfs()&#123; init_lookup_table(); int front = 1, rear = 2; while(front &lt; rear)&#123; State&amp; s = st[front]; if(memcmp(goal, s, sizeof(s)) == 0) return front; int z; for(z = 0; z &lt; 9; z++) if(!s[z]) break; int x = z / 3, y = z % 3; for(int d = 0; d &lt; 4; d++)&#123; int NewX = x + dx[d]; int NewY = y + dy[d]; int NewZ = NewX * 3 + NewY; if(NewX &gt;= 0 &amp;&amp; NewX &lt; 3 &amp;&amp; NewY &gt;= 0 &amp;&amp; NewY &lt; 3)&#123; State&amp; t = st[rear]; memcpy(&amp;t, &amp;s, sizeof(s)); t[NewZ] = s[z]; t[z] = s[NewZ]; dist[rear] = dist[front] + 1; if(try_to_insert(rear)) rear++; &#125; &#125; front++; &#125; return 0;&#125;int main()&#123;#ifndef DEBUG //freopen(\"test.in\",\"r\",stdin);#endif for(int i = 0; i &lt; 9; i++) scanf(\"%d\", &amp;st[1][i]); for(int i = 0; i &lt; 9; i++) scanf(\"%d\", &amp;goal[i]); int ans = bfs(); if(ans &gt; 0) printf(\"%d\\n\", dist[ans]); else printf(\"-1\\n\"); return 0;&#125; 拓展很多问题都可以和归结为图的遍历，但这些问题中图不是是事先给出的，从程序读入的，而是有程序动态生成的，称为隐式图。回溯法（关于回溯法的总结我就先不写啦，有时间再来填坑吧！^-^）一般是要找一个（或所有）满足约束状态的解（或者是某种意义状态下的最优解），而状态空间搜索一般是要寻找一个从初始状态到终止状态的路径，所以把路径寻找问题归结为隐式图的遍历。隐式图的遍历需要一个结点查找表来判重，一般可以先用STL中的set来写（代码量最小，最简单，但时间效率很低），后面有时间在将其用Hush的方式来写一遍，避免出错，如果你对Hush表很熟练，那么就可以直接写哒！","categories":[],"tags":[{"name":"DFS及BFS","slug":"DFS及BFS","permalink":"http://yoursite.com/tags/DFS及BFS/"},{"name":"搜索","slug":"搜索","permalink":"http://yoursite.com/tags/搜索/"},{"name":"哈希表","slug":"哈希表","permalink":"http://yoursite.com/tags/哈希表/"}]}]}